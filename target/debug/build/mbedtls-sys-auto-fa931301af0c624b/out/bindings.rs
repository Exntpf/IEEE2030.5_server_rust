/* automatically generated by rust-bindgen 0.58.1 */

#![allow(dead_code, deref_nullptr, non_snake_case, non_camel_case_types, non_upper_case_globals, invalid_value)]

# [repr (C)] # [derive (Copy , Clone , Debug , Default , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct __BindgenBitfieldUnit < Storage > { storage : Storage , } impl < Storage > __BindgenBitfieldUnit < Storage > { # [inline] pub const fn new (storage : Storage) -> Self { Self { storage } } } impl < Storage > __BindgenBitfieldUnit < Storage > where Storage : AsRef < [u8] > + AsMut < [u8] >, { # [inline] pub fn get_bit (& self , index : usize) -> bool { debug_assert ! (index / 8 < self . storage . as_ref () . len ()) ; let byte_index = index / 8 ; let byte = self . storage . as_ref () [byte_index] ; let bit_index = if cfg ! (target_endian = "big") { 7 - (index % 8) } else { index % 8 } ; let mask = 1 << bit_index ; byte & mask == mask } # [inline] pub fn set_bit (& mut self , index : usize , val : bool) { debug_assert ! (index / 8 < self . storage . as_ref () . len ()) ; let byte_index = index / 8 ; let byte = & mut self . storage . as_mut () [byte_index] ; let bit_index = if cfg ! (target_endian = "big") { 7 - (index % 8) } else { index % 8 } ; let mask = 1 << bit_index ; if val { * byte |= mask ; } else { * byte &= ! mask ; } } # [inline] pub fn get (& self , bit_offset : usize , bit_width : u8) -> u64 { debug_assert ! (bit_width <= 64) ; debug_assert ! (bit_offset / 8 < self . storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width as usize)) / 8 <= self . storage . as_ref () . len ()) ; let mut val = 0 ; for i in 0 .. (bit_width as usize) { if self . get_bit (i + bit_offset) { let index = if cfg ! (target_endian = "big") { bit_width as usize - 1 - i } else { i } ; val |= 1 << index ; } } val } # [inline] pub fn set (& mut self , bit_offset : usize , bit_width : u8 , val : u64) { debug_assert ! (bit_width <= 64) ; debug_assert ! (bit_offset / 8 < self . storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width as usize)) / 8 <= self . storage . as_ref () . len ()) ; for i in 0 .. (bit_width as usize) { let mask = 1 << i ; let val_bit_is_set = val & mask == mask ; let index = if cfg ! (target_endian = "big") { bit_width as usize - 1 - i } else { i } ; self . set_bit (index + bit_offset , val_bit_is_set) ; } } } pub const ERR_MPI_FILE_IO_ERROR : :: types :: raw_types :: c_int = - 2 ; pub const ERR_MPI_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 4 ; pub const ERR_MPI_INVALID_CHARACTER : :: types :: raw_types :: c_int = - 6 ; pub const ERR_MPI_BUFFER_TOO_SMALL : :: types :: raw_types :: c_int = - 8 ; pub const ERR_MPI_NEGATIVE_VALUE : :: types :: raw_types :: c_int = - 10 ; pub const ERR_MPI_DIVISION_BY_ZERO : :: types :: raw_types :: c_int = - 12 ; pub const ERR_MPI_NOT_ACCEPTABLE : :: types :: raw_types :: c_int = - 14 ; pub const ERR_MPI_ALLOC_FAILED : :: types :: raw_types :: c_int = - 16 ; pub const MPI_MAX_LIMBS : :: types :: raw_types :: c_int = 10000 ; pub const MPI_WINDOW_SIZE : :: types :: raw_types :: c_int = 6 ; pub const MPI_MAX_SIZE : :: types :: raw_types :: c_int = 1024 ; pub const MPI_MAX_BITS : :: types :: raw_types :: c_int = 8192 ; pub const MPI_MAX_BITS_SCALE100 : :: types :: raw_types :: c_int = 819200 ; pub const LN_2_DIV_LN_10_SCALE100 : :: types :: raw_types :: c_int = 332 ; pub const MPI_RW_BUFFER_SIZE : :: types :: raw_types :: c_int = 2484 ; pub const ERR_MD_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 20608 ; pub const ERR_MD_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 20736 ; pub const ERR_MD_ALLOC_FAILED : :: types :: raw_types :: c_int = - 20864 ; pub const ERR_MD_FILE_IO_ERROR : :: types :: raw_types :: c_int = - 20992 ; pub const ERR_MD_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 21120 ; pub const MD_MAX_SIZE : :: types :: raw_types :: c_int = 64 ; pub const MD_MAX_BLOCK_SIZE : :: types :: raw_types :: c_int = 128 ; pub const ERR_THREADING_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 26 ; pub const ERR_THREADING_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 28 ; pub const ERR_THREADING_MUTEX_ERROR : :: types :: raw_types :: c_int = - 30 ; pub const ERR_ECP_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 20352 ; pub const ERR_ECP_BUFFER_TOO_SMALL : :: types :: raw_types :: c_int = - 20224 ; pub const ERR_ECP_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 20096 ; pub const ERR_ECP_VERIFY_FAILED : :: types :: raw_types :: c_int = - 19968 ; pub const ERR_ECP_ALLOC_FAILED : :: types :: raw_types :: c_int = - 19840 ; pub const ERR_ECP_RANDOM_FAILED : :: types :: raw_types :: c_int = - 19712 ; pub const ERR_ECP_INVALID_KEY : :: types :: raw_types :: c_int = - 19584 ; pub const ERR_ECP_SIG_LEN_MISMATCH : :: types :: raw_types :: c_int = - 19456 ; pub const ERR_ECP_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 19328 ; pub const ERR_ECP_IN_PROGRESS : :: types :: raw_types :: c_int = - 19200 ; pub const ECP_DP_MAX : :: types :: raw_types :: c_int = 12 ; pub const ECP_MAX_BITS_MIN : :: types :: raw_types :: c_int = 521 ; pub const ECP_MAX_BITS : :: types :: raw_types :: c_int = 521 ; pub const ECP_MAX_BYTES : :: types :: raw_types :: c_int = 66 ; pub const ECP_MAX_PT_LEN : :: types :: raw_types :: c_int = 133 ; pub const ECP_WINDOW_SIZE : :: types :: raw_types :: c_int = 4 ; pub const ECP_FIXED_POINT_OPTIM : :: types :: raw_types :: c_int = 1 ; pub const ECP_PF_UNCOMPRESSED : :: types :: raw_types :: c_int = 0 ; pub const ECP_PF_COMPRESSED : :: types :: raw_types :: c_int = 1 ; pub const ECP_TLS_NAMED_CURVE : :: types :: raw_types :: c_int = 3 ; pub const ERR_RSA_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 16512 ; pub const ERR_RSA_INVALID_PADDING : :: types :: raw_types :: c_int = - 16640 ; pub const ERR_RSA_KEY_GEN_FAILED : :: types :: raw_types :: c_int = - 16768 ; pub const ERR_RSA_KEY_CHECK_FAILED : :: types :: raw_types :: c_int = - 16896 ; pub const ERR_RSA_PUBLIC_FAILED : :: types :: raw_types :: c_int = - 17024 ; pub const ERR_RSA_PRIVATE_FAILED : :: types :: raw_types :: c_int = - 17152 ; pub const ERR_RSA_VERIFY_FAILED : :: types :: raw_types :: c_int = - 17280 ; pub const ERR_RSA_OUTPUT_TOO_LARGE : :: types :: raw_types :: c_int = - 17408 ; pub const ERR_RSA_RNG_FAILED : :: types :: raw_types :: c_int = - 17536 ; pub const ERR_RSA_UNSUPPORTED_OPERATION : :: types :: raw_types :: c_int = - 17664 ; pub const ERR_RSA_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 17792 ; pub const RSA_PUBLIC : :: types :: raw_types :: c_int = 0 ; pub const RSA_PRIVATE : :: types :: raw_types :: c_int = 1 ; pub const RSA_PKCS_V15 : :: types :: raw_types :: c_int = 0 ; pub const RSA_PKCS_V21 : :: types :: raw_types :: c_int = 1 ; pub const RSA_SIGN : :: types :: raw_types :: c_int = 1 ; pub const RSA_CRYPT : :: types :: raw_types :: c_int = 2 ; pub const RSA_SALT_LEN_ANY : :: types :: raw_types :: c_int = - 1 ; pub const ERR_ASN1_OUT_OF_DATA : :: types :: raw_types :: c_int = - 96 ; pub const ERR_ASN1_UNEXPECTED_TAG : :: types :: raw_types :: c_int = - 98 ; pub const ERR_ASN1_INVALID_LENGTH : :: types :: raw_types :: c_int = - 100 ; pub const ERR_ASN1_LENGTH_MISMATCH : :: types :: raw_types :: c_int = - 102 ; pub const ERR_ASN1_INVALID_DATA : :: types :: raw_types :: c_int = - 104 ; pub const ERR_ASN1_ALLOC_FAILED : :: types :: raw_types :: c_int = - 106 ; pub const ERR_ASN1_BUF_TOO_SMALL : :: types :: raw_types :: c_int = - 108 ; pub const ASN1_BOOLEAN : :: types :: raw_types :: c_int = 1 ; pub const ASN1_INTEGER : :: types :: raw_types :: c_int = 2 ; pub const ASN1_BIT_STRING : :: types :: raw_types :: c_int = 3 ; pub const ASN1_OCTET_STRING : :: types :: raw_types :: c_int = 4 ; pub const ASN1_NULL : :: types :: raw_types :: c_int = 5 ; pub const ASN1_OID : :: types :: raw_types :: c_int = 6 ; pub const ASN1_ENUMERATED : :: types :: raw_types :: c_int = 10 ; pub const ASN1_UTF8_STRING : :: types :: raw_types :: c_int = 12 ; pub const ASN1_SEQUENCE : :: types :: raw_types :: c_int = 16 ; pub const ASN1_SET : :: types :: raw_types :: c_int = 17 ; pub const ASN1_PRINTABLE_STRING : :: types :: raw_types :: c_int = 19 ; pub const ASN1_T61_STRING : :: types :: raw_types :: c_int = 20 ; pub const ASN1_IA5_STRING : :: types :: raw_types :: c_int = 22 ; pub const ASN1_UTC_TIME : :: types :: raw_types :: c_int = 23 ; pub const ASN1_GENERALIZED_TIME : :: types :: raw_types :: c_int = 24 ; pub const ASN1_UNIVERSAL_STRING : :: types :: raw_types :: c_int = 28 ; pub const ASN1_BMP_STRING : :: types :: raw_types :: c_int = 30 ; pub const ASN1_PRIMITIVE : :: types :: raw_types :: c_int = 0 ; pub const ASN1_CONSTRUCTED : :: types :: raw_types :: c_int = 32 ; pub const ASN1_CONTEXT_SPECIFIC : :: types :: raw_types :: c_int = 128 ; pub const ASN1_TAG_CLASS_MASK : :: types :: raw_types :: c_int = 192 ; pub const ASN1_TAG_PC_MASK : :: types :: raw_types :: c_int = 32 ; pub const ASN1_TAG_VALUE_MASK : :: types :: raw_types :: c_int = 31 ; pub const ERR_PK_ALLOC_FAILED : :: types :: raw_types :: c_int = - 16256 ; pub const ERR_PK_TYPE_MISMATCH : :: types :: raw_types :: c_int = - 16128 ; pub const ERR_PK_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 16000 ; pub const ERR_PK_FILE_IO_ERROR : :: types :: raw_types :: c_int = - 15872 ; pub const ERR_PK_KEY_INVALID_VERSION : :: types :: raw_types :: c_int = - 15744 ; pub const ERR_PK_KEY_INVALID_FORMAT : :: types :: raw_types :: c_int = - 15616 ; pub const ERR_PK_UNKNOWN_PK_ALG : :: types :: raw_types :: c_int = - 15488 ; pub const ERR_PK_PASSWORD_REQUIRED : :: types :: raw_types :: c_int = - 15360 ; pub const ERR_PK_PASSWORD_MISMATCH : :: types :: raw_types :: c_int = - 15232 ; pub const ERR_PK_INVALID_PUBKEY : :: types :: raw_types :: c_int = - 15104 ; pub const ERR_PK_INVALID_ALG : :: types :: raw_types :: c_int = - 14976 ; pub const ERR_PK_UNKNOWN_NAMED_CURVE : :: types :: raw_types :: c_int = - 14848 ; pub const ERR_PK_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 14720 ; pub const ERR_PK_SIG_LEN_MISMATCH : :: types :: raw_types :: c_int = - 14592 ; pub const ERR_PK_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 14464 ; pub const PK_SIGNATURE_MAX_SIZE : :: types :: raw_types :: c_int = 0 ; pub const PK_DEBUG_MAX_ITEMS : :: types :: raw_types :: c_int = 3 ; pub const X509_MAX_INTERMEDIATE_CA : :: types :: raw_types :: c_int = 8 ; pub const ERR_X509_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 8320 ; pub const ERR_X509_UNKNOWN_OID : :: types :: raw_types :: c_int = - 8448 ; pub const ERR_X509_INVALID_FORMAT : :: types :: raw_types :: c_int = - 8576 ; pub const ERR_X509_INVALID_VERSION : :: types :: raw_types :: c_int = - 8704 ; pub const ERR_X509_INVALID_SERIAL : :: types :: raw_types :: c_int = - 8832 ; pub const ERR_X509_INVALID_ALG : :: types :: raw_types :: c_int = - 8960 ; pub const ERR_X509_INVALID_NAME : :: types :: raw_types :: c_int = - 9088 ; pub const ERR_X509_INVALID_DATE : :: types :: raw_types :: c_int = - 9216 ; pub const ERR_X509_INVALID_SIGNATURE : :: types :: raw_types :: c_int = - 9344 ; pub const ERR_X509_INVALID_EXTENSIONS : :: types :: raw_types :: c_int = - 9472 ; pub const ERR_X509_UNKNOWN_VERSION : :: types :: raw_types :: c_int = - 9600 ; pub const ERR_X509_UNKNOWN_SIG_ALG : :: types :: raw_types :: c_int = - 9728 ; pub const ERR_X509_SIG_MISMATCH : :: types :: raw_types :: c_int = - 9856 ; pub const ERR_X509_CERT_VERIFY_FAILED : :: types :: raw_types :: c_int = - 9984 ; pub const ERR_X509_CERT_UNKNOWN_FORMAT : :: types :: raw_types :: c_int = - 10112 ; pub const ERR_X509_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 10240 ; pub const ERR_X509_ALLOC_FAILED : :: types :: raw_types :: c_int = - 10368 ; pub const ERR_X509_FILE_IO_ERROR : :: types :: raw_types :: c_int = - 10496 ; pub const ERR_X509_BUFFER_TOO_SMALL : :: types :: raw_types :: c_int = - 10624 ; pub const ERR_X509_FATAL_ERROR : :: types :: raw_types :: c_int = - 12288 ; pub const X509_BADCERT_EXPIRED : :: types :: raw_types :: c_int = 1 ; pub const X509_BADCERT_REVOKED : :: types :: raw_types :: c_int = 2 ; pub const X509_BADCERT_CN_MISMATCH : :: types :: raw_types :: c_int = 4 ; pub const X509_BADCERT_NOT_TRUSTED : :: types :: raw_types :: c_int = 8 ; pub const X509_BADCRL_NOT_TRUSTED : :: types :: raw_types :: c_int = 16 ; pub const X509_BADCRL_EXPIRED : :: types :: raw_types :: c_int = 32 ; pub const X509_BADCERT_MISSING : :: types :: raw_types :: c_int = 64 ; pub const X509_BADCERT_SKIP_VERIFY : :: types :: raw_types :: c_int = 128 ; pub const X509_BADCERT_OTHER : :: types :: raw_types :: c_int = 256 ; pub const X509_BADCERT_FUTURE : :: types :: raw_types :: c_int = 512 ; pub const X509_BADCRL_FUTURE : :: types :: raw_types :: c_int = 1024 ; pub const X509_BADCERT_KEY_USAGE : :: types :: raw_types :: c_int = 2048 ; pub const X509_BADCERT_EXT_KEY_USAGE : :: types :: raw_types :: c_int = 4096 ; pub const X509_BADCERT_NS_CERT_TYPE : :: types :: raw_types :: c_int = 8192 ; pub const X509_BADCERT_BAD_MD : :: types :: raw_types :: c_int = 16384 ; pub const X509_BADCERT_BAD_PK : :: types :: raw_types :: c_int = 32768 ; pub const X509_BADCERT_BAD_KEY : :: types :: raw_types :: c_int = 65536 ; pub const X509_BADCRL_BAD_MD : :: types :: raw_types :: c_int = 131072 ; pub const X509_BADCRL_BAD_PK : :: types :: raw_types :: c_int = 262144 ; pub const X509_BADCRL_BAD_KEY : :: types :: raw_types :: c_int = 524288 ; pub const X509_SAN_OTHER_NAME : :: types :: raw_types :: c_int = 0 ; pub const X509_SAN_RFC822_NAME : :: types :: raw_types :: c_int = 1 ; pub const X509_SAN_DNS_NAME : :: types :: raw_types :: c_int = 2 ; pub const X509_SAN_X400_ADDRESS_NAME : :: types :: raw_types :: c_int = 3 ; pub const X509_SAN_DIRECTORY_NAME : :: types :: raw_types :: c_int = 4 ; pub const X509_SAN_EDI_PARTY_NAME : :: types :: raw_types :: c_int = 5 ; pub const X509_SAN_UNIFORM_RESOURCE_IDENTIFIER : :: types :: raw_types :: c_int = 6 ; pub const X509_SAN_IP_ADDRESS : :: types :: raw_types :: c_int = 7 ; pub const X509_SAN_REGISTERED_ID : :: types :: raw_types :: c_int = 8 ; pub const X509_KU_DIGITAL_SIGNATURE : :: types :: raw_types :: c_int = 128 ; pub const X509_KU_NON_REPUDIATION : :: types :: raw_types :: c_int = 64 ; pub const X509_KU_KEY_ENCIPHERMENT : :: types :: raw_types :: c_int = 32 ; pub const X509_KU_DATA_ENCIPHERMENT : :: types :: raw_types :: c_int = 16 ; pub const X509_KU_KEY_AGREEMENT : :: types :: raw_types :: c_int = 8 ; pub const X509_KU_KEY_CERT_SIGN : :: types :: raw_types :: c_int = 4 ; pub const X509_KU_CRL_SIGN : :: types :: raw_types :: c_int = 2 ; pub const X509_KU_ENCIPHER_ONLY : :: types :: raw_types :: c_int = 1 ; pub const X509_KU_DECIPHER_ONLY : :: types :: raw_types :: c_int = 32768 ; pub const X509_NS_CERT_TYPE_SSL_CLIENT : :: types :: raw_types :: c_int = 128 ; pub const X509_NS_CERT_TYPE_SSL_SERVER : :: types :: raw_types :: c_int = 64 ; pub const X509_NS_CERT_TYPE_EMAIL : :: types :: raw_types :: c_int = 32 ; pub const X509_NS_CERT_TYPE_OBJECT_SIGNING : :: types :: raw_types :: c_int = 16 ; pub const X509_NS_CERT_TYPE_RESERVED : :: types :: raw_types :: c_int = 8 ; pub const X509_NS_CERT_TYPE_SSL_CA : :: types :: raw_types :: c_int = 4 ; pub const X509_NS_CERT_TYPE_EMAIL_CA : :: types :: raw_types :: c_int = 2 ; pub const X509_NS_CERT_TYPE_OBJECT_SIGNING_CA : :: types :: raw_types :: c_int = 1 ; pub const X509_FORMAT_DER : :: types :: raw_types :: c_int = 1 ; pub const X509_FORMAT_PEM : :: types :: raw_types :: c_int = 2 ; pub const X509_MAX_DN_NAME_SIZE : :: types :: raw_types :: c_int = 256 ; pub const ERR_CIPHER_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 24704 ; pub const ERR_CIPHER_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 24832 ; pub const ERR_CIPHER_ALLOC_FAILED : :: types :: raw_types :: c_int = - 24960 ; pub const ERR_CIPHER_INVALID_PADDING : :: types :: raw_types :: c_int = - 25088 ; pub const ERR_CIPHER_FULL_BLOCK_EXPECTED : :: types :: raw_types :: c_int = - 25216 ; pub const ERR_CIPHER_AUTH_FAILED : :: types :: raw_types :: c_int = - 25344 ; pub const ERR_CIPHER_INVALID_CONTEXT : :: types :: raw_types :: c_int = - 25472 ; pub const ERR_CIPHER_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 25600 ; pub const CIPHER_VARIABLE_IV_LEN : :: types :: raw_types :: c_int = 1 ; pub const CIPHER_VARIABLE_KEY_LEN : :: types :: raw_types :: c_int = 2 ; pub const MAX_IV_LENGTH : :: types :: raw_types :: c_int = 16 ; pub const MAX_BLOCK_LENGTH : :: types :: raw_types :: c_int = 16 ; pub const MAX_KEY_LENGTH : :: types :: raw_types :: c_int = 64 ; pub const AES_ENCRYPT : :: types :: raw_types :: c_int = 1 ; pub const AES_DECRYPT : :: types :: raw_types :: c_int = 0 ; pub const ERR_AES_INVALID_KEY_LENGTH : :: types :: raw_types :: c_int = - 32 ; pub const ERR_AES_INVALID_INPUT_LENGTH : :: types :: raw_types :: c_int = - 34 ; pub const ERR_AES_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 33 ; pub const ERR_AES_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 35 ; pub const ERR_AES_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 37 ; pub const TLS_RSA_WITH_NULL_MD5 : :: types :: raw_types :: c_int = 1 ; pub const TLS_RSA_WITH_NULL_SHA : :: types :: raw_types :: c_int = 2 ; pub const TLS_RSA_WITH_RC4_128_MD5 : :: types :: raw_types :: c_int = 4 ; pub const TLS_RSA_WITH_RC4_128_SHA : :: types :: raw_types :: c_int = 5 ; pub const TLS_RSA_WITH_DES_CBC_SHA : :: types :: raw_types :: c_int = 9 ; pub const TLS_RSA_WITH_3DES_EDE_CBC_SHA : :: types :: raw_types :: c_int = 10 ; pub const TLS_DHE_RSA_WITH_DES_CBC_SHA : :: types :: raw_types :: c_int = 21 ; pub const TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA : :: types :: raw_types :: c_int = 22 ; pub const TLS_PSK_WITH_NULL_SHA : :: types :: raw_types :: c_int = 44 ; pub const TLS_DHE_PSK_WITH_NULL_SHA : :: types :: raw_types :: c_int = 45 ; pub const TLS_RSA_PSK_WITH_NULL_SHA : :: types :: raw_types :: c_int = 46 ; pub const TLS_RSA_WITH_AES_128_CBC_SHA : :: types :: raw_types :: c_int = 47 ; pub const TLS_DHE_RSA_WITH_AES_128_CBC_SHA : :: types :: raw_types :: c_int = 51 ; pub const TLS_RSA_WITH_AES_256_CBC_SHA : :: types :: raw_types :: c_int = 53 ; pub const TLS_DHE_RSA_WITH_AES_256_CBC_SHA : :: types :: raw_types :: c_int = 57 ; pub const TLS_RSA_WITH_NULL_SHA256 : :: types :: raw_types :: c_int = 59 ; pub const TLS_RSA_WITH_AES_128_CBC_SHA256 : :: types :: raw_types :: c_int = 60 ; pub const TLS_RSA_WITH_AES_256_CBC_SHA256 : :: types :: raw_types :: c_int = 61 ; pub const TLS_RSA_WITH_CAMELLIA_128_CBC_SHA : :: types :: raw_types :: c_int = 65 ; pub const TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA : :: types :: raw_types :: c_int = 69 ; pub const TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 : :: types :: raw_types :: c_int = 103 ; pub const TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 : :: types :: raw_types :: c_int = 107 ; pub const TLS_RSA_WITH_CAMELLIA_256_CBC_SHA : :: types :: raw_types :: c_int = 132 ; pub const TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA : :: types :: raw_types :: c_int = 136 ; pub const TLS_PSK_WITH_RC4_128_SHA : :: types :: raw_types :: c_int = 138 ; pub const TLS_PSK_WITH_3DES_EDE_CBC_SHA : :: types :: raw_types :: c_int = 139 ; pub const TLS_PSK_WITH_AES_128_CBC_SHA : :: types :: raw_types :: c_int = 140 ; pub const TLS_PSK_WITH_AES_256_CBC_SHA : :: types :: raw_types :: c_int = 141 ; pub const TLS_DHE_PSK_WITH_RC4_128_SHA : :: types :: raw_types :: c_int = 142 ; pub const TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA : :: types :: raw_types :: c_int = 143 ; pub const TLS_DHE_PSK_WITH_AES_128_CBC_SHA : :: types :: raw_types :: c_int = 144 ; pub const TLS_DHE_PSK_WITH_AES_256_CBC_SHA : :: types :: raw_types :: c_int = 145 ; pub const TLS_RSA_PSK_WITH_RC4_128_SHA : :: types :: raw_types :: c_int = 146 ; pub const TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA : :: types :: raw_types :: c_int = 147 ; pub const TLS_RSA_PSK_WITH_AES_128_CBC_SHA : :: types :: raw_types :: c_int = 148 ; pub const TLS_RSA_PSK_WITH_AES_256_CBC_SHA : :: types :: raw_types :: c_int = 149 ; pub const TLS_RSA_WITH_AES_128_GCM_SHA256 : :: types :: raw_types :: c_int = 156 ; pub const TLS_RSA_WITH_AES_256_GCM_SHA384 : :: types :: raw_types :: c_int = 157 ; pub const TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 : :: types :: raw_types :: c_int = 158 ; pub const TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 : :: types :: raw_types :: c_int = 159 ; pub const TLS_PSK_WITH_AES_128_GCM_SHA256 : :: types :: raw_types :: c_int = 168 ; pub const TLS_PSK_WITH_AES_256_GCM_SHA384 : :: types :: raw_types :: c_int = 169 ; pub const TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 : :: types :: raw_types :: c_int = 170 ; pub const TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 : :: types :: raw_types :: c_int = 171 ; pub const TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 : :: types :: raw_types :: c_int = 172 ; pub const TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 : :: types :: raw_types :: c_int = 173 ; pub const TLS_PSK_WITH_AES_128_CBC_SHA256 : :: types :: raw_types :: c_int = 174 ; pub const TLS_PSK_WITH_AES_256_CBC_SHA384 : :: types :: raw_types :: c_int = 175 ; pub const TLS_PSK_WITH_NULL_SHA256 : :: types :: raw_types :: c_int = 176 ; pub const TLS_PSK_WITH_NULL_SHA384 : :: types :: raw_types :: c_int = 177 ; pub const TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 : :: types :: raw_types :: c_int = 178 ; pub const TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 : :: types :: raw_types :: c_int = 179 ; pub const TLS_DHE_PSK_WITH_NULL_SHA256 : :: types :: raw_types :: c_int = 180 ; pub const TLS_DHE_PSK_WITH_NULL_SHA384 : :: types :: raw_types :: c_int = 181 ; pub const TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 : :: types :: raw_types :: c_int = 182 ; pub const TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 : :: types :: raw_types :: c_int = 183 ; pub const TLS_RSA_PSK_WITH_NULL_SHA256 : :: types :: raw_types :: c_int = 184 ; pub const TLS_RSA_PSK_WITH_NULL_SHA384 : :: types :: raw_types :: c_int = 185 ; pub const TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 186 ; pub const TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 190 ; pub const TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 : :: types :: raw_types :: c_int = 192 ; pub const TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 : :: types :: raw_types :: c_int = 196 ; pub const TLS_ECDH_ECDSA_WITH_NULL_SHA : :: types :: raw_types :: c_int = 49153 ; pub const TLS_ECDH_ECDSA_WITH_RC4_128_SHA : :: types :: raw_types :: c_int = 49154 ; pub const TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA : :: types :: raw_types :: c_int = 49155 ; pub const TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA : :: types :: raw_types :: c_int = 49156 ; pub const TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA : :: types :: raw_types :: c_int = 49157 ; pub const TLS_ECDHE_ECDSA_WITH_NULL_SHA : :: types :: raw_types :: c_int = 49158 ; pub const TLS_ECDHE_ECDSA_WITH_RC4_128_SHA : :: types :: raw_types :: c_int = 49159 ; pub const TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA : :: types :: raw_types :: c_int = 49160 ; pub const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA : :: types :: raw_types :: c_int = 49161 ; pub const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA : :: types :: raw_types :: c_int = 49162 ; pub const TLS_ECDH_RSA_WITH_NULL_SHA : :: types :: raw_types :: c_int = 49163 ; pub const TLS_ECDH_RSA_WITH_RC4_128_SHA : :: types :: raw_types :: c_int = 49164 ; pub const TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA : :: types :: raw_types :: c_int = 49165 ; pub const TLS_ECDH_RSA_WITH_AES_128_CBC_SHA : :: types :: raw_types :: c_int = 49166 ; pub const TLS_ECDH_RSA_WITH_AES_256_CBC_SHA : :: types :: raw_types :: c_int = 49167 ; pub const TLS_ECDHE_RSA_WITH_NULL_SHA : :: types :: raw_types :: c_int = 49168 ; pub const TLS_ECDHE_RSA_WITH_RC4_128_SHA : :: types :: raw_types :: c_int = 49169 ; pub const TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA : :: types :: raw_types :: c_int = 49170 ; pub const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA : :: types :: raw_types :: c_int = 49171 ; pub const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA : :: types :: raw_types :: c_int = 49172 ; pub const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49187 ; pub const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49188 ; pub const TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49189 ; pub const TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49190 ; pub const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49191 ; pub const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49192 ; pub const TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49193 ; pub const TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49194 ; pub const TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49195 ; pub const TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49196 ; pub const TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49197 ; pub const TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49198 ; pub const TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49199 ; pub const TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49200 ; pub const TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49201 ; pub const TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49202 ; pub const TLS_ECDHE_PSK_WITH_RC4_128_SHA : :: types :: raw_types :: c_int = 49203 ; pub const TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA : :: types :: raw_types :: c_int = 49204 ; pub const TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA : :: types :: raw_types :: c_int = 49205 ; pub const TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA : :: types :: raw_types :: c_int = 49206 ; pub const TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49207 ; pub const TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49208 ; pub const TLS_ECDHE_PSK_WITH_NULL_SHA : :: types :: raw_types :: c_int = 49209 ; pub const TLS_ECDHE_PSK_WITH_NULL_SHA256 : :: types :: raw_types :: c_int = 49210 ; pub const TLS_ECDHE_PSK_WITH_NULL_SHA384 : :: types :: raw_types :: c_int = 49211 ; pub const TLS_RSA_WITH_ARIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49212 ; pub const TLS_RSA_WITH_ARIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49213 ; pub const TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49220 ; pub const TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49221 ; pub const TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49224 ; pub const TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49225 ; pub const TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49226 ; pub const TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49227 ; pub const TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49228 ; pub const TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49229 ; pub const TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49230 ; pub const TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49231 ; pub const TLS_RSA_WITH_ARIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49232 ; pub const TLS_RSA_WITH_ARIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49233 ; pub const TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49234 ; pub const TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49235 ; pub const TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49244 ; pub const TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49245 ; pub const TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49246 ; pub const TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49247 ; pub const TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49248 ; pub const TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49249 ; pub const TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49250 ; pub const TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49251 ; pub const TLS_PSK_WITH_ARIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49252 ; pub const TLS_PSK_WITH_ARIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49253 ; pub const TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49254 ; pub const TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49255 ; pub const TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49256 ; pub const TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49257 ; pub const TLS_PSK_WITH_ARIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49258 ; pub const TLS_PSK_WITH_ARIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49259 ; pub const TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49260 ; pub const TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49261 ; pub const TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49262 ; pub const TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49263 ; pub const TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49264 ; pub const TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49265 ; pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49266 ; pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49267 ; pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49268 ; pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49269 ; pub const TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49270 ; pub const TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49271 ; pub const TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49272 ; pub const TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49273 ; pub const TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49274 ; pub const TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49275 ; pub const TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49276 ; pub const TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49277 ; pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49286 ; pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49287 ; pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49288 ; pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49289 ; pub const TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49290 ; pub const TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49291 ; pub const TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49292 ; pub const TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49293 ; pub const TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49294 ; pub const TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49295 ; pub const TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49296 ; pub const TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49297 ; pub const TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 : :: types :: raw_types :: c_int = 49298 ; pub const TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 : :: types :: raw_types :: c_int = 49299 ; pub const TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49300 ; pub const TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49301 ; pub const TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49302 ; pub const TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49303 ; pub const TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49304 ; pub const TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49305 ; pub const TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 : :: types :: raw_types :: c_int = 49306 ; pub const TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 : :: types :: raw_types :: c_int = 49307 ; pub const TLS_RSA_WITH_AES_128_CCM : :: types :: raw_types :: c_int = 49308 ; pub const TLS_RSA_WITH_AES_256_CCM : :: types :: raw_types :: c_int = 49309 ; pub const TLS_DHE_RSA_WITH_AES_128_CCM : :: types :: raw_types :: c_int = 49310 ; pub const TLS_DHE_RSA_WITH_AES_256_CCM : :: types :: raw_types :: c_int = 49311 ; pub const TLS_RSA_WITH_AES_128_CCM_8 : :: types :: raw_types :: c_int = 49312 ; pub const TLS_RSA_WITH_AES_256_CCM_8 : :: types :: raw_types :: c_int = 49313 ; pub const TLS_DHE_RSA_WITH_AES_128_CCM_8 : :: types :: raw_types :: c_int = 49314 ; pub const TLS_DHE_RSA_WITH_AES_256_CCM_8 : :: types :: raw_types :: c_int = 49315 ; pub const TLS_PSK_WITH_AES_128_CCM : :: types :: raw_types :: c_int = 49316 ; pub const TLS_PSK_WITH_AES_256_CCM : :: types :: raw_types :: c_int = 49317 ; pub const TLS_DHE_PSK_WITH_AES_128_CCM : :: types :: raw_types :: c_int = 49318 ; pub const TLS_DHE_PSK_WITH_AES_256_CCM : :: types :: raw_types :: c_int = 49319 ; pub const TLS_PSK_WITH_AES_128_CCM_8 : :: types :: raw_types :: c_int = 49320 ; pub const TLS_PSK_WITH_AES_256_CCM_8 : :: types :: raw_types :: c_int = 49321 ; pub const TLS_DHE_PSK_WITH_AES_128_CCM_8 : :: types :: raw_types :: c_int = 49322 ; pub const TLS_DHE_PSK_WITH_AES_256_CCM_8 : :: types :: raw_types :: c_int = 49323 ; pub const TLS_ECDHE_ECDSA_WITH_AES_128_CCM : :: types :: raw_types :: c_int = 49324 ; pub const TLS_ECDHE_ECDSA_WITH_AES_256_CCM : :: types :: raw_types :: c_int = 49325 ; pub const TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 : :: types :: raw_types :: c_int = 49326 ; pub const TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 : :: types :: raw_types :: c_int = 49327 ; pub const TLS_ECJPAKE_WITH_AES_128_CCM_8 : :: types :: raw_types :: c_int = 49407 ; pub const TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 : :: types :: raw_types :: c_int = 52392 ; pub const TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 : :: types :: raw_types :: c_int = 52393 ; pub const TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 : :: types :: raw_types :: c_int = 52394 ; pub const TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 : :: types :: raw_types :: c_int = 52395 ; pub const TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 : :: types :: raw_types :: c_int = 52396 ; pub const TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 : :: types :: raw_types :: c_int = 52397 ; pub const TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 : :: types :: raw_types :: c_int = 52398 ; pub const CIPHERSUITE_WEAK : :: types :: raw_types :: c_int = 1 ; pub const CIPHERSUITE_SHORT_TAG : :: types :: raw_types :: c_int = 2 ; pub const CIPHERSUITE_NODTLS : :: types :: raw_types :: c_int = 4 ; pub const X509_CRT_VERSION_1 : :: types :: raw_types :: c_int = 0 ; pub const X509_CRT_VERSION_2 : :: types :: raw_types :: c_int = 1 ; pub const X509_CRT_VERSION_3 : :: types :: raw_types :: c_int = 2 ; pub const X509_RFC5280_MAX_SERIAL_LEN : :: types :: raw_types :: c_int = 32 ; pub const X509_RFC5280_UTC_TIME_LEN : :: types :: raw_types :: c_int = 15 ; pub const X509_MAX_FILE_PATH_LEN : :: types :: raw_types :: c_int = 512 ; pub const X509_MAX_VERIFY_CHAIN_SIZE : :: types :: raw_types :: c_int = 10 ; pub const ERR_DHM_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 12416 ; pub const ERR_DHM_READ_PARAMS_FAILED : :: types :: raw_types :: c_int = - 12544 ; pub const ERR_DHM_MAKE_PARAMS_FAILED : :: types :: raw_types :: c_int = - 12672 ; pub const ERR_DHM_READ_PUBLIC_FAILED : :: types :: raw_types :: c_int = - 12800 ; pub const ERR_DHM_MAKE_PUBLIC_FAILED : :: types :: raw_types :: c_int = - 12928 ; pub const ERR_DHM_CALC_SECRET_FAILED : :: types :: raw_types :: c_int = - 13056 ; pub const ERR_DHM_INVALID_FORMAT : :: types :: raw_types :: c_int = - 13184 ; pub const ERR_DHM_ALLOC_FAILED : :: types :: raw_types :: c_int = - 13312 ; pub const ERR_DHM_FILE_IO_ERROR : :: types :: raw_types :: c_int = - 13440 ; pub const ERR_DHM_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 13568 ; pub const ERR_DHM_SET_GROUP_FAILED : :: types :: raw_types :: c_int = - 13696 ; pub const ERR_OID_NOT_FOUND : :: types :: raw_types :: c_int = - 46 ; pub const ERR_OID_BUF_TOO_SMALL : :: types :: raw_types :: c_int = - 11 ; pub const OID_X509_EXT_AUTHORITY_KEY_IDENTIFIER : :: types :: raw_types :: c_int = 1 ; pub const OID_X509_EXT_SUBJECT_KEY_IDENTIFIER : :: types :: raw_types :: c_int = 2 ; pub const OID_X509_EXT_KEY_USAGE : :: types :: raw_types :: c_int = 4 ; pub const OID_X509_EXT_CERTIFICATE_POLICIES : :: types :: raw_types :: c_int = 8 ; pub const OID_X509_EXT_POLICY_MAPPINGS : :: types :: raw_types :: c_int = 16 ; pub const OID_X509_EXT_SUBJECT_ALT_NAME : :: types :: raw_types :: c_int = 32 ; pub const OID_X509_EXT_ISSUER_ALT_NAME : :: types :: raw_types :: c_int = 64 ; pub const OID_X509_EXT_SUBJECT_DIRECTORY_ATTRS : :: types :: raw_types :: c_int = 128 ; pub const OID_X509_EXT_BASIC_CONSTRAINTS : :: types :: raw_types :: c_int = 256 ; pub const OID_X509_EXT_NAME_CONSTRAINTS : :: types :: raw_types :: c_int = 512 ; pub const OID_X509_EXT_POLICY_CONSTRAINTS : :: types :: raw_types :: c_int = 1024 ; pub const OID_X509_EXT_EXTENDED_KEY_USAGE : :: types :: raw_types :: c_int = 2048 ; pub const OID_X509_EXT_CRL_DISTRIBUTION_POINTS : :: types :: raw_types :: c_int = 4096 ; pub const OID_X509_EXT_INIHIBIT_ANYPOLICY : :: types :: raw_types :: c_int = 8192 ; pub const OID_X509_EXT_FRESHEST_CRL : :: types :: raw_types :: c_int = 16384 ; pub const OID_X509_EXT_NS_CERT_TYPE : :: types :: raw_types :: c_int = 65536 ; pub const OID_ISO_MEMBER_BODIES : & 'static [u8 ; 2usize] = b"*\0" ; pub const OID_ISO_IDENTIFIED_ORG : & 'static [u8 ; 2usize] = b"+\0" ; pub const OID_ISO_CCITT_DS : & 'static [u8 ; 2usize] = b"U\0" ; pub const OID_ISO_ITU_COUNTRY : & 'static [u8 ; 2usize] = b"`\0" ; pub const OID_COUNTRY_US : [u8 ; 3usize] = [134u8 , 72u8 , 0u8] ; pub const OID_ORG_RSA_DATA_SECURITY : [u8 ; 4usize] = [134u8 , 247u8 , 13u8 , 0u8] ; pub const OID_RSA_COMPANY : [u8 ; 7usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 0u8] ; pub const OID_ORG_ANSI_X9_62 : [u8 ; 3usize] = [206u8 , 61u8 , 0u8] ; pub const OID_ANSI_X9_62 : [u8 ; 6usize] = [42u8 , 134u8 , 72u8 , 206u8 , 61u8 , 0u8] ; pub const OID_ORG_DOD : & 'static [u8 ; 2usize] = b"\x06\0" ; pub const OID_ORG_OIW : & 'static [u8 ; 2usize] = b"\x0E\0" ; pub const OID_OIW_SECSIG : & 'static [u8 ; 3usize] = b"\x0E\x03\0" ; pub const OID_OIW_SECSIG_ALG : & 'static [u8 ; 4usize] = b"\x0E\x03\x02\0" ; pub const OID_OIW_SECSIG_SHA1 : & 'static [u8 ; 5usize] = b"\x0E\x03\x02\x1A\0" ; pub const OID_ORG_CERTICOM : [u8 ; 3usize] = [129u8 , 4u8 , 0u8] ; pub const OID_CERTICOM : [u8 ; 4usize] = [43u8 , 129u8 , 4u8 , 0u8] ; pub const OID_ORG_TELETRUST : & 'static [u8 ; 2usize] = b"$\0" ; pub const OID_TELETRUST : & 'static [u8 ; 3usize] = b"+$\0" ; pub const OID_ORGANIZATION : & 'static [u8 ; 2usize] = b"\x01\0" ; pub const OID_ISO_ITU_US_ORG : [u8 ; 5usize] = [96u8 , 134u8 , 72u8 , 1u8 , 0u8] ; pub const OID_ORG_GOV : & 'static [u8 ; 2usize] = b"e\0" ; pub const OID_GOV : [u8 ; 6usize] = [96u8 , 134u8 , 72u8 , 1u8 , 101u8 , 0u8] ; pub const OID_ORG_NETSCAPE : [u8 ; 4usize] = [134u8 , 248u8 , 66u8 , 0u8] ; pub const OID_NETSCAPE : [u8 ; 8usize] = [96u8 , 134u8 , 72u8 , 1u8 , 134u8 , 248u8 , 66u8 , 0u8] ; pub const OID_ID_CE : & 'static [u8 ; 3usize] = b"U\x1D\0" ; pub const OID_NIST_ALG : [u8 ; 8usize] = [96u8 , 134u8 , 72u8 , 1u8 , 101u8 , 3u8 , 4u8 , 0u8] ; pub const OID_INTERNET : & 'static [u8 ; 4usize] = b"+\x06\x01\0" ; pub const OID_PKIX : & 'static [u8 ; 7usize] = b"+\x06\x01\x05\x05\x07\0" ; pub const OID_AT : & 'static [u8 ; 3usize] = b"U\x04\0" ; pub const OID_AT_CN : & 'static [u8 ; 4usize] = b"U\x04\x03\0" ; pub const OID_AT_SUR_NAME : & 'static [u8 ; 4usize] = b"U\x04\x04\0" ; pub const OID_AT_SERIAL_NUMBER : & 'static [u8 ; 4usize] = b"U\x04\x05\0" ; pub const OID_AT_COUNTRY : & 'static [u8 ; 4usize] = b"U\x04\x06\0" ; pub const OID_AT_LOCALITY : & 'static [u8 ; 4usize] = b"U\x04\x07\0" ; pub const OID_AT_STATE : & 'static [u8 ; 4usize] = b"U\x04\x08\0" ; pub const OID_AT_ORGANIZATION : & 'static [u8 ; 4usize] = b"U\x04\n\0" ; pub const OID_AT_ORG_UNIT : & 'static [u8 ; 4usize] = b"U\x04\x0B\0" ; pub const OID_AT_TITLE : & 'static [u8 ; 4usize] = b"U\x04\x0C\0" ; pub const OID_AT_POSTAL_ADDRESS : & 'static [u8 ; 4usize] = b"U\x04\x10\0" ; pub const OID_AT_POSTAL_CODE : & 'static [u8 ; 4usize] = b"U\x04\x11\0" ; pub const OID_AT_GIVEN_NAME : & 'static [u8 ; 4usize] = b"U\x04*\0" ; pub const OID_AT_INITIALS : & 'static [u8 ; 4usize] = b"U\x04+\0" ; pub const OID_AT_GENERATION_QUALIFIER : & 'static [u8 ; 4usize] = b"U\x04,\0" ; pub const OID_AT_UNIQUE_IDENTIFIER : & 'static [u8 ; 4usize] = b"U\x04-\0" ; pub const OID_AT_DN_QUALIFIER : & 'static [u8 ; 4usize] = b"U\x04.\0" ; pub const OID_AT_PSEUDONYM : & 'static [u8 ; 4usize] = b"U\x04A\0" ; pub const OID_DOMAIN_COMPONENT : [u8 ; 11usize] = [9u8 , 146u8 , 38u8 , 137u8 , 147u8 , 242u8 , 44u8 , 100u8 , 1u8 , 25u8 , 0u8] ; pub const OID_AUTHORITY_KEY_IDENTIFIER : & 'static [u8 ; 4usize] = b"U\x1D#\0" ; pub const OID_SUBJECT_KEY_IDENTIFIER : & 'static [u8 ; 4usize] = b"U\x1D\x0E\0" ; pub const OID_KEY_USAGE : & 'static [u8 ; 4usize] = b"U\x1D\x0F\0" ; pub const OID_CERTIFICATE_POLICIES : & 'static [u8 ; 4usize] = b"U\x1D \0" ; pub const OID_POLICY_MAPPINGS : & 'static [u8 ; 4usize] = b"U\x1D!\0" ; pub const OID_SUBJECT_ALT_NAME : & 'static [u8 ; 4usize] = b"U\x1D\x11\0" ; pub const OID_ISSUER_ALT_NAME : & 'static [u8 ; 4usize] = b"U\x1D\x12\0" ; pub const OID_SUBJECT_DIRECTORY_ATTRS : & 'static [u8 ; 4usize] = b"U\x1D\t\0" ; pub const OID_BASIC_CONSTRAINTS : & 'static [u8 ; 4usize] = b"U\x1D\x13\0" ; pub const OID_NAME_CONSTRAINTS : & 'static [u8 ; 4usize] = b"U\x1D\x1E\0" ; pub const OID_POLICY_CONSTRAINTS : & 'static [u8 ; 4usize] = b"U\x1D$\0" ; pub const OID_EXTENDED_KEY_USAGE : & 'static [u8 ; 4usize] = b"U\x1D%\0" ; pub const OID_CRL_DISTRIBUTION_POINTS : & 'static [u8 ; 4usize] = b"U\x1D\x1F\0" ; pub const OID_INIHIBIT_ANYPOLICY : & 'static [u8 ; 4usize] = b"U\x1D6\0" ; pub const OID_FRESHEST_CRL : & 'static [u8 ; 4usize] = b"U\x1D.\0" ; pub const OID_ANY_POLICY : & 'static [u8 ; 5usize] = b"U\x1D \0\0" ; pub const OID_NS_CERT : [u8 ; 9usize] = [96u8 , 134u8 , 72u8 , 1u8 , 134u8 , 248u8 , 66u8 , 1u8 , 0u8] ; pub const OID_NS_CERT_TYPE : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 134u8 , 248u8 , 66u8 , 1u8 , 1u8 , 0u8] ; pub const OID_NS_BASE_URL : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 134u8 , 248u8 , 66u8 , 1u8 , 2u8 , 0u8] ; pub const OID_NS_REVOCATION_URL : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 134u8 , 248u8 , 66u8 , 1u8 , 3u8 , 0u8] ; pub const OID_NS_CA_REVOCATION_URL : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 134u8 , 248u8 , 66u8 , 1u8 , 4u8 , 0u8] ; pub const OID_NS_RENEWAL_URL : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 134u8 , 248u8 , 66u8 , 1u8 , 7u8 , 0u8] ; pub const OID_NS_CA_POLICY_URL : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 134u8 , 248u8 , 66u8 , 1u8 , 8u8 , 0u8] ; pub const OID_NS_SSL_SERVER_NAME : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 134u8 , 248u8 , 66u8 , 1u8 , 12u8 , 0u8] ; pub const OID_NS_COMMENT : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 134u8 , 248u8 , 66u8 , 1u8 , 13u8 , 0u8] ; pub const OID_NS_DATA_TYPE : [u8 ; 9usize] = [96u8 , 134u8 , 72u8 , 1u8 , 134u8 , 248u8 , 66u8 , 2u8 , 0u8] ; pub const OID_NS_CERT_SEQUENCE : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 134u8 , 248u8 , 66u8 , 2u8 , 5u8 , 0u8] ; pub const OID_PRIVATE_KEY_USAGE_PERIOD : & 'static [u8 ; 4usize] = b"U\x1D\x10\0" ; pub const OID_CRL_NUMBER : & 'static [u8 ; 4usize] = b"U\x1D\x14\0" ; pub const OID_ANY_EXTENDED_KEY_USAGE : & 'static [u8 ; 5usize] = b"U\x1D%\0\0" ; pub const OID_KP : & 'static [u8 ; 8usize] = b"+\x06\x01\x05\x05\x07\x03\0" ; pub const OID_SERVER_AUTH : & 'static [u8 ; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x01\0" ; pub const OID_CLIENT_AUTH : & 'static [u8 ; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x02\0" ; pub const OID_CODE_SIGNING : & 'static [u8 ; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x03\0" ; pub const OID_EMAIL_PROTECTION : & 'static [u8 ; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x04\0" ; pub const OID_TIME_STAMPING : & 'static [u8 ; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x08\0" ; pub const OID_OCSP_SIGNING : & 'static [u8 ; 9usize] = b"+\x06\x01\x05\x05\x07\x03\t\0" ; pub const OID_WISUN_FAN : [u8 ; 10usize] = [43u8 , 6u8 , 1u8 , 4u8 , 1u8 , 130u8 , 228u8 , 37u8 , 1u8 , 0u8] ; pub const OID_ON : & 'static [u8 ; 8usize] = b"+\x06\x01\x05\x05\x07\x08\0" ; pub const OID_ON_HW_MODULE_NAME : & 'static [u8 ; 9usize] = b"+\x06\x01\x05\x05\x07\x08\x04\0" ; pub const OID_PKCS : [u8 ; 8usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 0u8] ; pub const OID_PKCS1 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 1u8 , 0u8] ; pub const OID_PKCS5 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 5u8 , 0u8] ; pub const OID_PKCS9 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 9u8 , 0u8] ; pub const OID_PKCS12 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 12u8 , 0u8] ; pub const OID_PKCS1_RSA : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 1u8 , 1u8 , 0u8] ; pub const OID_PKCS1_MD2 : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 1u8 , 2u8 , 0u8] ; pub const OID_PKCS1_MD4 : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 1u8 , 3u8 , 0u8] ; pub const OID_PKCS1_MD5 : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 1u8 , 4u8 , 0u8] ; pub const OID_PKCS1_SHA1 : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 1u8 , 5u8 , 0u8] ; pub const OID_PKCS1_SHA224 : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 1u8 , 14u8 , 0u8] ; pub const OID_PKCS1_SHA256 : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 1u8 , 11u8 , 0u8] ; pub const OID_PKCS1_SHA384 : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 1u8 , 12u8 , 0u8] ; pub const OID_PKCS1_SHA512 : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 1u8 , 13u8 , 0u8] ; pub const OID_RSA_SHA_OBS : & 'static [u8 ; 6usize] = b"+\x0E\x03\x02\x1D\0" ; pub const OID_PKCS9_EMAIL : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 9u8 , 1u8 , 0u8] ; pub const OID_RSASSA_PSS : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 1u8 , 10u8 , 0u8] ; pub const OID_MGF1 : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 1u8 , 8u8 , 0u8] ; pub const OID_DIGEST_ALG_MD2 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 2u8 , 2u8 , 0u8] ; pub const OID_DIGEST_ALG_MD4 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 2u8 , 4u8 , 0u8] ; pub const OID_DIGEST_ALG_MD5 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 2u8 , 5u8 , 0u8] ; pub const OID_DIGEST_ALG_SHA1 : & 'static [u8 ; 6usize] = b"+\x0E\x03\x02\x1A\0" ; pub const OID_DIGEST_ALG_SHA224 : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 101u8 , 3u8 , 4u8 , 2u8 , 4u8 , 0u8] ; pub const OID_DIGEST_ALG_SHA256 : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 101u8 , 3u8 , 4u8 , 2u8 , 1u8 , 0u8] ; pub const OID_DIGEST_ALG_SHA384 : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 101u8 , 3u8 , 4u8 , 2u8 , 2u8 , 0u8] ; pub const OID_DIGEST_ALG_SHA512 : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 101u8 , 3u8 , 4u8 , 2u8 , 3u8 , 0u8] ; pub const OID_DIGEST_ALG_RIPEMD160 : & 'static [u8 ; 6usize] = b"+$\x03\x02\x01\0" ; pub const OID_HMAC_SHA1 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 2u8 , 7u8 , 0u8] ; pub const OID_HMAC_SHA224 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 2u8 , 8u8 , 0u8] ; pub const OID_HMAC_SHA256 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 2u8 , 9u8 , 0u8] ; pub const OID_HMAC_SHA384 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 2u8 , 10u8 , 0u8] ; pub const OID_HMAC_SHA512 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 2u8 , 11u8 , 0u8] ; pub const OID_DES_CBC : & 'static [u8 ; 6usize] = b"+\x0E\x03\x02\x07\0" ; pub const OID_DES_EDE3_CBC : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 3u8 , 7u8 , 0u8] ; pub const OID_AES : [u8 ; 9usize] = [96u8 , 134u8 , 72u8 , 1u8 , 101u8 , 3u8 , 4u8 , 1u8 , 0u8] ; pub const OID_AES128_KW : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 101u8 , 3u8 , 4u8 , 1u8 , 5u8 , 0u8] ; pub const OID_AES128_KWP : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 101u8 , 3u8 , 4u8 , 1u8 , 8u8 , 0u8] ; pub const OID_AES192_KW : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 101u8 , 3u8 , 4u8 , 1u8 , 25u8 , 0u8] ; pub const OID_AES192_KWP : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 101u8 , 3u8 , 4u8 , 1u8 , 28u8 , 0u8] ; pub const OID_AES256_KW : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 101u8 , 3u8 , 4u8 , 1u8 , 45u8 , 0u8] ; pub const OID_AES256_KWP : [u8 ; 10usize] = [96u8 , 134u8 , 72u8 , 1u8 , 101u8 , 3u8 , 4u8 , 1u8 , 48u8 , 0u8] ; pub const OID_PKCS5_PBKDF2 : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 5u8 , 12u8 , 0u8] ; pub const OID_PKCS5_PBES2 : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 5u8 , 13u8 , 0u8] ; pub const OID_PKCS5_PBMAC1 : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 5u8 , 14u8 , 0u8] ; pub const OID_PKCS5_PBE_MD2_DES_CBC : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 5u8 , 1u8 , 0u8] ; pub const OID_PKCS5_PBE_MD2_RC2_CBC : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 5u8 , 4u8 , 0u8] ; pub const OID_PKCS5_PBE_MD5_DES_CBC : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 5u8 , 3u8 , 0u8] ; pub const OID_PKCS5_PBE_MD5_RC2_CBC : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 5u8 , 6u8 , 0u8] ; pub const OID_PKCS5_PBE_SHA1_DES_CBC : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 5u8 , 10u8 , 0u8] ; pub const OID_PKCS5_PBE_SHA1_RC2_CBC : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 5u8 , 11u8 , 0u8] ; pub const OID_PKCS9_CSR_EXT_REQ : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 9u8 , 14u8 , 0u8] ; pub const OID_PKCS12_PBE : [u8 ; 10usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 12u8 , 1u8 , 0u8] ; pub const OID_PKCS12_PBE_SHA1_RC4_128 : [u8 ; 11usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 12u8 , 1u8 , 1u8 , 0u8] ; pub const OID_PKCS12_PBE_SHA1_RC4_40 : [u8 ; 11usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 12u8 , 1u8 , 2u8 , 0u8] ; pub const OID_PKCS12_PBE_SHA1_DES3_EDE_CBC : [u8 ; 11usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 12u8 , 1u8 , 3u8 , 0u8] ; pub const OID_PKCS12_PBE_SHA1_DES2_EDE_CBC : [u8 ; 11usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 12u8 , 1u8 , 4u8 , 0u8] ; pub const OID_PKCS12_PBE_SHA1_RC2_128_CBC : [u8 ; 11usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 12u8 , 1u8 , 5u8 , 0u8] ; pub const OID_PKCS12_PBE_SHA1_RC2_40_CBC : [u8 ; 11usize] = [42u8 , 134u8 , 72u8 , 134u8 , 247u8 , 13u8 , 1u8 , 12u8 , 1u8 , 6u8 , 0u8] ; pub const OID_EC_ALG_UNRESTRICTED : [u8 ; 8usize] = [42u8 , 134u8 , 72u8 , 206u8 , 61u8 , 2u8 , 1u8 , 0u8] ; pub const OID_EC_ALG_ECDH : [u8 ; 6usize] = [43u8 , 129u8 , 4u8 , 1u8 , 12u8 , 0u8] ; pub const OID_EC_GRP_SECP192R1 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 206u8 , 61u8 , 3u8 , 1u8 , 1u8 , 0u8] ; pub const OID_EC_GRP_SECP224R1 : [u8 ; 6usize] = [43u8 , 129u8 , 4u8 , 0u8 , 33u8 , 0u8] ; pub const OID_EC_GRP_SECP256R1 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 206u8 , 61u8 , 3u8 , 1u8 , 7u8 , 0u8] ; pub const OID_EC_GRP_SECP384R1 : [u8 ; 6usize] = [43u8 , 129u8 , 4u8 , 0u8 , 34u8 , 0u8] ; pub const OID_EC_GRP_SECP521R1 : [u8 ; 6usize] = [43u8 , 129u8 , 4u8 , 0u8 , 35u8 , 0u8] ; pub const OID_EC_GRP_SECP192K1 : [u8 ; 6usize] = [43u8 , 129u8 , 4u8 , 0u8 , 31u8 , 0u8] ; pub const OID_EC_GRP_SECP224K1 : [u8 ; 6usize] = [43u8 , 129u8 , 4u8 , 0u8 , 32u8 , 0u8] ; pub const OID_EC_GRP_SECP256K1 : [u8 ; 6usize] = [43u8 , 129u8 , 4u8 , 0u8 , 10u8 , 0u8] ; pub const OID_EC_BRAINPOOL_V1 : & 'static [u8 ; 9usize] = b"+$\x03\x03\x02\x08\x01\x01\0" ; pub const OID_EC_GRP_BP256R1 : & 'static [u8 ; 10usize] = b"+$\x03\x03\x02\x08\x01\x01\x07\0" ; pub const OID_EC_GRP_BP384R1 : & 'static [u8 ; 10usize] = b"+$\x03\x03\x02\x08\x01\x01\x0B\0" ; pub const OID_EC_GRP_BP512R1 : & 'static [u8 ; 10usize] = b"+$\x03\x03\x02\x08\x01\x01\r\0" ; pub const OID_ANSI_X9_62_FIELD_TYPE : [u8 ; 7usize] = [42u8 , 134u8 , 72u8 , 206u8 , 61u8 , 1u8 , 0u8] ; pub const OID_ANSI_X9_62_PRIME_FIELD : [u8 ; 8usize] = [42u8 , 134u8 , 72u8 , 206u8 , 61u8 , 1u8 , 1u8 , 0u8] ; pub const OID_ANSI_X9_62_SIG : [u8 ; 7usize] = [42u8 , 134u8 , 72u8 , 206u8 , 61u8 , 4u8 , 0u8] ; pub const OID_ANSI_X9_62_SIG_SHA2 : [u8 ; 8usize] = [42u8 , 134u8 , 72u8 , 206u8 , 61u8 , 4u8 , 3u8 , 0u8] ; pub const OID_ECDSA_SHA1 : [u8 ; 8usize] = [42u8 , 134u8 , 72u8 , 206u8 , 61u8 , 4u8 , 1u8 , 0u8] ; pub const OID_ECDSA_SHA224 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 206u8 , 61u8 , 4u8 , 3u8 , 1u8 , 0u8] ; pub const OID_ECDSA_SHA256 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 206u8 , 61u8 , 4u8 , 3u8 , 2u8 , 0u8] ; pub const OID_ECDSA_SHA384 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 206u8 , 61u8 , 4u8 , 3u8 , 3u8 , 0u8] ; pub const OID_ECDSA_SHA512 : [u8 ; 9usize] = [42u8 , 134u8 , 72u8 , 206u8 , 61u8 , 4u8 , 3u8 , 4u8 , 0u8] ; pub const ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED : :: types :: raw_types :: c_int = - 52 ; pub const ERR_CTR_DRBG_REQUEST_TOO_BIG : :: types :: raw_types :: c_int = - 54 ; pub const ERR_CTR_DRBG_INPUT_TOO_BIG : :: types :: raw_types :: c_int = - 56 ; pub const ERR_CTR_DRBG_FILE_IO_ERROR : :: types :: raw_types :: c_int = - 58 ; pub const CTR_DRBG_BLOCKSIZE : :: types :: raw_types :: c_int = 16 ; pub const CTR_DRBG_KEYSIZE : :: types :: raw_types :: c_int = 32 ; pub const CTR_DRBG_KEYBITS : :: types :: raw_types :: c_int = 256 ; pub const CTR_DRBG_SEEDLEN : :: types :: raw_types :: c_int = 48 ; pub const CTR_DRBG_ENTROPY_LEN : :: types :: raw_types :: c_int = 48 ; pub const CTR_DRBG_RESEED_INTERVAL : :: types :: raw_types :: c_int = 10000 ; pub const CTR_DRBG_MAX_INPUT : :: types :: raw_types :: c_int = 256 ; pub const CTR_DRBG_MAX_REQUEST : :: types :: raw_types :: c_int = 1024 ; pub const CTR_DRBG_MAX_SEED_INPUT : :: types :: raw_types :: c_int = 384 ; pub const CTR_DRBG_PR_OFF : :: types :: raw_types :: c_int = 0 ; pub const CTR_DRBG_PR_ON : :: types :: raw_types :: c_int = 1 ; pub const CTR_DRBG_ENTROPY_NONCE_LEN : :: types :: raw_types :: c_int = 0 ; pub const ERR_HMAC_DRBG_REQUEST_TOO_BIG : :: types :: raw_types :: c_int = - 3 ; pub const ERR_HMAC_DRBG_INPUT_TOO_BIG : :: types :: raw_types :: c_int = - 5 ; pub const ERR_HMAC_DRBG_FILE_IO_ERROR : :: types :: raw_types :: c_int = - 7 ; pub const ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED : :: types :: raw_types :: c_int = - 9 ; pub const HMAC_DRBG_RESEED_INTERVAL : :: types :: raw_types :: c_int = 10000 ; pub const HMAC_DRBG_MAX_INPUT : :: types :: raw_types :: c_int = 256 ; pub const HMAC_DRBG_MAX_REQUEST : :: types :: raw_types :: c_int = 1024 ; pub const HMAC_DRBG_MAX_SEED_INPUT : :: types :: raw_types :: c_int = 384 ; pub const HMAC_DRBG_PR_OFF : :: types :: raw_types :: c_int = 0 ; pub const HMAC_DRBG_PR_ON : :: types :: raw_types :: c_int = 1 ; pub const ERR_SSL_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 28800 ; pub const ERR_SSL_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 28928 ; pub const ERR_SSL_INVALID_MAC : :: types :: raw_types :: c_int = - 29056 ; pub const ERR_SSL_INVALID_RECORD : :: types :: raw_types :: c_int = - 29184 ; pub const ERR_SSL_CONN_EOF : :: types :: raw_types :: c_int = - 29312 ; pub const ERR_SSL_UNKNOWN_CIPHER : :: types :: raw_types :: c_int = - 29440 ; pub const ERR_SSL_NO_CIPHER_CHOSEN : :: types :: raw_types :: c_int = - 29568 ; pub const ERR_SSL_NO_RNG : :: types :: raw_types :: c_int = - 29696 ; pub const ERR_SSL_NO_CLIENT_CERTIFICATE : :: types :: raw_types :: c_int = - 29824 ; pub const ERR_SSL_CERTIFICATE_TOO_LARGE : :: types :: raw_types :: c_int = - 29952 ; pub const ERR_SSL_CERTIFICATE_REQUIRED : :: types :: raw_types :: c_int = - 30080 ; pub const ERR_SSL_PRIVATE_KEY_REQUIRED : :: types :: raw_types :: c_int = - 30208 ; pub const ERR_SSL_CA_CHAIN_REQUIRED : :: types :: raw_types :: c_int = - 30336 ; pub const ERR_SSL_UNEXPECTED_MESSAGE : :: types :: raw_types :: c_int = - 30464 ; pub const ERR_SSL_FATAL_ALERT_MESSAGE : :: types :: raw_types :: c_int = - 30592 ; pub const ERR_SSL_PEER_VERIFY_FAILED : :: types :: raw_types :: c_int = - 30720 ; pub const ERR_SSL_PEER_CLOSE_NOTIFY : :: types :: raw_types :: c_int = - 30848 ; pub const ERR_SSL_BAD_HS_CLIENT_HELLO : :: types :: raw_types :: c_int = - 30976 ; pub const ERR_SSL_BAD_HS_SERVER_HELLO : :: types :: raw_types :: c_int = - 31104 ; pub const ERR_SSL_BAD_HS_CERTIFICATE : :: types :: raw_types :: c_int = - 31232 ; pub const ERR_SSL_BAD_HS_CERTIFICATE_REQUEST : :: types :: raw_types :: c_int = - 31360 ; pub const ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE : :: types :: raw_types :: c_int = - 31488 ; pub const ERR_SSL_BAD_HS_SERVER_HELLO_DONE : :: types :: raw_types :: c_int = - 31616 ; pub const ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE : :: types :: raw_types :: c_int = - 31744 ; pub const ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP : :: types :: raw_types :: c_int = - 31872 ; pub const ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS : :: types :: raw_types :: c_int = - 32000 ; pub const ERR_SSL_BAD_HS_CERTIFICATE_VERIFY : :: types :: raw_types :: c_int = - 32128 ; pub const ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC : :: types :: raw_types :: c_int = - 32256 ; pub const ERR_SSL_BAD_HS_FINISHED : :: types :: raw_types :: c_int = - 32384 ; pub const ERR_SSL_ALLOC_FAILED : :: types :: raw_types :: c_int = - 32512 ; pub const ERR_SSL_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 32640 ; pub const ERR_SSL_HW_ACCEL_FALLTHROUGH : :: types :: raw_types :: c_int = - 28544 ; pub const ERR_SSL_COMPRESSION_FAILED : :: types :: raw_types :: c_int = - 28416 ; pub const ERR_SSL_BAD_HS_PROTOCOL_VERSION : :: types :: raw_types :: c_int = - 28288 ; pub const ERR_SSL_BAD_HS_NEW_SESSION_TICKET : :: types :: raw_types :: c_int = - 28160 ; pub const ERR_SSL_SESSION_TICKET_EXPIRED : :: types :: raw_types :: c_int = - 28032 ; pub const ERR_SSL_PK_TYPE_MISMATCH : :: types :: raw_types :: c_int = - 27904 ; pub const ERR_SSL_UNKNOWN_IDENTITY : :: types :: raw_types :: c_int = - 27776 ; pub const ERR_SSL_INTERNAL_ERROR : :: types :: raw_types :: c_int = - 27648 ; pub const ERR_SSL_COUNTER_WRAPPING : :: types :: raw_types :: c_int = - 27520 ; pub const ERR_SSL_WAITING_SERVER_HELLO_RENEGO : :: types :: raw_types :: c_int = - 27392 ; pub const ERR_SSL_HELLO_VERIFY_REQUIRED : :: types :: raw_types :: c_int = - 27264 ; pub const ERR_SSL_BUFFER_TOO_SMALL : :: types :: raw_types :: c_int = - 27136 ; pub const ERR_SSL_NO_USABLE_CIPHERSUITE : :: types :: raw_types :: c_int = - 27008 ; pub const ERR_SSL_WANT_READ : :: types :: raw_types :: c_int = - 26880 ; pub const ERR_SSL_WANT_WRITE : :: types :: raw_types :: c_int = - 26752 ; pub const ERR_SSL_TIMEOUT : :: types :: raw_types :: c_int = - 26624 ; pub const ERR_SSL_CLIENT_RECONNECT : :: types :: raw_types :: c_int = - 26496 ; pub const ERR_SSL_UNEXPECTED_RECORD : :: types :: raw_types :: c_int = - 26368 ; pub const ERR_SSL_NON_FATAL : :: types :: raw_types :: c_int = - 26240 ; pub const ERR_SSL_INVALID_VERIFY_HASH : :: types :: raw_types :: c_int = - 26112 ; pub const ERR_SSL_CONTINUE_PROCESSING : :: types :: raw_types :: c_int = - 25984 ; pub const ERR_SSL_ASYNC_IN_PROGRESS : :: types :: raw_types :: c_int = - 25856 ; pub const ERR_SSL_EARLY_MESSAGE : :: types :: raw_types :: c_int = - 25728 ; pub const ERR_SSL_UNEXPECTED_CID : :: types :: raw_types :: c_int = - 24576 ; pub const ERR_SSL_VERSION_MISMATCH : :: types :: raw_types :: c_int = - 24320 ; pub const ERR_SSL_CRYPTO_IN_PROGRESS : :: types :: raw_types :: c_int = - 28672 ; pub const ERR_SSL_BAD_CONFIG : :: types :: raw_types :: c_int = - 24192 ; pub const SSL_MAJOR_VERSION_3 : :: types :: raw_types :: c_int = 3 ; pub const SSL_MINOR_VERSION_0 : :: types :: raw_types :: c_int = 0 ; pub const SSL_MINOR_VERSION_1 : :: types :: raw_types :: c_int = 1 ; pub const SSL_MINOR_VERSION_2 : :: types :: raw_types :: c_int = 2 ; pub const SSL_MINOR_VERSION_3 : :: types :: raw_types :: c_int = 3 ; pub const SSL_MINOR_VERSION_4 : :: types :: raw_types :: c_int = 4 ; pub const SSL_TRANSPORT_STREAM : :: types :: raw_types :: c_int = 0 ; pub const SSL_TRANSPORT_DATAGRAM : :: types :: raw_types :: c_int = 1 ; pub const SSL_MAX_HOST_NAME_LEN : :: types :: raw_types :: c_int = 255 ; pub const SSL_MAX_ALPN_NAME_LEN : :: types :: raw_types :: c_int = 255 ; pub const SSL_MAX_ALPN_LIST_LEN : :: types :: raw_types :: c_int = 65535 ; pub const SSL_MAX_FRAG_LEN_NONE : :: types :: raw_types :: c_int = 0 ; pub const SSL_MAX_FRAG_LEN_512 : :: types :: raw_types :: c_int = 1 ; pub const SSL_MAX_FRAG_LEN_1024 : :: types :: raw_types :: c_int = 2 ; pub const SSL_MAX_FRAG_LEN_2048 : :: types :: raw_types :: c_int = 3 ; pub const SSL_MAX_FRAG_LEN_4096 : :: types :: raw_types :: c_int = 4 ; pub const SSL_MAX_FRAG_LEN_INVALID : :: types :: raw_types :: c_int = 5 ; pub const SSL_IS_CLIENT : :: types :: raw_types :: c_int = 0 ; pub const SSL_IS_SERVER : :: types :: raw_types :: c_int = 1 ; pub const SSL_IS_NOT_FALLBACK : :: types :: raw_types :: c_int = 0 ; pub const SSL_IS_FALLBACK : :: types :: raw_types :: c_int = 1 ; pub const SSL_EXTENDED_MS_DISABLED : :: types :: raw_types :: c_int = 0 ; pub const SSL_EXTENDED_MS_ENABLED : :: types :: raw_types :: c_int = 1 ; pub const SSL_CID_DISABLED : :: types :: raw_types :: c_int = 0 ; pub const SSL_CID_ENABLED : :: types :: raw_types :: c_int = 1 ; pub const SSL_ETM_DISABLED : :: types :: raw_types :: c_int = 0 ; pub const SSL_ETM_ENABLED : :: types :: raw_types :: c_int = 1 ; pub const SSL_COMPRESS_NULL : :: types :: raw_types :: c_int = 0 ; pub const SSL_COMPRESS_DEFLATE : :: types :: raw_types :: c_int = 1 ; pub const SSL_VERIFY_NONE : :: types :: raw_types :: c_int = 0 ; pub const SSL_VERIFY_OPTIONAL : :: types :: raw_types :: c_int = 1 ; pub const SSL_VERIFY_REQUIRED : :: types :: raw_types :: c_int = 2 ; pub const SSL_VERIFY_UNSET : :: types :: raw_types :: c_int = 3 ; pub const SSL_LEGACY_RENEGOTIATION : :: types :: raw_types :: c_int = 0 ; pub const SSL_SECURE_RENEGOTIATION : :: types :: raw_types :: c_int = 1 ; pub const SSL_RENEGOTIATION_DISABLED : :: types :: raw_types :: c_int = 0 ; pub const SSL_RENEGOTIATION_ENABLED : :: types :: raw_types :: c_int = 1 ; pub const SSL_ANTI_REPLAY_DISABLED : :: types :: raw_types :: c_int = 0 ; pub const SSL_ANTI_REPLAY_ENABLED : :: types :: raw_types :: c_int = 1 ; pub const SSL_RENEGOTIATION_NOT_ENFORCED : :: types :: raw_types :: c_int = - 1 ; pub const SSL_RENEGO_MAX_RECORDS_DEFAULT : :: types :: raw_types :: c_int = 16 ; pub const SSL_LEGACY_NO_RENEGOTIATION : :: types :: raw_types :: c_int = 0 ; pub const SSL_LEGACY_ALLOW_RENEGOTIATION : :: types :: raw_types :: c_int = 1 ; pub const SSL_LEGACY_BREAK_HANDSHAKE : :: types :: raw_types :: c_int = 2 ; pub const SSL_TRUNC_HMAC_DISABLED : :: types :: raw_types :: c_int = 0 ; pub const SSL_TRUNC_HMAC_ENABLED : :: types :: raw_types :: c_int = 1 ; pub const SSL_TRUNCATED_HMAC_LEN : :: types :: raw_types :: c_int = 10 ; pub const SSL_SESSION_TICKETS_DISABLED : :: types :: raw_types :: c_int = 0 ; pub const SSL_SESSION_TICKETS_ENABLED : :: types :: raw_types :: c_int = 1 ; pub const SSL_CBC_RECORD_SPLITTING_DISABLED : :: types :: raw_types :: c_int = 0 ; pub const SSL_CBC_RECORD_SPLITTING_ENABLED : :: types :: raw_types :: c_int = 1 ; pub const SSL_ARC4_ENABLED : :: types :: raw_types :: c_int = 0 ; pub const SSL_ARC4_DISABLED : :: types :: raw_types :: c_int = 1 ; pub const SSL_PRESET_DEFAULT : :: types :: raw_types :: c_int = 0 ; pub const SSL_PRESET_SUITEB : :: types :: raw_types :: c_int = 2 ; pub const SSL_CERT_REQ_CA_LIST_ENABLED : :: types :: raw_types :: c_int = 1 ; pub const SSL_CERT_REQ_CA_LIST_DISABLED : :: types :: raw_types :: c_int = 0 ; pub const SSL_DTLS_SRTP_MKI_UNSUPPORTED : :: types :: raw_types :: c_int = 0 ; pub const SSL_DTLS_SRTP_MKI_SUPPORTED : :: types :: raw_types :: c_int = 1 ; pub const SSL_DTLS_TIMEOUT_DFL_MIN : :: types :: raw_types :: c_int = 1000 ; pub const SSL_DTLS_TIMEOUT_DFL_MAX : :: types :: raw_types :: c_int = 60000 ; pub const SSL_DEFAULT_TICKET_LIFETIME : :: types :: raw_types :: c_int = 86400 ; pub const SSL_MAX_CONTENT_LEN : :: types :: raw_types :: c_int = 16384 ; pub const SSL_IN_CONTENT_LEN : :: types :: raw_types :: c_int = 16384 ; pub const SSL_OUT_CONTENT_LEN : :: types :: raw_types :: c_int = 16384 ; pub const SSL_DTLS_MAX_BUFFERING : :: types :: raw_types :: c_int = 32768 ; pub const SSL_CID_IN_LEN_MAX : :: types :: raw_types :: c_int = 32 ; pub const SSL_CID_OUT_LEN_MAX : :: types :: raw_types :: c_int = 32 ; pub const SSL_CID_PADDING_GRANULARITY : :: types :: raw_types :: c_int = 16 ; pub const SSL_TLS1_3_PADDING_GRANULARITY : :: types :: raw_types :: c_int = 1 ; pub const SSL_VERIFY_DATA_MAX_LEN : :: types :: raw_types :: c_int = 12 ; pub const SSL_EMPTY_RENEGOTIATION_INFO : :: types :: raw_types :: c_int = 255 ; pub const SSL_FALLBACK_SCSV_VALUE : :: types :: raw_types :: c_int = 22016 ; pub const SSL_HASH_NONE : :: types :: raw_types :: c_int = 0 ; pub const SSL_HASH_MD5 : :: types :: raw_types :: c_int = 1 ; pub const SSL_HASH_SHA1 : :: types :: raw_types :: c_int = 2 ; pub const SSL_HASH_SHA224 : :: types :: raw_types :: c_int = 3 ; pub const SSL_HASH_SHA256 : :: types :: raw_types :: c_int = 4 ; pub const SSL_HASH_SHA384 : :: types :: raw_types :: c_int = 5 ; pub const SSL_HASH_SHA512 : :: types :: raw_types :: c_int = 6 ; pub const SSL_SIG_ANON : :: types :: raw_types :: c_int = 0 ; pub const SSL_SIG_RSA : :: types :: raw_types :: c_int = 1 ; pub const SSL_SIG_ECDSA : :: types :: raw_types :: c_int = 3 ; pub const SSL_CERT_TYPE_RSA_SIGN : :: types :: raw_types :: c_int = 1 ; pub const SSL_CERT_TYPE_ECDSA_SIGN : :: types :: raw_types :: c_int = 64 ; pub const SSL_MSG_CHANGE_CIPHER_SPEC : :: types :: raw_types :: c_int = 20 ; pub const SSL_MSG_ALERT : :: types :: raw_types :: c_int = 21 ; pub const SSL_MSG_HANDSHAKE : :: types :: raw_types :: c_int = 22 ; pub const SSL_MSG_APPLICATION_DATA : :: types :: raw_types :: c_int = 23 ; pub const SSL_MSG_CID : :: types :: raw_types :: c_int = 25 ; pub const SSL_ALERT_LEVEL_WARNING : :: types :: raw_types :: c_int = 1 ; pub const SSL_ALERT_LEVEL_FATAL : :: types :: raw_types :: c_int = 2 ; pub const SSL_ALERT_MSG_CLOSE_NOTIFY : :: types :: raw_types :: c_int = 0 ; pub const SSL_ALERT_MSG_UNEXPECTED_MESSAGE : :: types :: raw_types :: c_int = 10 ; pub const SSL_ALERT_MSG_BAD_RECORD_MAC : :: types :: raw_types :: c_int = 20 ; pub const SSL_ALERT_MSG_DECRYPTION_FAILED : :: types :: raw_types :: c_int = 21 ; pub const SSL_ALERT_MSG_RECORD_OVERFLOW : :: types :: raw_types :: c_int = 22 ; pub const SSL_ALERT_MSG_DECOMPRESSION_FAILURE : :: types :: raw_types :: c_int = 30 ; pub const SSL_ALERT_MSG_HANDSHAKE_FAILURE : :: types :: raw_types :: c_int = 40 ; pub const SSL_ALERT_MSG_NO_CERT : :: types :: raw_types :: c_int = 41 ; pub const SSL_ALERT_MSG_BAD_CERT : :: types :: raw_types :: c_int = 42 ; pub const SSL_ALERT_MSG_UNSUPPORTED_CERT : :: types :: raw_types :: c_int = 43 ; pub const SSL_ALERT_MSG_CERT_REVOKED : :: types :: raw_types :: c_int = 44 ; pub const SSL_ALERT_MSG_CERT_EXPIRED : :: types :: raw_types :: c_int = 45 ; pub const SSL_ALERT_MSG_CERT_UNKNOWN : :: types :: raw_types :: c_int = 46 ; pub const SSL_ALERT_MSG_ILLEGAL_PARAMETER : :: types :: raw_types :: c_int = 47 ; pub const SSL_ALERT_MSG_UNKNOWN_CA : :: types :: raw_types :: c_int = 48 ; pub const SSL_ALERT_MSG_ACCESS_DENIED : :: types :: raw_types :: c_int = 49 ; pub const SSL_ALERT_MSG_DECODE_ERROR : :: types :: raw_types :: c_int = 50 ; pub const SSL_ALERT_MSG_DECRYPT_ERROR : :: types :: raw_types :: c_int = 51 ; pub const SSL_ALERT_MSG_EXPORT_RESTRICTION : :: types :: raw_types :: c_int = 60 ; pub const SSL_ALERT_MSG_PROTOCOL_VERSION : :: types :: raw_types :: c_int = 70 ; pub const SSL_ALERT_MSG_INSUFFICIENT_SECURITY : :: types :: raw_types :: c_int = 71 ; pub const SSL_ALERT_MSG_INTERNAL_ERROR : :: types :: raw_types :: c_int = 80 ; pub const SSL_ALERT_MSG_INAPROPRIATE_FALLBACK : :: types :: raw_types :: c_int = 86 ; pub const SSL_ALERT_MSG_USER_CANCELED : :: types :: raw_types :: c_int = 90 ; pub const SSL_ALERT_MSG_NO_RENEGOTIATION : :: types :: raw_types :: c_int = 100 ; pub const SSL_ALERT_MSG_UNSUPPORTED_EXT : :: types :: raw_types :: c_int = 110 ; pub const SSL_ALERT_MSG_UNRECOGNIZED_NAME : :: types :: raw_types :: c_int = 112 ; pub const SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY : :: types :: raw_types :: c_int = 115 ; pub const SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL : :: types :: raw_types :: c_int = 120 ; pub const SSL_HS_HELLO_REQUEST : :: types :: raw_types :: c_int = 0 ; pub const SSL_HS_CLIENT_HELLO : :: types :: raw_types :: c_int = 1 ; pub const SSL_HS_SERVER_HELLO : :: types :: raw_types :: c_int = 2 ; pub const SSL_HS_HELLO_VERIFY_REQUEST : :: types :: raw_types :: c_int = 3 ; pub const SSL_HS_NEW_SESSION_TICKET : :: types :: raw_types :: c_int = 4 ; pub const SSL_HS_CERTIFICATE : :: types :: raw_types :: c_int = 11 ; pub const SSL_HS_SERVER_KEY_EXCHANGE : :: types :: raw_types :: c_int = 12 ; pub const SSL_HS_CERTIFICATE_REQUEST : :: types :: raw_types :: c_int = 13 ; pub const SSL_HS_SERVER_HELLO_DONE : :: types :: raw_types :: c_int = 14 ; pub const SSL_HS_CERTIFICATE_VERIFY : :: types :: raw_types :: c_int = 15 ; pub const SSL_HS_CLIENT_KEY_EXCHANGE : :: types :: raw_types :: c_int = 16 ; pub const SSL_HS_FINISHED : :: types :: raw_types :: c_int = 20 ; pub const TLS_EXT_SERVERNAME : :: types :: raw_types :: c_int = 0 ; pub const TLS_EXT_SERVERNAME_HOSTNAME : :: types :: raw_types :: c_int = 0 ; pub const TLS_EXT_MAX_FRAGMENT_LENGTH : :: types :: raw_types :: c_int = 1 ; pub const TLS_EXT_TRUNCATED_HMAC : :: types :: raw_types :: c_int = 4 ; pub const TLS_EXT_SUPPORTED_ELLIPTIC_CURVES : :: types :: raw_types :: c_int = 10 ; pub const TLS_EXT_SUPPORTED_POINT_FORMATS : :: types :: raw_types :: c_int = 11 ; pub const TLS_EXT_SIG_ALG : :: types :: raw_types :: c_int = 13 ; pub const TLS_EXT_USE_SRTP : :: types :: raw_types :: c_int = 14 ; pub const TLS_EXT_ALPN : :: types :: raw_types :: c_int = 16 ; pub const TLS_EXT_ENCRYPT_THEN_MAC : :: types :: raw_types :: c_int = 22 ; pub const TLS_EXT_EXTENDED_MASTER_SECRET : :: types :: raw_types :: c_int = 23 ; pub const TLS_EXT_SESSION_TICKET : :: types :: raw_types :: c_int = 35 ; pub const TLS_EXT_CID : :: types :: raw_types :: c_int = 254 ; pub const TLS_EXT_ECJPAKE_KKPP : :: types :: raw_types :: c_int = 256 ; pub const TLS_EXT_RENEGOTIATION_INFO : :: types :: raw_types :: c_int = 65281 ; pub const PSK_MAX_LEN : :: types :: raw_types :: c_int = 32 ; pub const ERR_MD5_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 47 ; pub const ERR_SHA1_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 53 ; pub const ERR_SHA1_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 115 ; pub const ERR_SHA256_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 55 ; pub const ERR_SHA256_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 116 ; pub const ERR_SHA512_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 57 ; pub const ERR_SHA512_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 117 ; pub const ERR_NET_SOCKET_FAILED : :: types :: raw_types :: c_int = - 66 ; pub const ERR_NET_CONNECT_FAILED : :: types :: raw_types :: c_int = - 68 ; pub const ERR_NET_BIND_FAILED : :: types :: raw_types :: c_int = - 70 ; pub const ERR_NET_LISTEN_FAILED : :: types :: raw_types :: c_int = - 72 ; pub const ERR_NET_ACCEPT_FAILED : :: types :: raw_types :: c_int = - 74 ; pub const ERR_NET_RECV_FAILED : :: types :: raw_types :: c_int = - 76 ; pub const ERR_NET_SEND_FAILED : :: types :: raw_types :: c_int = - 78 ; pub const ERR_NET_CONN_RESET : :: types :: raw_types :: c_int = - 80 ; pub const ERR_NET_UNKNOWN_HOST : :: types :: raw_types :: c_int = - 82 ; pub const ERR_NET_BUFFER_TOO_SMALL : :: types :: raw_types :: c_int = - 67 ; pub const ERR_NET_INVALID_CONTEXT : :: types :: raw_types :: c_int = - 69 ; pub const ERR_NET_POLL_FAILED : :: types :: raw_types :: c_int = - 71 ; pub const ERR_NET_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 73 ; pub const NET_LISTEN_BACKLOG : :: types :: raw_types :: c_int = 10 ; pub const NET_PROTO_TCP : :: types :: raw_types :: c_int = 0 ; pub const NET_PROTO_UDP : :: types :: raw_types :: c_int = 1 ; pub const NET_POLL_READ : :: types :: raw_types :: c_int = 1 ; pub const NET_POLL_WRITE : :: types :: raw_types :: c_int = 2 ; pub const HAVEGE_COLLECT_SIZE : :: types :: raw_types :: c_int = 1024 ; pub const ERR_POLY1305_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 87 ; pub const ERR_POLY1305_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 89 ; pub const ERR_POLY1305_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 91 ; pub const ERR_CHACHA20_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 81 ; pub const ERR_CHACHA20_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 83 ; pub const ERR_CHACHA20_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 85 ; pub const XTEA_ENCRYPT : :: types :: raw_types :: c_int = 1 ; pub const XTEA_DECRYPT : :: types :: raw_types :: c_int = 0 ; pub const ERR_XTEA_INVALID_INPUT_LENGTH : :: types :: raw_types :: c_int = - 40 ; pub const ERR_XTEA_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 41 ; pub const VERSION_MAJOR : :: types :: raw_types :: c_int = 2 ; pub const VERSION_MINOR : :: types :: raw_types :: c_int = 28 ; pub const VERSION_PATCH : :: types :: raw_types :: c_int = 0 ; pub const VERSION_NUMBER : :: types :: raw_types :: c_int = 35389440 ; pub const VERSION_STRING : & 'static [u8 ; 7usize] = b"2.28.0\0" ; pub const VERSION_STRING_FULL : & 'static [u8 ; 16usize] = b"mbed TLS 2.28.0\0" ; pub const SSL_MIN_MAJOR_VERSION : :: types :: raw_types :: c_int = 3 ; pub const SSL_MIN_MINOR_VERSION : :: types :: raw_types :: c_int = 3 ; pub const SSL_MIN_VALID_MINOR_VERSION : :: types :: raw_types :: c_int = 1 ; pub const SSL_MIN_VALID_MAJOR_VERSION : :: types :: raw_types :: c_int = 3 ; pub const SSL_MAX_MAJOR_VERSION : :: types :: raw_types :: c_int = 3 ; pub const SSL_MAX_MINOR_VERSION : :: types :: raw_types :: c_int = 3 ; pub const SSL_INITIAL_HANDSHAKE : :: types :: raw_types :: c_int = 0 ; pub const SSL_RENEGOTIATION_IN_PROGRESS : :: types :: raw_types :: c_int = 1 ; pub const SSL_RENEGOTIATION_DONE : :: types :: raw_types :: c_int = 2 ; pub const SSL_RENEGOTIATION_PENDING : :: types :: raw_types :: c_int = 3 ; pub const SSL_RETRANS_PREPARING : :: types :: raw_types :: c_int = 0 ; pub const SSL_RETRANS_SENDING : :: types :: raw_types :: c_int = 1 ; pub const SSL_RETRANS_WAITING : :: types :: raw_types :: c_int = 2 ; pub const SSL_RETRANS_FINISHED : :: types :: raw_types :: c_int = 3 ; pub const SSL_COMPRESSION_ADD : :: types :: raw_types :: c_int = 0 ; pub const SSL_MAC_ADD : :: types :: raw_types :: c_int = 48 ; pub const SSL_PADDING_ADD : :: types :: raw_types :: c_int = 256 ; pub const SSL_MAX_CID_EXPANSION : :: types :: raw_types :: c_int = 0 ; pub const SSL_PAYLOAD_OVERHEAD : :: types :: raw_types :: c_int = 320 ; pub const SSL_IN_PAYLOAD_LEN : :: types :: raw_types :: c_int = 16704 ; pub const SSL_OUT_PAYLOAD_LEN : :: types :: raw_types :: c_int = 16704 ; pub const SSL_MAX_BUFFERED_HS : :: types :: raw_types :: c_int = 4 ; pub const SSL_MAX_SIG_HASH_ALG_LIST_LEN : :: types :: raw_types :: c_int = 65534 ; pub const SSL_MAX_CURVE_LIST_LEN : :: types :: raw_types :: c_int = 65535 ; pub const SSL_HEADER_LEN : :: types :: raw_types :: c_int = 13 ; pub const SSL_IN_BUFFER_LEN : :: types :: raw_types :: c_int = 16717 ; pub const SSL_OUT_BUFFER_LEN : :: types :: raw_types :: c_int = 16717 ; pub const TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT : :: types :: raw_types :: c_int = 1 ; pub const TLS_EXT_ECJPAKE_KKPP_OK : :: types :: raw_types :: c_int = 2 ; pub const SSL_MAX_BLOCK_LENGTH : :: types :: raw_types :: c_int = 16 ; pub const SSL_MAX_IV_LENGTH : :: types :: raw_types :: c_int = 16 ; pub const SSL_MAX_KEY_LENGTH : :: types :: raw_types :: c_int = 32 ; pub const SSL_CID_LEN_MAX : :: types :: raw_types :: c_int = 32 ; pub const SSL_COOKIE_TIMEOUT : :: types :: raw_types :: c_int = 60 ; pub const SSL_CACHE_DEFAULT_TIMEOUT : :: types :: raw_types :: c_int = 86400 ; pub const SSL_CACHE_DEFAULT_MAX_ENTRIES : :: types :: raw_types :: c_int = 50 ; pub const ERR_RIPEMD160_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 49 ; pub const ERR_PLATFORM_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 112 ; pub const ERR_PLATFORM_FEATURE_UNSUPPORTED : :: types :: raw_types :: c_int = - 114 ; pub const PLATFORM_STD_EXIT_SUCCESS : :: types :: raw_types :: c_int = 0 ; pub const PLATFORM_STD_EXIT_FAILURE : :: types :: raw_types :: c_int = 1 ; pub const PLATFORM_STD_NV_SEED_FILE : & 'static [u8 ; 9usize] = b"seedfile\0" ; pub const EXIT_SUCCESS : :: types :: raw_types :: c_int = 0 ; pub const EXIT_FAILURE : :: types :: raw_types :: c_int = 1 ; pub const ERR_PKCS5_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 12160 ; pub const ERR_PKCS5_INVALID_FORMAT : :: types :: raw_types :: c_int = - 12032 ; pub const ERR_PKCS5_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 11904 ; pub const ERR_PKCS5_PASSWORD_MISMATCH : :: types :: raw_types :: c_int = - 11776 ; pub const PKCS5_DECRYPT : :: types :: raw_types :: c_int = 0 ; pub const PKCS5_ENCRYPT : :: types :: raw_types :: c_int = 1 ; pub const ERR_PKCS12_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 8064 ; pub const ERR_PKCS12_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 7936 ; pub const ERR_PKCS12_PBE_INVALID_FORMAT : :: types :: raw_types :: c_int = - 7808 ; pub const ERR_PKCS12_PASSWORD_MISMATCH : :: types :: raw_types :: c_int = - 7680 ; pub const PKCS12_DERIVE_KEY : :: types :: raw_types :: c_int = 1 ; pub const PKCS12_DERIVE_IV : :: types :: raw_types :: c_int = 2 ; pub const PKCS12_DERIVE_MAC_KEY : :: types :: raw_types :: c_int = 3 ; pub const PKCS12_PBE_DECRYPT : :: types :: raw_types :: c_int = 0 ; pub const PKCS12_PBE_ENCRYPT : :: types :: raw_types :: c_int = 1 ; pub const ERR_PEM_NO_HEADER_FOOTER_PRESENT : :: types :: raw_types :: c_int = - 4224 ; pub const ERR_PEM_INVALID_DATA : :: types :: raw_types :: c_int = - 4352 ; pub const ERR_PEM_ALLOC_FAILED : :: types :: raw_types :: c_int = - 4480 ; pub const ERR_PEM_INVALID_ENC_IV : :: types :: raw_types :: c_int = - 4608 ; pub const ERR_PEM_UNKNOWN_ENC_ALG : :: types :: raw_types :: c_int = - 4736 ; pub const ERR_PEM_PASSWORD_REQUIRED : :: types :: raw_types :: c_int = - 4864 ; pub const ERR_PEM_PASSWORD_MISMATCH : :: types :: raw_types :: c_int = - 4992 ; pub const ERR_PEM_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 5120 ; pub const ERR_PEM_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 5248 ; pub const ERR_PADLOCK_DATA_MISALIGNED : :: types :: raw_types :: c_int = - 48 ; pub const MEMORY_ALIGN_MULTIPLE : :: types :: raw_types :: c_int = 4 ; pub const MEMORY_VERIFY_NONE : :: types :: raw_types :: c_int = 0 ; pub const MEMORY_VERIFY_ALLOC : :: types :: raw_types :: c_int = 1 ; pub const MEMORY_VERIFY_FREE : :: types :: raw_types :: c_int = 2 ; pub const MEMORY_VERIFY_ALWAYS : :: types :: raw_types :: c_int = 3 ; pub const ERR_MD4_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 45 ; pub const ERR_MD2_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 43 ; pub const ERR_HKDF_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 24448 ; pub const GCM_ENCRYPT : :: types :: raw_types :: c_int = 1 ; pub const GCM_DECRYPT : :: types :: raw_types :: c_int = 0 ; pub const ERR_GCM_AUTH_FAILED : :: types :: raw_types :: c_int = - 18 ; pub const ERR_GCM_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 19 ; pub const ERR_GCM_BAD_INPUT : :: types :: raw_types :: c_int = - 20 ; pub const ERR_ERROR_GENERIC_ERROR : :: types :: raw_types :: c_int = - 1 ; pub const ERR_ERROR_CORRUPTION_DETECTED : :: types :: raw_types :: c_int = - 110 ; pub const ENTROPY_MIN_PLATFORM : :: types :: raw_types :: c_int = 32 ; pub const ENTROPY_MIN_HAVEGE : :: types :: raw_types :: c_int = 32 ; pub const ENTROPY_MIN_HARDCLOCK : :: types :: raw_types :: c_int = 4 ; pub const ENTROPY_MIN_HARDWARE : :: types :: raw_types :: c_int = 32 ; pub const ERR_ENTROPY_SOURCE_FAILED : :: types :: raw_types :: c_int = - 60 ; pub const ERR_ENTROPY_MAX_SOURCES : :: types :: raw_types :: c_int = - 62 ; pub const ERR_ENTROPY_NO_SOURCES_DEFINED : :: types :: raw_types :: c_int = - 64 ; pub const ERR_ENTROPY_NO_STRONG_SOURCE : :: types :: raw_types :: c_int = - 61 ; pub const ERR_ENTROPY_FILE_IO_ERROR : :: types :: raw_types :: c_int = - 63 ; pub const ENTROPY_MAX_SOURCES : :: types :: raw_types :: c_int = 20 ; pub const ENTROPY_MAX_GATHER : :: types :: raw_types :: c_int = 128 ; pub const ENTROPY_BLOCK_SIZE : :: types :: raw_types :: c_int = 64 ; pub const ENTROPY_MAX_SEED_SIZE : :: types :: raw_types :: c_int = 1024 ; pub const ENTROPY_SOURCE_MANUAL : :: types :: raw_types :: c_int = 20 ; pub const ENTROPY_SOURCE_STRONG : :: types :: raw_types :: c_int = 1 ; pub const ENTROPY_SOURCE_WEAK : :: types :: raw_types :: c_int = 0 ; pub const DES_ENCRYPT : :: types :: raw_types :: c_int = 1 ; pub const DES_DECRYPT : :: types :: raw_types :: c_int = 0 ; pub const ERR_DES_INVALID_INPUT_LENGTH : :: types :: raw_types :: c_int = - 50 ; pub const ERR_DES_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 51 ; pub const DES_KEY_SIZE : :: types :: raw_types :: c_int = 8 ; pub const PRINTF_SIZET : & 'static [u8 ; 3usize] = b"zu\0" ; pub const PRINTF_LONGLONG : & 'static [u8 ; 4usize] = b"lld\0" ; pub const ERR_CMAC_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 122 ; pub const AES_BLOCK_SIZE : :: types :: raw_types :: c_int = 16 ; pub const DES3_BLOCK_SIZE : :: types :: raw_types :: c_int = 8 ; pub const CIPHER_BLKSIZE_MAX : :: types :: raw_types :: c_int = 16 ; pub const ERR_CHACHAPOLY_BAD_STATE : :: types :: raw_types :: c_int = - 84 ; pub const ERR_CHACHAPOLY_AUTH_FAILED : :: types :: raw_types :: c_int = - 86 ; pub const ERR_CCM_BAD_INPUT : :: types :: raw_types :: c_int = - 13 ; pub const ERR_CCM_AUTH_FAILED : :: types :: raw_types :: c_int = - 15 ; pub const ERR_CCM_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 17 ; pub const CAMELLIA_ENCRYPT : :: types :: raw_types :: c_int = 1 ; pub const CAMELLIA_DECRYPT : :: types :: raw_types :: c_int = 0 ; pub const ERR_CAMELLIA_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 36 ; pub const ERR_CAMELLIA_INVALID_INPUT_LENGTH : :: types :: raw_types :: c_int = - 38 ; pub const ERR_CAMELLIA_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 39 ; pub const BLOWFISH_ENCRYPT : :: types :: raw_types :: c_int = 1 ; pub const BLOWFISH_DECRYPT : :: types :: raw_types :: c_int = 0 ; pub const BLOWFISH_MAX_KEY_BITS : :: types :: raw_types :: c_int = 448 ; pub const BLOWFISH_MIN_KEY_BITS : :: types :: raw_types :: c_int = 32 ; pub const BLOWFISH_ROUNDS : :: types :: raw_types :: c_int = 16 ; pub const BLOWFISH_BLOCKSIZE : :: types :: raw_types :: c_int = 8 ; pub const ERR_BLOWFISH_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 22 ; pub const ERR_BLOWFISH_INVALID_INPUT_LENGTH : :: types :: raw_types :: c_int = - 24 ; pub const ERR_BLOWFISH_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 23 ; pub const ERR_BASE64_BUFFER_TOO_SMALL : :: types :: raw_types :: c_int = - 42 ; pub const ERR_BASE64_INVALID_CHARACTER : :: types :: raw_types :: c_int = - 44 ; pub const ARIA_ENCRYPT : :: types :: raw_types :: c_int = 1 ; pub const ARIA_DECRYPT : :: types :: raw_types :: c_int = 0 ; pub const ARIA_BLOCKSIZE : :: types :: raw_types :: c_int = 16 ; pub const ARIA_MAX_ROUNDS : :: types :: raw_types :: c_int = 16 ; pub const ARIA_MAX_KEYSIZE : :: types :: raw_types :: c_int = 32 ; pub const ERR_ARIA_BAD_INPUT_DATA : :: types :: raw_types :: c_int = - 92 ; pub const ERR_ARIA_INVALID_INPUT_LENGTH : :: types :: raw_types :: c_int = - 94 ; pub const ERR_ARIA_FEATURE_UNAVAILABLE : :: types :: raw_types :: c_int = - 90 ; pub const ERR_ARIA_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 88 ; pub const ERR_ARC4_HW_ACCEL_FAILED : :: types :: raw_types :: c_int = - 25 ; pub const AESNI_AES : :: types :: raw_types :: c_int = 33554432 ; pub const AESNI_CLMUL : :: types :: raw_types :: c_int = 2 ; extern "C" { # [link_name = "\u{1}mbedtls_printf"] pub fn printf (format : * const :: types :: raw_types :: c_char , ...) -> :: types :: raw_types :: c_int ; } pub type iso_c_forbids_empty_translation_units = :: types :: raw_types :: c_int ; extern "C" { # [link_name = "\u{1}mbedtls_platform_zeroize"] pub fn platform_zeroize (buf : * mut :: types :: raw_types :: c_void , len : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_platform_gmtime_r"] pub fn platform_gmtime_r (tt : * const time_t , tm_buf : * mut tm) -> * mut tm ; } pub type mpi_sint = i64 ; pub type mpi_uint = u64 ; pub type t_udbl = u128 ; # [repr (C)] # [derive (Copy , Clone)] pub struct mpi { pub s : :: types :: raw_types :: c_int , pub n : size_t , pub p : * mut mpi_uint , } # [test] fn bindgen_test_layout_mpi () { assert_eq ! (:: core :: mem :: size_of :: < mpi > () , 24usize , concat ! ("Size of: " , stringify ! (mpi))) ; assert_eq ! (:: core :: mem :: align_of :: < mpi > () , 8usize , concat ! ("Alignment of " , stringify ! (mpi))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < mpi > ())) . s as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (mpi) , "::" , stringify ! (s))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < mpi > ())) . n as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (mpi) , "::" , stringify ! (n))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < mpi > ())) . p as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (mpi) , "::" , stringify ! (p))) ; } impl Default for mpi { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_mpi_init"] pub fn mpi_init (X : * mut mpi) ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_free"] pub fn mpi_free (X : * mut mpi) ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_grow"] pub fn mpi_grow (X : * mut mpi , nblimbs : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_shrink"] pub fn mpi_shrink (X : * mut mpi , nblimbs : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_copy"] pub fn mpi_copy (X : * mut mpi , Y : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_swap"] pub fn mpi_swap (X : * mut mpi , Y : * mut mpi) ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_safe_cond_assign"] pub fn mpi_safe_cond_assign (X : * mut mpi , Y : * const mpi , assign : :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_safe_cond_swap"] pub fn mpi_safe_cond_swap (X : * mut mpi , Y : * mut mpi , assign : :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_lset"] pub fn mpi_lset (X : * mut mpi , z : mpi_sint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_get_bit"] pub fn mpi_get_bit (X : * const mpi , pos : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_set_bit"] pub fn mpi_set_bit (X : * mut mpi , pos : size_t , val : :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_lsb"] pub fn mpi_lsb (X : * const mpi) -> size_t ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_bitlen"] pub fn mpi_bitlen (X : * const mpi) -> size_t ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_size"] pub fn mpi_size (X : * const mpi) -> size_t ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_read_string"] pub fn mpi_read_string (X : * mut mpi , radix : :: types :: raw_types :: c_int , s : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_write_string"] pub fn mpi_write_string (X : * const mpi , radix : :: types :: raw_types :: c_int , buf : * mut :: types :: raw_types :: c_char , buflen : size_t , olen : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_read_file"] pub fn mpi_read_file (X : * mut mpi , radix : :: types :: raw_types :: c_int , fin : * mut FILE) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_write_file"] pub fn mpi_write_file (p : * const :: types :: raw_types :: c_char , X : * const mpi , radix : :: types :: raw_types :: c_int , fout : * mut FILE) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_read_binary"] pub fn mpi_read_binary (X : * mut mpi , buf : * const :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_read_binary_le"] pub fn mpi_read_binary_le (X : * mut mpi , buf : * const :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_write_binary"] pub fn mpi_write_binary (X : * const mpi , buf : * mut :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_write_binary_le"] pub fn mpi_write_binary_le (X : * const mpi , buf : * mut :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_shift_l"] pub fn mpi_shift_l (X : * mut mpi , count : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_shift_r"] pub fn mpi_shift_r (X : * mut mpi , count : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_cmp_abs"] pub fn mpi_cmp_abs (X : * const mpi , Y : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_cmp_mpi"] pub fn mpi_cmp_mpi (X : * const mpi , Y : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_lt_mpi_ct"] pub fn mpi_lt_mpi_ct (X : * const mpi , Y : * const mpi , ret : * mut :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_cmp_int"] pub fn mpi_cmp_int (X : * const mpi , z : mpi_sint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_add_abs"] pub fn mpi_add_abs (X : * mut mpi , A : * const mpi , B : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_sub_abs"] pub fn mpi_sub_abs (X : * mut mpi , A : * const mpi , B : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_add_mpi"] pub fn mpi_add_mpi (X : * mut mpi , A : * const mpi , B : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_sub_mpi"] pub fn mpi_sub_mpi (X : * mut mpi , A : * const mpi , B : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_add_int"] pub fn mpi_add_int (X : * mut mpi , A : * const mpi , b : mpi_sint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_sub_int"] pub fn mpi_sub_int (X : * mut mpi , A : * const mpi , b : mpi_sint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_mul_mpi"] pub fn mpi_mul_mpi (X : * mut mpi , A : * const mpi , B : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_mul_int"] pub fn mpi_mul_int (X : * mut mpi , A : * const mpi , b : mpi_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_div_mpi"] pub fn mpi_div_mpi (Q : * mut mpi , R : * mut mpi , A : * const mpi , B : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_div_int"] pub fn mpi_div_int (Q : * mut mpi , R : * mut mpi , A : * const mpi , b : mpi_sint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_mod_mpi"] pub fn mpi_mod_mpi (R : * mut mpi , A : * const mpi , B : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_mod_int"] pub fn mpi_mod_int (r : * mut mpi_uint , A : * const mpi , b : mpi_sint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_exp_mod"] pub fn mpi_exp_mod (X : * mut mpi , A : * const mpi , E : * const mpi , N : * const mpi , prec_RR : * mut mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_fill_random"] pub fn mpi_fill_random (X : * mut mpi , size : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_random"] pub fn mpi_random (X : * mut mpi , min : mpi_sint , N : * const mpi , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_gcd"] pub fn mpi_gcd (G : * mut mpi , A : * const mpi , B : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_inv_mod"] pub fn mpi_inv_mod (X : * mut mpi , A : * const mpi , N : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_is_prime"] pub fn mpi_is_prime (X : * const mpi , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_is_prime_ext"] pub fn mpi_is_prime_ext (X : * const mpi , rounds : :: types :: raw_types :: c_int , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } pub const MPI_GEN_PRIME_FLAG_DH : mpi_gen_prime_flag_t = 1 ; pub const MPI_GEN_PRIME_FLAG_LOW_ERR : mpi_gen_prime_flag_t = 2 ; pub type mpi_gen_prime_flag_t = u32 ; extern "C" { # [link_name = "\u{1}mbedtls_mpi_gen_prime"] pub fn mpi_gen_prime (X : * mut mpi , nbits : size_t , flags : :: types :: raw_types :: c_int , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_mpi_self_test"] pub fn mpi_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } pub const MD_NONE : md_type_t = 0 ; pub const MD_MD2 : md_type_t = 1 ; pub const MD_MD4 : md_type_t = 2 ; pub const MD_MD5 : md_type_t = 3 ; pub const MD_SHA1 : md_type_t = 4 ; pub const MD_SHA224 : md_type_t = 5 ; pub const MD_SHA256 : md_type_t = 6 ; pub const MD_SHA384 : md_type_t = 7 ; pub const MD_SHA512 : md_type_t = 8 ; pub const MD_RIPEMD160 : md_type_t = 9 ; pub type md_type_t = u32 ; # [repr (C)] # [derive (Copy , Clone)] pub struct md_context_t { pub md_info : * const md_info_t , pub md_ctx : * mut :: types :: raw_types :: c_void , pub hmac_ctx : * mut :: types :: raw_types :: c_void , } # [test] fn bindgen_test_layout_md_context_t () { assert_eq ! (:: core :: mem :: size_of :: < md_context_t > () , 24usize , concat ! ("Size of: " , stringify ! (md_context_t))) ; assert_eq ! (:: core :: mem :: align_of :: < md_context_t > () , 8usize , concat ! ("Alignment of " , stringify ! (md_context_t))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md_context_t > ())) . md_info as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (md_context_t) , "::" , stringify ! (md_info))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md_context_t > ())) . md_ctx as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (md_context_t) , "::" , stringify ! (md_ctx))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md_context_t > ())) . hmac_ctx as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (md_context_t) , "::" , stringify ! (hmac_ctx))) ; } impl Default for md_context_t { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_md_list"] pub fn md_list () -> * const :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md_info_from_string"] pub fn md_info_from_string (md_name : * const :: types :: raw_types :: c_char) -> * const md_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_md_info_from_type"] pub fn md_info_from_type (md_type : md_type_t) -> * const md_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_md_init"] pub fn md_init (ctx : * mut md_context_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_md_free"] pub fn md_free (ctx : * mut md_context_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_md_init_ctx"] pub fn md_init_ctx (ctx : * mut md_context_t , md_info : * const md_info_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_md_setup"] pub fn md_setup (ctx : * mut md_context_t , md_info : * const md_info_t , hmac : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_md_clone"] pub fn md_clone (dst : * mut md_context_t , src : * const md_context_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md_get_size"] pub fn md_get_size (md_info : * const md_info_t) -> :: types :: raw_types :: c_uchar ; } extern "C" { # [link_name = "\u{1}mbedtls_md_get_type"] pub fn md_get_type (md_info : * const md_info_t) -> md_type_t ; } extern "C" { # [link_name = "\u{1}mbedtls_md_get_name"] pub fn md_get_name (md_info : * const md_info_t) -> * const :: types :: raw_types :: c_char ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_md_starts"] pub fn md_starts (ctx : * mut md_context_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_md_update"] pub fn md_update (ctx : * mut md_context_t , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_md_finish"] pub fn md_finish (ctx : * mut md_context_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_md"] pub fn md (md_info : * const md_info_t , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_md_file"] pub fn md_file (md_info : * const md_info_t , path : * const :: types :: raw_types :: c_char , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_md_hmac_starts"] pub fn md_hmac_starts (ctx : * mut md_context_t , key : * const :: types :: raw_types :: c_uchar , keylen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_md_hmac_update"] pub fn md_hmac_update (ctx : * mut md_context_t , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_md_hmac_finish"] pub fn md_hmac_finish (ctx : * mut md_context_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_md_hmac_reset"] pub fn md_hmac_reset (ctx : * mut md_context_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_md_hmac"] pub fn md_hmac (md_info : * const md_info_t , key : * const :: types :: raw_types :: c_uchar , keylen : size_t , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_md_process"] pub fn md_process (ctx : * mut md_context_t , data : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct threading_mutex_t { pub mutex : pthread_mutex_t , pub is_valid : :: types :: raw_types :: c_char , } # [test] fn bindgen_test_layout_threading_mutex_t () { assert_eq ! (:: core :: mem :: size_of :: < threading_mutex_t > () , 48usize , concat ! ("Size of: " , stringify ! (threading_mutex_t))) ; assert_eq ! (:: core :: mem :: align_of :: < threading_mutex_t > () , 8usize , concat ! ("Alignment of " , stringify ! (threading_mutex_t))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < threading_mutex_t > ())) . mutex as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (threading_mutex_t) , "::" , stringify ! (mutex))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < threading_mutex_t > ())) . is_valid as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (threading_mutex_t) , "::" , stringify ! (is_valid))) ; } impl Default for threading_mutex_t { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_mutex_init"] pub static mut mutex_init : :: core :: option :: Option < unsafe extern "C" fn (mutex : * mut threading_mutex_t) > ; } extern "C" { # [link_name = "\u{1}mbedtls_mutex_free"] pub static mut mutex_free : :: core :: option :: Option < unsafe extern "C" fn (mutex : * mut threading_mutex_t) > ; } extern "C" { # [link_name = "\u{1}mbedtls_mutex_lock"] pub static mut mutex_lock : :: core :: option :: Option < unsafe extern "C" fn (mutex : * mut threading_mutex_t) -> :: types :: raw_types :: c_int > ; } extern "C" { # [link_name = "\u{1}mbedtls_mutex_unlock"] pub static mut mutex_unlock : :: core :: option :: Option < unsafe extern "C" fn (mutex : * mut threading_mutex_t) -> :: types :: raw_types :: c_int > ; } extern "C" { # [link_name = "\u{1}mbedtls_threading_readdir_mutex"] pub static mut threading_readdir_mutex : threading_mutex_t ; } extern "C" { # [link_name = "\u{1}mbedtls_threading_gmtime_mutex"] pub static mut threading_gmtime_mutex : threading_mutex_t ; } pub const ECP_DP_NONE : ecp_group_id = 0 ; pub const ECP_DP_SECP192R1 : ecp_group_id = 1 ; pub const ECP_DP_SECP224R1 : ecp_group_id = 2 ; pub const ECP_DP_SECP256R1 : ecp_group_id = 3 ; pub const ECP_DP_SECP384R1 : ecp_group_id = 4 ; pub const ECP_DP_SECP521R1 : ecp_group_id = 5 ; pub const ECP_DP_BP256R1 : ecp_group_id = 6 ; pub const ECP_DP_BP384R1 : ecp_group_id = 7 ; pub const ECP_DP_BP512R1 : ecp_group_id = 8 ; pub const ECP_DP_CURVE25519 : ecp_group_id = 9 ; pub const ECP_DP_SECP192K1 : ecp_group_id = 10 ; pub const ECP_DP_SECP224K1 : ecp_group_id = 11 ; pub const ECP_DP_SECP256K1 : ecp_group_id = 12 ; pub const ECP_DP_CURVE448 : ecp_group_id = 13 ; pub type ecp_group_id = u32 ; pub const ECP_TYPE_NONE : ecp_curve_type = 0 ; pub const ECP_TYPE_SHORT_WEIERSTRASS : ecp_curve_type = 1 ; pub const ECP_TYPE_MONTGOMERY : ecp_curve_type = 2 ; pub type ecp_curve_type = u32 ; # [repr (C)] # [derive (Copy , Clone)] pub struct ecp_curve_info { pub grp_id : ecp_group_id , pub tls_id : u16 , pub bit_size : u16 , pub name : * const :: types :: raw_types :: c_char , } # [test] fn bindgen_test_layout_ecp_curve_info () { assert_eq ! (:: core :: mem :: size_of :: < ecp_curve_info > () , 16usize , concat ! ("Size of: " , stringify ! (ecp_curve_info))) ; assert_eq ! (:: core :: mem :: align_of :: < ecp_curve_info > () , 8usize , concat ! ("Alignment of " , stringify ! (ecp_curve_info))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_curve_info > ())) . grp_id as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ecp_curve_info) , "::" , stringify ! (grp_id))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_curve_info > ())) . tls_id as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (ecp_curve_info) , "::" , stringify ! (tls_id))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_curve_info > ())) . bit_size as * const _ as usize } , 6usize , concat ! ("Offset of field: " , stringify ! (ecp_curve_info) , "::" , stringify ! (bit_size))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_curve_info > ())) . name as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ecp_curve_info) , "::" , stringify ! (name))) ; } impl Default for ecp_curve_info { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct ecp_point { pub X : mpi , pub Y : mpi , pub Z : mpi , } # [test] fn bindgen_test_layout_ecp_point () { assert_eq ! (:: core :: mem :: size_of :: < ecp_point > () , 72usize , concat ! ("Size of: " , stringify ! (ecp_point))) ; assert_eq ! (:: core :: mem :: align_of :: < ecp_point > () , 8usize , concat ! ("Alignment of " , stringify ! (ecp_point))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_point > ())) . X as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ecp_point) , "::" , stringify ! (X))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_point > ())) . Y as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (ecp_point) , "::" , stringify ! (Y))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_point > ())) . Z as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (ecp_point) , "::" , stringify ! (Z))) ; } impl Default for ecp_point { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct ecp_group { pub id : ecp_group_id , pub P : mpi , pub A : mpi , pub B : mpi , pub G : ecp_point , pub N : mpi , pub pbits : size_t , pub nbits : size_t , pub h : :: types :: raw_types :: c_uint , pub modp : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut mpi) -> :: types :: raw_types :: c_int > , pub t_pre : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut ecp_point , arg2 : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int > , pub t_post : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut ecp_point , arg2 : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int > , pub t_data : * mut :: types :: raw_types :: c_void , pub T : * mut ecp_point , pub T_size : size_t , } # [test] fn bindgen_test_layout_ecp_group () { assert_eq ! (:: core :: mem :: size_of :: < ecp_group > () , 248usize , concat ! ("Size of: " , stringify ! (ecp_group))) ; assert_eq ! (:: core :: mem :: align_of :: < ecp_group > () , 8usize , concat ! ("Alignment of " , stringify ! (ecp_group))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . id as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (id))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . P as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (P))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . A as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (A))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . B as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (B))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . G as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (G))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . N as * const _ as usize } , 152usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (N))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . pbits as * const _ as usize } , 176usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (pbits))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . nbits as * const _ as usize } , 184usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (nbits))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . h as * const _ as usize } , 192usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (h))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . modp as * const _ as usize } , 200usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (modp))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . t_pre as * const _ as usize } , 208usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (t_pre))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . t_post as * const _ as usize } , 216usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (t_post))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . t_data as * const _ as usize } , 224usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (t_data))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . T as * const _ as usize } , 232usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (T))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_group > ())) . T_size as * const _ as usize } , 240usize , concat ! ("Offset of field: " , stringify ! (ecp_group) , "::" , stringify ! (T_size))) ; } impl Default for ecp_group { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } pub type ecp_restart_ctx = :: types :: raw_types :: c_void ; # [repr (C)] # [derive (Copy , Clone)] pub struct ecp_keypair { pub grp : ecp_group , pub d : mpi , pub Q : ecp_point , } # [test] fn bindgen_test_layout_ecp_keypair () { assert_eq ! (:: core :: mem :: size_of :: < ecp_keypair > () , 344usize , concat ! ("Size of: " , stringify ! (ecp_keypair))) ; assert_eq ! (:: core :: mem :: align_of :: < ecp_keypair > () , 8usize , concat ! ("Alignment of " , stringify ! (ecp_keypair))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_keypair > ())) . grp as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ecp_keypair) , "::" , stringify ! (grp))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_keypair > ())) . d as * const _ as usize } , 248usize , concat ! ("Offset of field: " , stringify ! (ecp_keypair) , "::" , stringify ! (d))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecp_keypair > ())) . Q as * const _ as usize } , 272usize , concat ! ("Offset of field: " , stringify ! (ecp_keypair) , "::" , stringify ! (Q))) ; } impl Default for ecp_keypair { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_ecp_get_type"] pub fn ecp_get_type (grp : * const ecp_group) -> ecp_curve_type ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_curve_list"] pub fn ecp_curve_list () -> * const ecp_curve_info ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_grp_id_list"] pub fn ecp_grp_id_list () -> * const ecp_group_id ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_curve_info_from_grp_id"] pub fn ecp_curve_info_from_grp_id (grp_id : ecp_group_id) -> * const ecp_curve_info ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_curve_info_from_tls_id"] pub fn ecp_curve_info_from_tls_id (tls_id : u16) -> * const ecp_curve_info ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_curve_info_from_name"] pub fn ecp_curve_info_from_name (name : * const :: types :: raw_types :: c_char) -> * const ecp_curve_info ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_point_init"] pub fn ecp_point_init (pt : * mut ecp_point) ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_group_init"] pub fn ecp_group_init (grp : * mut ecp_group) ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_keypair_init"] pub fn ecp_keypair_init (key : * mut ecp_keypair) ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_point_free"] pub fn ecp_point_free (pt : * mut ecp_point) ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_group_free"] pub fn ecp_group_free (grp : * mut ecp_group) ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_keypair_free"] pub fn ecp_keypair_free (key : * mut ecp_keypair) ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_copy"] pub fn ecp_copy (P : * mut ecp_point , Q : * const ecp_point) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_group_copy"] pub fn ecp_group_copy (dst : * mut ecp_group , src : * const ecp_group) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_set_zero"] pub fn ecp_set_zero (pt : * mut ecp_point) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_is_zero"] pub fn ecp_is_zero (pt : * mut ecp_point) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_point_cmp"] pub fn ecp_point_cmp (P : * const ecp_point , Q : * const ecp_point) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_point_read_string"] pub fn ecp_point_read_string (P : * mut ecp_point , radix : :: types :: raw_types :: c_int , x : * const :: types :: raw_types :: c_char , y : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_point_write_binary"] pub fn ecp_point_write_binary (grp : * const ecp_group , P : * const ecp_point , format : :: types :: raw_types :: c_int , olen : * mut size_t , buf : * mut :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_point_read_binary"] pub fn ecp_point_read_binary (grp : * const ecp_group , P : * mut ecp_point , buf : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_tls_read_point"] pub fn ecp_tls_read_point (grp : * const ecp_group , pt : * mut ecp_point , buf : * mut * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_tls_write_point"] pub fn ecp_tls_write_point (grp : * const ecp_group , pt : * const ecp_point , format : :: types :: raw_types :: c_int , olen : * mut size_t , buf : * mut :: types :: raw_types :: c_uchar , blen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_group_load"] pub fn ecp_group_load (grp : * mut ecp_group , id : ecp_group_id) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_tls_read_group"] pub fn ecp_tls_read_group (grp : * mut ecp_group , buf : * mut * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_tls_read_group_id"] pub fn ecp_tls_read_group_id (grp : * mut ecp_group_id , buf : * mut * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_tls_write_group"] pub fn ecp_tls_write_group (grp : * const ecp_group , olen : * mut size_t , buf : * mut :: types :: raw_types :: c_uchar , blen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_mul"] pub fn ecp_mul (grp : * mut ecp_group , R : * mut ecp_point , m : * const mpi , P : * const ecp_point , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_mul_restartable"] pub fn ecp_mul_restartable (grp : * mut ecp_group , R : * mut ecp_point , m : * const mpi , P : * const ecp_point , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , rs_ctx : * mut ecp_restart_ctx) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_muladd"] pub fn ecp_muladd (grp : * mut ecp_group , R : * mut ecp_point , m : * const mpi , P : * const ecp_point , n : * const mpi , Q : * const ecp_point) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_muladd_restartable"] pub fn ecp_muladd_restartable (grp : * mut ecp_group , R : * mut ecp_point , m : * const mpi , P : * const ecp_point , n : * const mpi , Q : * const ecp_point , rs_ctx : * mut ecp_restart_ctx) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_check_pubkey"] pub fn ecp_check_pubkey (grp : * const ecp_group , pt : * const ecp_point) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_check_privkey"] pub fn ecp_check_privkey (grp : * const ecp_group , d : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_gen_privkey"] pub fn ecp_gen_privkey (grp : * const ecp_group , d : * mut mpi , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_gen_keypair_base"] pub fn ecp_gen_keypair_base (grp : * mut ecp_group , G : * const ecp_point , d : * mut mpi , Q : * mut ecp_point , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_gen_keypair"] pub fn ecp_gen_keypair (grp : * mut ecp_group , d : * mut mpi , Q : * mut ecp_point , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_gen_key"] pub fn ecp_gen_key (grp_id : ecp_group_id , key : * mut ecp_keypair , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_read_key"] pub fn ecp_read_key (grp_id : ecp_group_id , key : * mut ecp_keypair , buf : * const :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_write_key"] pub fn ecp_write_key (key : * mut ecp_keypair , buf : * mut :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_check_pub_priv"] pub fn ecp_check_pub_priv (pub_ : * const ecp_keypair , prv : * const ecp_keypair) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecp_self_test"] pub fn ecp_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct rsa_context { pub ver : :: types :: raw_types :: c_int , pub len : size_t , pub N : mpi , pub E : mpi , pub D : mpi , pub P : mpi , pub Q : mpi , pub DP : mpi , pub DQ : mpi , pub QP : mpi , pub RN : mpi , pub RP : mpi , pub RQ : mpi , pub Vi : mpi , pub Vf : mpi , pub padding : :: types :: raw_types :: c_int , pub hash_id : :: types :: raw_types :: c_int , pub mutex : threading_mutex_t , } # [test] fn bindgen_test_layout_rsa_context () { assert_eq ! (:: core :: mem :: size_of :: < rsa_context > () , 384usize , concat ! ("Size of: " , stringify ! (rsa_context))) ; assert_eq ! (:: core :: mem :: align_of :: < rsa_context > () , 8usize , concat ! ("Alignment of " , stringify ! (rsa_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . ver as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . len as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . N as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (N))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . E as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (E))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . D as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (D))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . P as * const _ as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (P))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . Q as * const _ as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (Q))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . DP as * const _ as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (DP))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . DQ as * const _ as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (DQ))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . QP as * const _ as usize } , 184usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (QP))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . RN as * const _ as usize } , 208usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (RN))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . RP as * const _ as usize } , 232usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (RP))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . RQ as * const _ as usize } , 256usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (RQ))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . Vi as * const _ as usize } , 280usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (Vi))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . Vf as * const _ as usize } , 304usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (Vf))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . padding as * const _ as usize } , 328usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (padding))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . hash_id as * const _ as usize } , 332usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (hash_id))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_context > ())) . mutex as * const _ as usize } , 336usize , concat ! ("Offset of field: " , stringify ! (rsa_context) , "::" , stringify ! (mutex))) ; } impl Default for rsa_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_rsa_init"] pub fn rsa_init (ctx : * mut rsa_context , padding : :: types :: raw_types :: c_int , hash_id : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_import"] pub fn rsa_import (ctx : * mut rsa_context , N : * const mpi , P : * const mpi , Q : * const mpi , D : * const mpi , E : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_import_raw"] pub fn rsa_import_raw (ctx : * mut rsa_context , N : * const :: types :: raw_types :: c_uchar , N_len : size_t , P : * const :: types :: raw_types :: c_uchar , P_len : size_t , Q : * const :: types :: raw_types :: c_uchar , Q_len : size_t , D : * const :: types :: raw_types :: c_uchar , D_len : size_t , E : * const :: types :: raw_types :: c_uchar , E_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_complete"] pub fn rsa_complete (ctx : * mut rsa_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_export"] pub fn rsa_export (ctx : * const rsa_context , N : * mut mpi , P : * mut mpi , Q : * mut mpi , D : * mut mpi , E : * mut mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_export_raw"] pub fn rsa_export_raw (ctx : * const rsa_context , N : * mut :: types :: raw_types :: c_uchar , N_len : size_t , P : * mut :: types :: raw_types :: c_uchar , P_len : size_t , Q : * mut :: types :: raw_types :: c_uchar , Q_len : size_t , D : * mut :: types :: raw_types :: c_uchar , D_len : size_t , E : * mut :: types :: raw_types :: c_uchar , E_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_export_crt"] pub fn rsa_export_crt (ctx : * const rsa_context , DP : * mut mpi , DQ : * mut mpi , QP : * mut mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_set_padding"] pub fn rsa_set_padding (ctx : * mut rsa_context , padding : :: types :: raw_types :: c_int , hash_id : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_get_len"] pub fn rsa_get_len (ctx : * const rsa_context) -> size_t ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_gen_key"] pub fn rsa_gen_key (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , nbits : :: types :: raw_types :: c_uint , exponent : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_check_pubkey"] pub fn rsa_check_pubkey (ctx : * const rsa_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_check_privkey"] pub fn rsa_check_privkey (ctx : * const rsa_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_check_pub_priv"] pub fn rsa_check_pub_priv (pub_ : * const rsa_context , prv : * const rsa_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_public"] pub fn rsa_public (ctx : * mut rsa_context , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_private"] pub fn rsa_private (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_pkcs1_encrypt"] pub fn rsa_pkcs1_encrypt (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , ilen : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_rsaes_pkcs1_v15_encrypt"] pub fn rsa_rsaes_pkcs1_v15_encrypt (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , ilen : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_rsaes_oaep_encrypt"] pub fn rsa_rsaes_oaep_encrypt (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , label : * const :: types :: raw_types :: c_uchar , label_len : size_t , ilen : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_pkcs1_decrypt"] pub fn rsa_pkcs1_decrypt (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , olen : * mut size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar , output_max_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_rsaes_pkcs1_v15_decrypt"] pub fn rsa_rsaes_pkcs1_v15_decrypt (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , olen : * mut size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar , output_max_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_rsaes_oaep_decrypt"] pub fn rsa_rsaes_oaep_decrypt (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , label : * const :: types :: raw_types :: c_uchar , label_len : size_t , olen : * mut size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar , output_max_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_pkcs1_sign"] pub fn rsa_pkcs1_sign (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , md_alg : md_type_t , hashlen : :: types :: raw_types :: c_uint , hash : * const :: types :: raw_types :: c_uchar , sig : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_rsassa_pkcs1_v15_sign"] pub fn rsa_rsassa_pkcs1_v15_sign (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , md_alg : md_type_t , hashlen : :: types :: raw_types :: c_uint , hash : * const :: types :: raw_types :: c_uchar , sig : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_rsassa_pss_sign_ext"] pub fn rsa_rsassa_pss_sign_ext (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , md_alg : md_type_t , hashlen : :: types :: raw_types :: c_uint , hash : * const :: types :: raw_types :: c_uchar , saltlen : :: types :: raw_types :: c_int , sig : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_rsassa_pss_sign"] pub fn rsa_rsassa_pss_sign (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , md_alg : md_type_t , hashlen : :: types :: raw_types :: c_uint , hash : * const :: types :: raw_types :: c_uchar , sig : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_pkcs1_verify"] pub fn rsa_pkcs1_verify (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , md_alg : md_type_t , hashlen : :: types :: raw_types :: c_uint , hash : * const :: types :: raw_types :: c_uchar , sig : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_rsassa_pkcs1_v15_verify"] pub fn rsa_rsassa_pkcs1_v15_verify (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , md_alg : md_type_t , hashlen : :: types :: raw_types :: c_uint , hash : * const :: types :: raw_types :: c_uchar , sig : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_rsassa_pss_verify"] pub fn rsa_rsassa_pss_verify (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , md_alg : md_type_t , hashlen : :: types :: raw_types :: c_uint , hash : * const :: types :: raw_types :: c_uchar , sig : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_rsassa_pss_verify_ext"] pub fn rsa_rsassa_pss_verify_ext (ctx : * mut rsa_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , md_alg : md_type_t , hashlen : :: types :: raw_types :: c_uint , hash : * const :: types :: raw_types :: c_uchar , mgf1_hash_id : md_type_t , expected_salt_len : :: types :: raw_types :: c_int , sig : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_copy"] pub fn rsa_copy (dst : * mut rsa_context , src : * const rsa_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_free"] pub fn rsa_free (ctx : * mut rsa_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_self_test"] pub fn rsa_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } pub type ecdsa_context = ecp_keypair ; pub type ecdsa_restart_ctx = :: types :: raw_types :: c_void ; extern "C" { # [link_name = "\u{1}mbedtls_ecdsa_can_do"] pub fn ecdsa_can_do (gid : ecp_group_id) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdsa_sign"] pub fn ecdsa_sign (grp : * mut ecp_group , r : * mut mpi , s : * mut mpi , d : * const mpi , buf : * const :: types :: raw_types :: c_uchar , blen : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdsa_verify"] pub fn ecdsa_verify (grp : * mut ecp_group , buf : * const :: types :: raw_types :: c_uchar , blen : size_t , Q : * const ecp_point , r : * const mpi , s : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdsa_write_signature"] pub fn ecdsa_write_signature (ctx : * mut ecdsa_context , md_alg : md_type_t , hash : * const :: types :: raw_types :: c_uchar , hlen : size_t , sig : * mut :: types :: raw_types :: c_uchar , slen : * mut size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdsa_write_signature_restartable"] pub fn ecdsa_write_signature_restartable (ctx : * mut ecdsa_context , md_alg : md_type_t , hash : * const :: types :: raw_types :: c_uchar , hlen : size_t , sig : * mut :: types :: raw_types :: c_uchar , slen : * mut size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , rs_ctx : * mut ecdsa_restart_ctx) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdsa_read_signature"] pub fn ecdsa_read_signature (ctx : * mut ecdsa_context , hash : * const :: types :: raw_types :: c_uchar , hlen : size_t , sig : * const :: types :: raw_types :: c_uchar , slen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdsa_read_signature_restartable"] pub fn ecdsa_read_signature_restartable (ctx : * mut ecdsa_context , hash : * const :: types :: raw_types :: c_uchar , hlen : size_t , sig : * const :: types :: raw_types :: c_uchar , slen : size_t , rs_ctx : * mut ecdsa_restart_ctx) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdsa_genkey"] pub fn ecdsa_genkey (ctx : * mut ecdsa_context , gid : ecp_group_id , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdsa_from_keypair"] pub fn ecdsa_from_keypair (ctx : * mut ecdsa_context , key : * const ecp_keypair) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdsa_init"] pub fn ecdsa_init (ctx : * mut ecdsa_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdsa_free"] pub fn ecdsa_free (ctx : * mut ecdsa_context) ; } # [repr (C)] # [derive (Copy , Clone)] pub struct asn1_buf { pub tag : :: types :: raw_types :: c_int , pub len : size_t , pub p : * mut :: types :: raw_types :: c_uchar , } # [test] fn bindgen_test_layout_asn1_buf () { assert_eq ! (:: core :: mem :: size_of :: < asn1_buf > () , 24usize , concat ! ("Size of: " , stringify ! (asn1_buf))) ; assert_eq ! (:: core :: mem :: align_of :: < asn1_buf > () , 8usize , concat ! ("Alignment of " , stringify ! (asn1_buf))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < asn1_buf > ())) . tag as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (asn1_buf) , "::" , stringify ! (tag))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < asn1_buf > ())) . len as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (asn1_buf) , "::" , stringify ! (len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < asn1_buf > ())) . p as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (asn1_buf) , "::" , stringify ! (p))) ; } impl Default for asn1_buf { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct asn1_bitstring { pub len : size_t , pub unused_bits : :: types :: raw_types :: c_uchar , pub p : * mut :: types :: raw_types :: c_uchar , } # [test] fn bindgen_test_layout_asn1_bitstring () { assert_eq ! (:: core :: mem :: size_of :: < asn1_bitstring > () , 24usize , concat ! ("Size of: " , stringify ! (asn1_bitstring))) ; assert_eq ! (:: core :: mem :: align_of :: < asn1_bitstring > () , 8usize , concat ! ("Alignment of " , stringify ! (asn1_bitstring))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < asn1_bitstring > ())) . len as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (asn1_bitstring) , "::" , stringify ! (len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < asn1_bitstring > ())) . unused_bits as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (asn1_bitstring) , "::" , stringify ! (unused_bits))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < asn1_bitstring > ())) . p as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (asn1_bitstring) , "::" , stringify ! (p))) ; } impl Default for asn1_bitstring { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct asn1_sequence { pub buf : asn1_buf , pub next : * mut asn1_sequence , } # [test] fn bindgen_test_layout_asn1_sequence () { assert_eq ! (:: core :: mem :: size_of :: < asn1_sequence > () , 32usize , concat ! ("Size of: " , stringify ! (asn1_sequence))) ; assert_eq ! (:: core :: mem :: align_of :: < asn1_sequence > () , 8usize , concat ! ("Alignment of " , stringify ! (asn1_sequence))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < asn1_sequence > ())) . buf as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (asn1_sequence) , "::" , stringify ! (buf))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < asn1_sequence > ())) . next as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (asn1_sequence) , "::" , stringify ! (next))) ; } impl Default for asn1_sequence { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct asn1_named_data { pub oid : asn1_buf , pub val : asn1_buf , pub next : * mut asn1_named_data , pub next_merged : :: types :: raw_types :: c_uchar , } # [test] fn bindgen_test_layout_asn1_named_data () { assert_eq ! (:: core :: mem :: size_of :: < asn1_named_data > () , 64usize , concat ! ("Size of: " , stringify ! (asn1_named_data))) ; assert_eq ! (:: core :: mem :: align_of :: < asn1_named_data > () , 8usize , concat ! ("Alignment of " , stringify ! (asn1_named_data))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < asn1_named_data > ())) . oid as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (asn1_named_data) , "::" , stringify ! (oid))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < asn1_named_data > ())) . val as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (asn1_named_data) , "::" , stringify ! (val))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < asn1_named_data > ())) . next as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (asn1_named_data) , "::" , stringify ! (next))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < asn1_named_data > ())) . next_merged as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (asn1_named_data) , "::" , stringify ! (next_merged))) ; } impl Default for asn1_named_data { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_asn1_get_len"] pub fn asn1_get_len (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , len : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_get_tag"] pub fn asn1_get_tag (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , len : * mut size_t , tag : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_get_bool"] pub fn asn1_get_bool (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , val : * mut :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_get_int"] pub fn asn1_get_int (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , val : * mut :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_get_enum"] pub fn asn1_get_enum (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , val : * mut :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_get_bitstring"] pub fn asn1_get_bitstring (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , bs : * mut asn1_bitstring) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_get_bitstring_null"] pub fn asn1_get_bitstring_null (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , len : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_get_sequence_of"] pub fn asn1_get_sequence_of (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , cur : * mut asn1_sequence , tag : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_sequence_free"] pub fn asn1_sequence_free (seq : * mut asn1_sequence) ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_traverse_sequence_of"] pub fn asn1_traverse_sequence_of (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , tag_must_mask : :: types :: raw_types :: c_uchar , tag_must_val : :: types :: raw_types :: c_uchar , tag_may_mask : :: types :: raw_types :: c_uchar , tag_may_val : :: types :: raw_types :: c_uchar , cb : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , tag : :: types :: raw_types :: c_int , start : * mut :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int > , ctx : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_get_mpi"] pub fn asn1_get_mpi (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , X : * mut mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_get_alg"] pub fn asn1_get_alg (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , alg : * mut asn1_buf , params : * mut asn1_buf) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_get_alg_null"] pub fn asn1_get_alg_null (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , alg : * mut asn1_buf) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_find_named_data"] pub fn asn1_find_named_data (list : * mut asn1_named_data , oid : * const :: types :: raw_types :: c_char , len : size_t) -> * mut asn1_named_data ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_free_named_data"] pub fn asn1_free_named_data (entry : * mut asn1_named_data) ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_free_named_data_list"] pub fn asn1_free_named_data_list (head : * mut * mut asn1_named_data) ; } pub const PK_NONE : pk_type_t = 0 ; pub const PK_RSA : pk_type_t = 1 ; pub const PK_ECKEY : pk_type_t = 2 ; pub const PK_ECKEY_DH : pk_type_t = 3 ; pub const PK_ECDSA : pk_type_t = 4 ; pub const PK_RSA_ALT : pk_type_t = 5 ; pub const PK_RSASSA_PSS : pk_type_t = 6 ; pub const PK_OPAQUE : pk_type_t = 7 ; pub type pk_type_t = u32 ; # [repr (C)] # [derive (Copy , Clone)] pub struct pk_rsassa_pss_options { pub mgf1_hash_id : md_type_t , pub expected_salt_len : :: types :: raw_types :: c_int , } # [test] fn bindgen_test_layout_pk_rsassa_pss_options () { assert_eq ! (:: core :: mem :: size_of :: < pk_rsassa_pss_options > () , 8usize , concat ! ("Size of: " , stringify ! (pk_rsassa_pss_options))) ; assert_eq ! (:: core :: mem :: align_of :: < pk_rsassa_pss_options > () , 4usize , concat ! ("Alignment of " , stringify ! (pk_rsassa_pss_options))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_rsassa_pss_options > ())) . mgf1_hash_id as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pk_rsassa_pss_options) , "::" , stringify ! (mgf1_hash_id))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_rsassa_pss_options > ())) . expected_salt_len as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (pk_rsassa_pss_options) , "::" , stringify ! (expected_salt_len))) ; } impl Default for pk_rsassa_pss_options { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } pub const PK_DEBUG_NONE : pk_debug_type = 0 ; pub const PK_DEBUG_MPI : pk_debug_type = 1 ; pub const PK_DEBUG_ECP : pk_debug_type = 2 ; pub type pk_debug_type = u32 ; # [repr (C)] # [derive (Copy , Clone)] pub struct pk_debug_item { pub type_ : pk_debug_type , pub name : * const :: types :: raw_types :: c_char , pub value : * mut :: types :: raw_types :: c_void , } # [test] fn bindgen_test_layout_pk_debug_item () { assert_eq ! (:: core :: mem :: size_of :: < pk_debug_item > () , 24usize , concat ! ("Size of: " , stringify ! (pk_debug_item))) ; assert_eq ! (:: core :: mem :: align_of :: < pk_debug_item > () , 8usize , concat ! ("Alignment of " , stringify ! (pk_debug_item))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_debug_item > ())) . type_ as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pk_debug_item) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_debug_item > ())) . name as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (pk_debug_item) , "::" , stringify ! (name))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_debug_item > ())) . value as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (pk_debug_item) , "::" , stringify ! (value))) ; } impl Default for pk_debug_item { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct pk_context { pub pk_info : * const pk_info_t , pub pk_ctx : * mut :: types :: raw_types :: c_void , } # [test] fn bindgen_test_layout_pk_context () { assert_eq ! (:: core :: mem :: size_of :: < pk_context > () , 16usize , concat ! ("Size of: " , stringify ! (pk_context))) ; assert_eq ! (:: core :: mem :: align_of :: < pk_context > () , 8usize , concat ! ("Alignment of " , stringify ! (pk_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_context > ())) . pk_info as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pk_context) , "::" , stringify ! (pk_info))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_context > ())) . pk_ctx as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (pk_context) , "::" , stringify ! (pk_ctx))) ; } impl Default for pk_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } pub type pk_restart_ctx = :: types :: raw_types :: c_void ; pub type pk_rsa_alt_decrypt_func = :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , olen : * mut size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar , output_max_len : size_t) -> :: types :: raw_types :: c_int > ; pub type pk_rsa_alt_sign_func = :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , mode : :: types :: raw_types :: c_int , md_alg : md_type_t , hashlen : :: types :: raw_types :: c_uint , hash : * const :: types :: raw_types :: c_uchar , sig : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int > ; pub type pk_rsa_alt_key_len_func = :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void) -> size_t > ; extern "C" { # [link_name = "\u{1}mbedtls_pk_info_from_type"] pub fn pk_info_from_type (pk_type : pk_type_t) -> * const pk_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_init"] pub fn pk_init (ctx : * mut pk_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_free"] pub fn pk_free (ctx : * mut pk_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_setup"] pub fn pk_setup (ctx : * mut pk_context , info : * const pk_info_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_setup_rsa_alt"] pub fn pk_setup_rsa_alt (ctx : * mut pk_context , key : * mut :: types :: raw_types :: c_void , decrypt_func : pk_rsa_alt_decrypt_func , sign_func : pk_rsa_alt_sign_func , key_len_func : pk_rsa_alt_key_len_func) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_get_bitlen"] pub fn pk_get_bitlen (ctx : * const pk_context) -> size_t ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_can_do"] pub fn pk_can_do (ctx : * const pk_context , type_ : pk_type_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_verify"] pub fn pk_verify (ctx : * mut pk_context , md_alg : md_type_t , hash : * const :: types :: raw_types :: c_uchar , hash_len : size_t , sig : * const :: types :: raw_types :: c_uchar , sig_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_verify_restartable"] pub fn pk_verify_restartable (ctx : * mut pk_context , md_alg : md_type_t , hash : * const :: types :: raw_types :: c_uchar , hash_len : size_t , sig : * const :: types :: raw_types :: c_uchar , sig_len : size_t , rs_ctx : * mut pk_restart_ctx) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_verify_ext"] pub fn pk_verify_ext (type_ : pk_type_t , options : * const :: types :: raw_types :: c_void , ctx : * mut pk_context , md_alg : md_type_t , hash : * const :: types :: raw_types :: c_uchar , hash_len : size_t , sig : * const :: types :: raw_types :: c_uchar , sig_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_sign"] pub fn pk_sign (ctx : * mut pk_context , md_alg : md_type_t , hash : * const :: types :: raw_types :: c_uchar , hash_len : size_t , sig : * mut :: types :: raw_types :: c_uchar , sig_len : * mut size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_sign_restartable"] pub fn pk_sign_restartable (ctx : * mut pk_context , md_alg : md_type_t , hash : * const :: types :: raw_types :: c_uchar , hash_len : size_t , sig : * mut :: types :: raw_types :: c_uchar , sig_len : * mut size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , rs_ctx : * mut pk_restart_ctx) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_decrypt"] pub fn pk_decrypt (ctx : * mut pk_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , olen : * mut size_t , osize : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_encrypt"] pub fn pk_encrypt (ctx : * mut pk_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , olen : * mut size_t , osize : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_check_pair"] pub fn pk_check_pair (pub_ : * const pk_context , prv : * const pk_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_debug"] pub fn pk_debug (ctx : * const pk_context , items : * mut pk_debug_item) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_get_name"] pub fn pk_get_name (ctx : * const pk_context) -> * const :: types :: raw_types :: c_char ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_get_type"] pub fn pk_get_type (ctx : * const pk_context) -> pk_type_t ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_parse_key"] pub fn pk_parse_key (ctx : * mut pk_context , key : * const :: types :: raw_types :: c_uchar , keylen : size_t , pwd : * const :: types :: raw_types :: c_uchar , pwdlen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_parse_public_key"] pub fn pk_parse_public_key (ctx : * mut pk_context , key : * const :: types :: raw_types :: c_uchar , keylen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_parse_keyfile"] pub fn pk_parse_keyfile (ctx : * mut pk_context , path : * const :: types :: raw_types :: c_char , password : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_parse_public_keyfile"] pub fn pk_parse_public_keyfile (ctx : * mut pk_context , path : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_write_key_der"] pub fn pk_write_key_der (ctx : * mut pk_context , buf : * mut :: types :: raw_types :: c_uchar , size : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_write_pubkey_der"] pub fn pk_write_pubkey_der (ctx : * mut pk_context , buf : * mut :: types :: raw_types :: c_uchar , size : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_write_pubkey_pem"] pub fn pk_write_pubkey_pem (ctx : * mut pk_context , buf : * mut :: types :: raw_types :: c_uchar , size : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_write_key_pem"] pub fn pk_write_key_pem (ctx : * mut pk_context , buf : * mut :: types :: raw_types :: c_uchar , size : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_parse_subpubkey"] pub fn pk_parse_subpubkey (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , pk : * mut pk_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_write_pubkey"] pub fn pk_write_pubkey (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , key : * const pk_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pk_load_file"] pub fn pk_load_file (path : * const :: types :: raw_types :: c_char , buf : * mut * mut :: types :: raw_types :: c_uchar , n : * mut size_t) -> :: types :: raw_types :: c_int ; } pub type x509_buf = asn1_buf ; pub type x509_bitstring = asn1_bitstring ; pub type x509_name = asn1_named_data ; pub type x509_sequence = asn1_sequence ; # [repr (C)] # [derive (Default , Copy , Clone)] pub struct x509_time { pub year : :: types :: raw_types :: c_int , pub mon : :: types :: raw_types :: c_int , pub day : :: types :: raw_types :: c_int , pub hour : :: types :: raw_types :: c_int , pub min : :: types :: raw_types :: c_int , pub sec : :: types :: raw_types :: c_int , } # [test] fn bindgen_test_layout_x509_time () { assert_eq ! (:: core :: mem :: size_of :: < x509_time > () , 24usize , concat ! ("Size of: " , stringify ! (x509_time))) ; assert_eq ! (:: core :: mem :: align_of :: < x509_time > () , 4usize , concat ! ("Alignment of " , stringify ! (x509_time))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_time > ())) . year as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_time) , "::" , stringify ! (year))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_time > ())) . mon as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (x509_time) , "::" , stringify ! (mon))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_time > ())) . day as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (x509_time) , "::" , stringify ! (day))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_time > ())) . hour as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (x509_time) , "::" , stringify ! (hour))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_time > ())) . min as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (x509_time) , "::" , stringify ! (min))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_time > ())) . sec as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (x509_time) , "::" , stringify ! (sec))) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_dn_gets"] pub fn x509_dn_gets (buf : * mut :: types :: raw_types :: c_char , size : size_t , dn : * const x509_name) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_serial_gets"] pub fn x509_serial_gets (buf : * mut :: types :: raw_types :: c_char , size : size_t , serial : * const x509_buf) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_time_is_past"] pub fn x509_time_is_past (to : * const x509_time) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_time_is_future"] pub fn x509_time_is_future (from : * const x509_time) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_self_test"] pub fn x509_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_get_name"] pub fn x509_get_name (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , cur : * mut x509_name) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_get_alg_null"] pub fn x509_get_alg_null (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , alg : * mut x509_buf) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_get_alg"] pub fn x509_get_alg (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , alg : * mut x509_buf , params : * mut x509_buf) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_get_rsassa_pss_params"] pub fn x509_get_rsassa_pss_params (params : * const x509_buf , md_alg : * mut md_type_t , mgf_md : * mut md_type_t , salt_len : * mut :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_get_sig"] pub fn x509_get_sig (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , sig : * mut x509_buf) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_get_sig_alg"] pub fn x509_get_sig_alg (sig_oid : * const x509_buf , sig_params : * const x509_buf , md_alg : * mut md_type_t , pk_alg : * mut pk_type_t , sig_opts : * mut * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_get_time"] pub fn x509_get_time (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , t : * mut x509_time) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_get_serial"] pub fn x509_get_serial (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , serial : * mut x509_buf) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_get_ext"] pub fn x509_get_ext (p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , ext : * mut x509_buf , tag : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_sig_alg_gets"] pub fn x509_sig_alg_gets (buf : * mut :: types :: raw_types :: c_char , size : size_t , sig_oid : * const x509_buf , pk_alg : pk_type_t , md_alg : md_type_t , sig_opts : * const :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_key_size_helper"] pub fn x509_key_size_helper (buf : * mut :: types :: raw_types :: c_char , buf_size : size_t , name : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_string_to_names"] pub fn x509_string_to_names (head : * mut * mut asn1_named_data , name : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_set_extension"] pub fn x509_set_extension (head : * mut * mut asn1_named_data , oid : * const :: types :: raw_types :: c_char , oid_len : size_t , critical : :: types :: raw_types :: c_int , val : * const :: types :: raw_types :: c_uchar , val_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_write_extensions"] pub fn x509_write_extensions (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , first : * mut asn1_named_data) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_write_names"] pub fn x509_write_names (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , first : * mut asn1_named_data) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_write_sig"] pub fn x509_write_sig (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , oid : * const :: types :: raw_types :: c_char , oid_len : size_t , sig : * mut :: types :: raw_types :: c_uchar , size : size_t) -> :: types :: raw_types :: c_int ; } pub const CIPHER_ID_NONE : cipher_id_t = 0 ; pub const CIPHER_ID_NULL : cipher_id_t = 1 ; pub const CIPHER_ID_AES : cipher_id_t = 2 ; pub const CIPHER_ID_DES : cipher_id_t = 3 ; pub const CIPHER_ID_3DES : cipher_id_t = 4 ; pub const CIPHER_ID_CAMELLIA : cipher_id_t = 5 ; pub const CIPHER_ID_BLOWFISH : cipher_id_t = 6 ; pub const CIPHER_ID_ARC4 : cipher_id_t = 7 ; pub const CIPHER_ID_ARIA : cipher_id_t = 8 ; pub const CIPHER_ID_CHACHA20 : cipher_id_t = 9 ; pub type cipher_id_t = u32 ; pub const CIPHER_NONE : cipher_type_t = 0 ; pub const CIPHER_NULL : cipher_type_t = 1 ; pub const CIPHER_AES_128_ECB : cipher_type_t = 2 ; pub const CIPHER_AES_192_ECB : cipher_type_t = 3 ; pub const CIPHER_AES_256_ECB : cipher_type_t = 4 ; pub const CIPHER_AES_128_CBC : cipher_type_t = 5 ; pub const CIPHER_AES_192_CBC : cipher_type_t = 6 ; pub const CIPHER_AES_256_CBC : cipher_type_t = 7 ; pub const CIPHER_AES_128_CFB128 : cipher_type_t = 8 ; pub const CIPHER_AES_192_CFB128 : cipher_type_t = 9 ; pub const CIPHER_AES_256_CFB128 : cipher_type_t = 10 ; pub const CIPHER_AES_128_CTR : cipher_type_t = 11 ; pub const CIPHER_AES_192_CTR : cipher_type_t = 12 ; pub const CIPHER_AES_256_CTR : cipher_type_t = 13 ; pub const CIPHER_AES_128_GCM : cipher_type_t = 14 ; pub const CIPHER_AES_192_GCM : cipher_type_t = 15 ; pub const CIPHER_AES_256_GCM : cipher_type_t = 16 ; pub const CIPHER_CAMELLIA_128_ECB : cipher_type_t = 17 ; pub const CIPHER_CAMELLIA_192_ECB : cipher_type_t = 18 ; pub const CIPHER_CAMELLIA_256_ECB : cipher_type_t = 19 ; pub const CIPHER_CAMELLIA_128_CBC : cipher_type_t = 20 ; pub const CIPHER_CAMELLIA_192_CBC : cipher_type_t = 21 ; pub const CIPHER_CAMELLIA_256_CBC : cipher_type_t = 22 ; pub const CIPHER_CAMELLIA_128_CFB128 : cipher_type_t = 23 ; pub const CIPHER_CAMELLIA_192_CFB128 : cipher_type_t = 24 ; pub const CIPHER_CAMELLIA_256_CFB128 : cipher_type_t = 25 ; pub const CIPHER_CAMELLIA_128_CTR : cipher_type_t = 26 ; pub const CIPHER_CAMELLIA_192_CTR : cipher_type_t = 27 ; pub const CIPHER_CAMELLIA_256_CTR : cipher_type_t = 28 ; pub const CIPHER_CAMELLIA_128_GCM : cipher_type_t = 29 ; pub const CIPHER_CAMELLIA_192_GCM : cipher_type_t = 30 ; pub const CIPHER_CAMELLIA_256_GCM : cipher_type_t = 31 ; pub const CIPHER_DES_ECB : cipher_type_t = 32 ; pub const CIPHER_DES_CBC : cipher_type_t = 33 ; pub const CIPHER_DES_EDE_ECB : cipher_type_t = 34 ; pub const CIPHER_DES_EDE_CBC : cipher_type_t = 35 ; pub const CIPHER_DES_EDE3_ECB : cipher_type_t = 36 ; pub const CIPHER_DES_EDE3_CBC : cipher_type_t = 37 ; pub const CIPHER_BLOWFISH_ECB : cipher_type_t = 38 ; pub const CIPHER_BLOWFISH_CBC : cipher_type_t = 39 ; pub const CIPHER_BLOWFISH_CFB64 : cipher_type_t = 40 ; pub const CIPHER_BLOWFISH_CTR : cipher_type_t = 41 ; pub const CIPHER_ARC4_128 : cipher_type_t = 42 ; pub const CIPHER_AES_128_CCM : cipher_type_t = 43 ; pub const CIPHER_AES_192_CCM : cipher_type_t = 44 ; pub const CIPHER_AES_256_CCM : cipher_type_t = 45 ; pub const CIPHER_CAMELLIA_128_CCM : cipher_type_t = 46 ; pub const CIPHER_CAMELLIA_192_CCM : cipher_type_t = 47 ; pub const CIPHER_CAMELLIA_256_CCM : cipher_type_t = 48 ; pub const CIPHER_ARIA_128_ECB : cipher_type_t = 49 ; pub const CIPHER_ARIA_192_ECB : cipher_type_t = 50 ; pub const CIPHER_ARIA_256_ECB : cipher_type_t = 51 ; pub const CIPHER_ARIA_128_CBC : cipher_type_t = 52 ; pub const CIPHER_ARIA_192_CBC : cipher_type_t = 53 ; pub const CIPHER_ARIA_256_CBC : cipher_type_t = 54 ; pub const CIPHER_ARIA_128_CFB128 : cipher_type_t = 55 ; pub const CIPHER_ARIA_192_CFB128 : cipher_type_t = 56 ; pub const CIPHER_ARIA_256_CFB128 : cipher_type_t = 57 ; pub const CIPHER_ARIA_128_CTR : cipher_type_t = 58 ; pub const CIPHER_ARIA_192_CTR : cipher_type_t = 59 ; pub const CIPHER_ARIA_256_CTR : cipher_type_t = 60 ; pub const CIPHER_ARIA_128_GCM : cipher_type_t = 61 ; pub const CIPHER_ARIA_192_GCM : cipher_type_t = 62 ; pub const CIPHER_ARIA_256_GCM : cipher_type_t = 63 ; pub const CIPHER_ARIA_128_CCM : cipher_type_t = 64 ; pub const CIPHER_ARIA_192_CCM : cipher_type_t = 65 ; pub const CIPHER_ARIA_256_CCM : cipher_type_t = 66 ; pub const CIPHER_AES_128_OFB : cipher_type_t = 67 ; pub const CIPHER_AES_192_OFB : cipher_type_t = 68 ; pub const CIPHER_AES_256_OFB : cipher_type_t = 69 ; pub const CIPHER_AES_128_XTS : cipher_type_t = 70 ; pub const CIPHER_AES_256_XTS : cipher_type_t = 71 ; pub const CIPHER_CHACHA20 : cipher_type_t = 72 ; pub const CIPHER_CHACHA20_POLY1305 : cipher_type_t = 73 ; pub const CIPHER_AES_128_KW : cipher_type_t = 74 ; pub const CIPHER_AES_192_KW : cipher_type_t = 75 ; pub const CIPHER_AES_256_KW : cipher_type_t = 76 ; pub const CIPHER_AES_128_KWP : cipher_type_t = 77 ; pub const CIPHER_AES_192_KWP : cipher_type_t = 78 ; pub const CIPHER_AES_256_KWP : cipher_type_t = 79 ; pub type cipher_type_t = u32 ; pub const MODE_NONE : cipher_mode_t = 0 ; pub const MODE_ECB : cipher_mode_t = 1 ; pub const MODE_CBC : cipher_mode_t = 2 ; pub const MODE_CFB : cipher_mode_t = 3 ; pub const MODE_OFB : cipher_mode_t = 4 ; pub const MODE_CTR : cipher_mode_t = 5 ; pub const MODE_GCM : cipher_mode_t = 6 ; pub const MODE_STREAM : cipher_mode_t = 7 ; pub const MODE_CCM : cipher_mode_t = 8 ; pub const MODE_XTS : cipher_mode_t = 9 ; pub const MODE_CHACHAPOLY : cipher_mode_t = 10 ; pub const MODE_KW : cipher_mode_t = 11 ; pub const MODE_KWP : cipher_mode_t = 12 ; pub type cipher_mode_t = u32 ; pub const PADDING_PKCS7 : cipher_padding_t = 0 ; pub const PADDING_ONE_AND_ZEROS : cipher_padding_t = 1 ; pub const PADDING_ZEROS_AND_LEN : cipher_padding_t = 2 ; pub const PADDING_ZEROS : cipher_padding_t = 3 ; pub const PADDING_NONE : cipher_padding_t = 4 ; pub type cipher_padding_t = u32 ; pub const OPERATION_NONE : operation_t = - 1 ; pub const DECRYPT : operation_t = 0 ; pub const ENCRYPT : operation_t = 1 ; pub type operation_t = i32 ; pub const KEY_LENGTH_NONE : u32 = 0 ; pub const KEY_LENGTH_DES : u32 = 64 ; pub const KEY_LENGTH_DES_EDE : u32 = 128 ; pub const KEY_LENGTH_DES_EDE3 : u32 = 192 ; pub type _bindgen_ty_11 = u32 ; # [repr (C)] # [derive (Copy , Clone)] pub struct cipher_info_t { pub type_ : cipher_type_t , pub mode : cipher_mode_t , pub key_bitlen : :: types :: raw_types :: c_uint , pub name : * const :: types :: raw_types :: c_char , pub iv_size : :: types :: raw_types :: c_uint , pub flags : :: types :: raw_types :: c_int , pub block_size : :: types :: raw_types :: c_uint , pub base : * const cipher_base_t , } # [test] fn bindgen_test_layout_cipher_info_t () { assert_eq ! (:: core :: mem :: size_of :: < cipher_info_t > () , 48usize , concat ! ("Size of: " , stringify ! (cipher_info_t))) ; assert_eq ! (:: core :: mem :: align_of :: < cipher_info_t > () , 8usize , concat ! ("Alignment of " , stringify ! (cipher_info_t))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_info_t > ())) . type_ as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (cipher_info_t) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_info_t > ())) . mode as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (cipher_info_t) , "::" , stringify ! (mode))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_info_t > ())) . key_bitlen as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (cipher_info_t) , "::" , stringify ! (key_bitlen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_info_t > ())) . name as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (cipher_info_t) , "::" , stringify ! (name))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_info_t > ())) . iv_size as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (cipher_info_t) , "::" , stringify ! (iv_size))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_info_t > ())) . flags as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (cipher_info_t) , "::" , stringify ! (flags))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_info_t > ())) . block_size as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (cipher_info_t) , "::" , stringify ! (block_size))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_info_t > ())) . base as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (cipher_info_t) , "::" , stringify ! (base))) ; } impl Default for cipher_info_t { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct cipher_context_t { pub cipher_info : * const cipher_info_t , pub key_bitlen : :: types :: raw_types :: c_int , pub operation : operation_t , pub add_padding : :: core :: option :: Option < unsafe extern "C" fn (output : * mut :: types :: raw_types :: c_uchar , olen : size_t , data_len : size_t) > , pub get_padding : :: core :: option :: Option < unsafe extern "C" fn (input : * mut :: types :: raw_types :: c_uchar , ilen : size_t , data_len : * mut size_t) -> :: types :: raw_types :: c_int > , pub unprocessed_data : [:: types :: raw_types :: c_uchar ; 16usize] , pub unprocessed_len : size_t , pub iv : [:: types :: raw_types :: c_uchar ; 16usize] , pub iv_size : size_t , pub cipher_ctx : * mut :: types :: raw_types :: c_void , pub cmac_ctx : * mut cmac_context_t , } # [test] fn bindgen_test_layout_cipher_context_t () { assert_eq ! (:: core :: mem :: size_of :: < cipher_context_t > () , 96usize , concat ! ("Size of: " , stringify ! (cipher_context_t))) ; assert_eq ! (:: core :: mem :: align_of :: < cipher_context_t > () , 8usize , concat ! ("Alignment of " , stringify ! (cipher_context_t))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_context_t > ())) . cipher_info as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (cipher_context_t) , "::" , stringify ! (cipher_info))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_context_t > ())) . key_bitlen as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (cipher_context_t) , "::" , stringify ! (key_bitlen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_context_t > ())) . operation as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (cipher_context_t) , "::" , stringify ! (operation))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_context_t > ())) . add_padding as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (cipher_context_t) , "::" , stringify ! (add_padding))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_context_t > ())) . get_padding as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (cipher_context_t) , "::" , stringify ! (get_padding))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_context_t > ())) . unprocessed_data as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (cipher_context_t) , "::" , stringify ! (unprocessed_data))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_context_t > ())) . unprocessed_len as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (cipher_context_t) , "::" , stringify ! (unprocessed_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_context_t > ())) . iv as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (cipher_context_t) , "::" , stringify ! (iv))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_context_t > ())) . iv_size as * const _ as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (cipher_context_t) , "::" , stringify ! (iv_size))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_context_t > ())) . cipher_ctx as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (cipher_context_t) , "::" , stringify ! (cipher_ctx))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_context_t > ())) . cmac_ctx as * const _ as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (cipher_context_t) , "::" , stringify ! (cmac_ctx))) ; } impl Default for cipher_context_t { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_cipher_list"] pub fn cipher_list () -> * const :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_info_from_string"] pub fn cipher_info_from_string (cipher_name : * const :: types :: raw_types :: c_char) -> * const cipher_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_info_from_type"] pub fn cipher_info_from_type (cipher_type : cipher_type_t) -> * const cipher_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_info_from_values"] pub fn cipher_info_from_values (cipher_id : cipher_id_t , key_bitlen : :: types :: raw_types :: c_int , mode : cipher_mode_t) -> * const cipher_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_init"] pub fn cipher_init (ctx : * mut cipher_context_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_free"] pub fn cipher_free (ctx : * mut cipher_context_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_setup"] pub fn cipher_setup (ctx : * mut cipher_context_t , cipher_info : * const cipher_info_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_setkey"] pub fn cipher_setkey (ctx : * mut cipher_context_t , key : * const :: types :: raw_types :: c_uchar , key_bitlen : :: types :: raw_types :: c_int , operation : operation_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_set_padding_mode"] pub fn cipher_set_padding_mode (ctx : * mut cipher_context_t , mode : cipher_padding_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_set_iv"] pub fn cipher_set_iv (ctx : * mut cipher_context_t , iv : * const :: types :: raw_types :: c_uchar , iv_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_reset"] pub fn cipher_reset (ctx : * mut cipher_context_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_update_ad"] pub fn cipher_update_ad (ctx : * mut cipher_context_t , ad : * const :: types :: raw_types :: c_uchar , ad_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_update"] pub fn cipher_update (ctx : * mut cipher_context_t , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , olen : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_finish"] pub fn cipher_finish (ctx : * mut cipher_context_t , output : * mut :: types :: raw_types :: c_uchar , olen : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_write_tag"] pub fn cipher_write_tag (ctx : * mut cipher_context_t , tag : * mut :: types :: raw_types :: c_uchar , tag_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_check_tag"] pub fn cipher_check_tag (ctx : * mut cipher_context_t , tag : * const :: types :: raw_types :: c_uchar , tag_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_crypt"] pub fn cipher_crypt (ctx : * mut cipher_context_t , iv : * const :: types :: raw_types :: c_uchar , iv_len : size_t , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , olen : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_auth_encrypt"] pub fn cipher_auth_encrypt (ctx : * mut cipher_context_t , iv : * const :: types :: raw_types :: c_uchar , iv_len : size_t , ad : * const :: types :: raw_types :: c_uchar , ad_len : size_t , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , olen : * mut size_t , tag : * mut :: types :: raw_types :: c_uchar , tag_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_auth_decrypt"] pub fn cipher_auth_decrypt (ctx : * mut cipher_context_t , iv : * const :: types :: raw_types :: c_uchar , iv_len : size_t , ad : * const :: types :: raw_types :: c_uchar , ad_len : size_t , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , olen : * mut size_t , tag : * const :: types :: raw_types :: c_uchar , tag_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_auth_encrypt_ext"] pub fn cipher_auth_encrypt_ext (ctx : * mut cipher_context_t , iv : * const :: types :: raw_types :: c_uchar , iv_len : size_t , ad : * const :: types :: raw_types :: c_uchar , ad_len : size_t , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , output_len : size_t , olen : * mut size_t , tag_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_auth_decrypt_ext"] pub fn cipher_auth_decrypt_ext (ctx : * mut cipher_context_t , iv : * const :: types :: raw_types :: c_uchar , iv_len : size_t , ad : * const :: types :: raw_types :: c_uchar , ad_len : size_t , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , output_len : size_t , olen : * mut size_t , tag_len : size_t) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct x509_crl_entry { pub raw : x509_buf , pub serial : x509_buf , pub revocation_date : x509_time , pub entry_ext : x509_buf , pub next : * mut x509_crl_entry , } # [test] fn bindgen_test_layout_x509_crl_entry () { assert_eq ! (:: core :: mem :: size_of :: < x509_crl_entry > () , 104usize , concat ! ("Size of: " , stringify ! (x509_crl_entry))) ; assert_eq ! (:: core :: mem :: align_of :: < x509_crl_entry > () , 8usize , concat ! ("Alignment of " , stringify ! (x509_crl_entry))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl_entry > ())) . raw as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_crl_entry) , "::" , stringify ! (raw))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl_entry > ())) . serial as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (x509_crl_entry) , "::" , stringify ! (serial))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl_entry > ())) . revocation_date as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (x509_crl_entry) , "::" , stringify ! (revocation_date))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl_entry > ())) . entry_ext as * const _ as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (x509_crl_entry) , "::" , stringify ! (entry_ext))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl_entry > ())) . next as * const _ as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (x509_crl_entry) , "::" , stringify ! (next))) ; } impl Default for x509_crl_entry { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct x509_crl { pub raw : x509_buf , pub tbs : x509_buf , pub version : :: types :: raw_types :: c_int , pub sig_oid : x509_buf , pub issuer_raw : x509_buf , pub issuer : x509_name , pub this_update : x509_time , pub next_update : x509_time , pub entry : x509_crl_entry , pub crl_ext : x509_buf , pub sig_oid2 : x509_buf , pub sig : x509_buf , pub sig_md : md_type_t , pub sig_pk : pk_type_t , pub sig_opts : * mut :: types :: raw_types :: c_void , pub next : * mut x509_crl , } # [test] fn bindgen_test_layout_x509_crl () { assert_eq ! (:: core :: mem :: size_of :: < x509_crl > () , 416usize , concat ! ("Size of: " , stringify ! (x509_crl))) ; assert_eq ! (:: core :: mem :: align_of :: < x509_crl > () , 8usize , concat ! ("Alignment of " , stringify ! (x509_crl))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . raw as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (raw))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . tbs as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (tbs))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . version as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (version))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . sig_oid as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (sig_oid))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . issuer_raw as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (issuer_raw))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . issuer as * const _ as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (issuer))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . this_update as * const _ as usize } , 168usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (this_update))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . next_update as * const _ as usize } , 192usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (next_update))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . entry as * const _ as usize } , 216usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (entry))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . crl_ext as * const _ as usize } , 320usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (crl_ext))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . sig_oid2 as * const _ as usize } , 344usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (sig_oid2))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . sig as * const _ as usize } , 368usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (sig))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . sig_md as * const _ as usize } , 392usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (sig_md))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . sig_pk as * const _ as usize } , 396usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (sig_pk))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . sig_opts as * const _ as usize } , 400usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (sig_opts))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crl > ())) . next as * const _ as usize } , 408usize , concat ! ("Offset of field: " , stringify ! (x509_crl) , "::" , stringify ! (next))) ; } impl Default for x509_crl { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_x509_crl_parse_der"] pub fn x509_crl_parse_der (chain : * mut x509_crl , buf : * const :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crl_parse"] pub fn x509_crl_parse (chain : * mut x509_crl , buf : * const :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crl_parse_file"] pub fn x509_crl_parse_file (chain : * mut x509_crl , path : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crl_info"] pub fn x509_crl_info (buf : * mut :: types :: raw_types :: c_char , size : size_t , prefix : * const :: types :: raw_types :: c_char , crl : * const x509_crl) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crl_init"] pub fn x509_crl_init (crl : * mut x509_crl) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crl_free"] pub fn x509_crl_free (crl : * mut x509_crl) ; } # [repr (C)] # [derive (Copy , Clone)] pub struct aes_context { pub nr : :: types :: raw_types :: c_int , pub rk : * mut u32 , pub buf : [u32 ; 68usize] , } # [test] fn bindgen_test_layout_aes_context () { assert_eq ! (:: core :: mem :: size_of :: < aes_context > () , 288usize , concat ! ("Size of: " , stringify ! (aes_context))) ; assert_eq ! (:: core :: mem :: align_of :: < aes_context > () , 8usize , concat ! ("Alignment of " , stringify ! (aes_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < aes_context > ())) . nr as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (aes_context) , "::" , stringify ! (nr))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < aes_context > ())) . rk as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (aes_context) , "::" , stringify ! (rk))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < aes_context > ())) . buf as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (aes_context) , "::" , stringify ! (buf))) ; } impl Default for aes_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct aes_xts_context { pub crypt : aes_context , pub tweak : aes_context , } # [test] fn bindgen_test_layout_aes_xts_context () { assert_eq ! (:: core :: mem :: size_of :: < aes_xts_context > () , 576usize , concat ! ("Size of: " , stringify ! (aes_xts_context))) ; assert_eq ! (:: core :: mem :: align_of :: < aes_xts_context > () , 8usize , concat ! ("Alignment of " , stringify ! (aes_xts_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < aes_xts_context > ())) . crypt as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (aes_xts_context) , "::" , stringify ! (crypt))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < aes_xts_context > ())) . tweak as * const _ as usize } , 288usize , concat ! ("Offset of field: " , stringify ! (aes_xts_context) , "::" , stringify ! (tweak))) ; } impl Default for aes_xts_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_aes_init"] pub fn aes_init (ctx : * mut aes_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_aes_free"] pub fn aes_free (ctx : * mut aes_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_aes_xts_init"] pub fn aes_xts_init (ctx : * mut aes_xts_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_aes_xts_free"] pub fn aes_xts_free (ctx : * mut aes_xts_context) ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_aes_setkey_enc"] pub fn aes_setkey_enc (ctx : * mut aes_context , key : * const :: types :: raw_types :: c_uchar , keybits : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_aes_setkey_dec"] pub fn aes_setkey_dec (ctx : * mut aes_context , key : * const :: types :: raw_types :: c_uchar , keybits : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_aes_xts_setkey_enc"] pub fn aes_xts_setkey_enc (ctx : * mut aes_xts_context , key : * const :: types :: raw_types :: c_uchar , keybits : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_aes_xts_setkey_dec"] pub fn aes_xts_setkey_dec (ctx : * mut aes_xts_context , key : * const :: types :: raw_types :: c_uchar , keybits : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_aes_crypt_ecb"] pub fn aes_crypt_ecb (ctx : * mut aes_context , mode : :: types :: raw_types :: c_int , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_aes_crypt_cbc"] pub fn aes_crypt_cbc (ctx : * mut aes_context , mode : :: types :: raw_types :: c_int , length : size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_aes_crypt_xts"] pub fn aes_crypt_xts (ctx : * mut aes_xts_context , mode : :: types :: raw_types :: c_int , length : size_t , data_unit : * const :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_aes_crypt_cfb128"] pub fn aes_crypt_cfb128 (ctx : * mut aes_context , mode : :: types :: raw_types :: c_int , length : size_t , iv_off : * mut size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_aes_crypt_cfb8"] pub fn aes_crypt_cfb8 (ctx : * mut aes_context , mode : :: types :: raw_types :: c_int , length : size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_aes_crypt_ofb"] pub fn aes_crypt_ofb (ctx : * mut aes_context , length : size_t , iv_off : * mut size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_aes_crypt_ctr"] pub fn aes_crypt_ctr (ctx : * mut aes_context , length : size_t , nc_off : * mut size_t , nonce_counter : * mut :: types :: raw_types :: c_uchar , stream_block : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_internal_aes_encrypt"] pub fn internal_aes_encrypt (ctx : * mut aes_context , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_internal_aes_decrypt"] pub fn internal_aes_decrypt (ctx : * mut aes_context , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_aes_encrypt"] pub fn aes_encrypt (ctx : * mut aes_context , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_aes_decrypt"] pub fn aes_decrypt (ctx : * mut aes_context , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_aes_self_test"] pub fn aes_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } pub const KEY_EXCHANGE_NONE : key_exchange_type_t = 0 ; pub const KEY_EXCHANGE_RSA : key_exchange_type_t = 1 ; pub const KEY_EXCHANGE_DHE_RSA : key_exchange_type_t = 2 ; pub const KEY_EXCHANGE_ECDHE_RSA : key_exchange_type_t = 3 ; pub const KEY_EXCHANGE_ECDHE_ECDSA : key_exchange_type_t = 4 ; pub const KEY_EXCHANGE_PSK : key_exchange_type_t = 5 ; pub const KEY_EXCHANGE_DHE_PSK : key_exchange_type_t = 6 ; pub const KEY_EXCHANGE_RSA_PSK : key_exchange_type_t = 7 ; pub const KEY_EXCHANGE_ECDHE_PSK : key_exchange_type_t = 8 ; pub const KEY_EXCHANGE_ECDH_RSA : key_exchange_type_t = 9 ; pub const KEY_EXCHANGE_ECDH_ECDSA : key_exchange_type_t = 10 ; pub const KEY_EXCHANGE_ECJPAKE : key_exchange_type_t = 11 ; pub type key_exchange_type_t = u32 ; # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_ciphersuite_t { pub id : :: types :: raw_types :: c_int , pub name : * const :: types :: raw_types :: c_char , pub cipher : cipher_type_t , pub mac : md_type_t , pub key_exchange : key_exchange_type_t , pub min_major_ver : :: types :: raw_types :: c_int , pub min_minor_ver : :: types :: raw_types :: c_int , pub max_major_ver : :: types :: raw_types :: c_int , pub max_minor_ver : :: types :: raw_types :: c_int , pub flags : :: types :: raw_types :: c_uchar , } # [test] fn bindgen_test_layout_ssl_ciphersuite_t () { assert_eq ! (:: core :: mem :: size_of :: < ssl_ciphersuite_t > () , 48usize , concat ! ("Size of: " , stringify ! (ssl_ciphersuite_t))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_ciphersuite_t > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_ciphersuite_t))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ciphersuite_t > ())) . id as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_ciphersuite_t) , "::" , stringify ! (id))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ciphersuite_t > ())) . name as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_ciphersuite_t) , "::" , stringify ! (name))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ciphersuite_t > ())) . cipher as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (ssl_ciphersuite_t) , "::" , stringify ! (cipher))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ciphersuite_t > ())) . mac as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (ssl_ciphersuite_t) , "::" , stringify ! (mac))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ciphersuite_t > ())) . key_exchange as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (ssl_ciphersuite_t) , "::" , stringify ! (key_exchange))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ciphersuite_t > ())) . min_major_ver as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (ssl_ciphersuite_t) , "::" , stringify ! (min_major_ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ciphersuite_t > ())) . min_minor_ver as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (ssl_ciphersuite_t) , "::" , stringify ! (min_minor_ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ciphersuite_t > ())) . max_major_ver as * const _ as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (ssl_ciphersuite_t) , "::" , stringify ! (max_major_ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ciphersuite_t > ())) . max_minor_ver as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (ssl_ciphersuite_t) , "::" , stringify ! (max_minor_ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ciphersuite_t > ())) . flags as * const _ as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (ssl_ciphersuite_t) , "::" , stringify ! (flags))) ; } impl Default for ssl_ciphersuite_t { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_ssl_list_ciphersuites"] pub fn ssl_list_ciphersuites () -> * const :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_ciphersuite_from_string"] pub fn ssl_ciphersuite_from_string (ciphersuite_name : * const :: types :: raw_types :: c_char) -> * const ssl_ciphersuite_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_ciphersuite_from_id"] pub fn ssl_ciphersuite_from_id (ciphersuite_id : :: types :: raw_types :: c_int) -> * const ssl_ciphersuite_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_ciphersuite_sig_pk_alg"] pub fn ssl_get_ciphersuite_sig_pk_alg (info : * const ssl_ciphersuite_t) -> pk_type_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_ciphersuite_sig_alg"] pub fn ssl_get_ciphersuite_sig_alg (info : * const ssl_ciphersuite_t) -> pk_type_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_ciphersuite_uses_ec"] pub fn ssl_ciphersuite_uses_ec (info : * const ssl_ciphersuite_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_ciphersuite_uses_psk"] pub fn ssl_ciphersuite_uses_psk (info : * const ssl_ciphersuite_t) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct x509_crt { pub own_buffer : :: types :: raw_types :: c_int , pub raw : x509_buf , pub tbs : x509_buf , pub version : :: types :: raw_types :: c_int , pub serial : x509_buf , pub sig_oid : x509_buf , pub issuer_raw : x509_buf , pub subject_raw : x509_buf , pub issuer : x509_name , pub subject : x509_name , pub valid_from : x509_time , pub valid_to : x509_time , pub pk_raw : x509_buf , pub pk : pk_context , pub issuer_id : x509_buf , pub subject_id : x509_buf , pub v3_ext : x509_buf , pub subject_alt_names : x509_sequence , pub certificate_policies : x509_sequence , pub ext_types : :: types :: raw_types :: c_int , pub ca_istrue : :: types :: raw_types :: c_int , pub max_pathlen : :: types :: raw_types :: c_int , pub key_usage : :: types :: raw_types :: c_uint , pub ext_key_usage : x509_sequence , pub ns_cert_type : :: types :: raw_types :: c_uchar , pub sig : x509_buf , pub sig_md : md_type_t , pub sig_pk : pk_type_t , pub sig_opts : * mut :: types :: raw_types :: c_void , pub next : * mut x509_crt , } # [test] fn bindgen_test_layout_x509_crt () { assert_eq ! (:: core :: mem :: size_of :: < x509_crt > () , 616usize , concat ! ("Size of: " , stringify ! (x509_crt))) ; assert_eq ! (:: core :: mem :: align_of :: < x509_crt > () , 8usize , concat ! ("Alignment of " , stringify ! (x509_crt))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . own_buffer as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (own_buffer))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . raw as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (raw))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . tbs as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (tbs))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . version as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (version))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . serial as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (serial))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . sig_oid as * const _ as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (sig_oid))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . issuer_raw as * const _ as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (issuer_raw))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . subject_raw as * const _ as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (subject_raw))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . issuer as * const _ as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (issuer))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . subject as * const _ as usize } , 224usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (subject))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . valid_from as * const _ as usize } , 288usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (valid_from))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . valid_to as * const _ as usize } , 312usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (valid_to))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . pk_raw as * const _ as usize } , 336usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (pk_raw))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . pk as * const _ as usize } , 360usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (pk))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . issuer_id as * const _ as usize } , 376usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (issuer_id))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . subject_id as * const _ as usize } , 400usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (subject_id))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . v3_ext as * const _ as usize } , 424usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (v3_ext))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . subject_alt_names as * const _ as usize } , 448usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (subject_alt_names))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . certificate_policies as * const _ as usize } , 480usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (certificate_policies))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . ext_types as * const _ as usize } , 512usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (ext_types))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . ca_istrue as * const _ as usize } , 516usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (ca_istrue))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . max_pathlen as * const _ as usize } , 520usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (max_pathlen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . key_usage as * const _ as usize } , 524usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (key_usage))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . ext_key_usage as * const _ as usize } , 528usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (ext_key_usage))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . ns_cert_type as * const _ as usize } , 560usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (ns_cert_type))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . sig as * const _ as usize } , 568usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (sig))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . sig_md as * const _ as usize } , 592usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (sig_md))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . sig_pk as * const _ as usize } , 596usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (sig_pk))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . sig_opts as * const _ as usize } , 600usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (sig_opts))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt > ())) . next as * const _ as usize } , 608usize , concat ! ("Offset of field: " , stringify ! (x509_crt) , "::" , stringify ! (next))) ; } impl Default for x509_crt { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct x509_san_other_name { pub type_id : x509_buf , pub value : x509_san_other_name__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union x509_san_other_name__bindgen_ty_1 { pub hardware_module_name : x509_san_other_name__bindgen_ty_1__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub struct x509_san_other_name__bindgen_ty_1__bindgen_ty_1 { pub oid : x509_buf , pub val : x509_buf , } # [test] fn bindgen_test_layout_x509_san_other_name__bindgen_ty_1__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < x509_san_other_name__bindgen_ty_1__bindgen_ty_1 > () , 48usize , concat ! ("Size of: " , stringify ! (x509_san_other_name__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < x509_san_other_name__bindgen_ty_1__bindgen_ty_1 > () , 8usize , concat ! ("Alignment of " , stringify ! (x509_san_other_name__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_san_other_name__bindgen_ty_1__bindgen_ty_1 > ())) . oid as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_san_other_name__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (oid))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_san_other_name__bindgen_ty_1__bindgen_ty_1 > ())) . val as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (x509_san_other_name__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (val))) ; } impl Default for x509_san_other_name__bindgen_ty_1__bindgen_ty_1 { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [test] fn bindgen_test_layout_x509_san_other_name__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < x509_san_other_name__bindgen_ty_1 > () , 48usize , concat ! ("Size of: " , stringify ! (x509_san_other_name__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < x509_san_other_name__bindgen_ty_1 > () , 8usize , concat ! ("Alignment of " , stringify ! (x509_san_other_name__bindgen_ty_1))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_san_other_name__bindgen_ty_1 > ())) . hardware_module_name as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_san_other_name__bindgen_ty_1) , "::" , stringify ! (hardware_module_name))) ; } impl Default for x509_san_other_name__bindgen_ty_1 { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [test] fn bindgen_test_layout_x509_san_other_name () { assert_eq ! (:: core :: mem :: size_of :: < x509_san_other_name > () , 72usize , concat ! ("Size of: " , stringify ! (x509_san_other_name))) ; assert_eq ! (:: core :: mem :: align_of :: < x509_san_other_name > () , 8usize , concat ! ("Alignment of " , stringify ! (x509_san_other_name))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_san_other_name > ())) . type_id as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_san_other_name) , "::" , stringify ! (type_id))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_san_other_name > ())) . value as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (x509_san_other_name) , "::" , stringify ! (value))) ; } impl Default for x509_san_other_name { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct x509_subject_alternative_name { pub type_ : :: types :: raw_types :: c_int , pub san : x509_subject_alternative_name__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union x509_subject_alternative_name__bindgen_ty_1 { pub other_name : x509_san_other_name , pub unstructured_name : x509_buf , } # [test] fn bindgen_test_layout_x509_subject_alternative_name__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < x509_subject_alternative_name__bindgen_ty_1 > () , 72usize , concat ! ("Size of: " , stringify ! (x509_subject_alternative_name__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < x509_subject_alternative_name__bindgen_ty_1 > () , 8usize , concat ! ("Alignment of " , stringify ! (x509_subject_alternative_name__bindgen_ty_1))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_subject_alternative_name__bindgen_ty_1 > ())) . other_name as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_subject_alternative_name__bindgen_ty_1) , "::" , stringify ! (other_name))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_subject_alternative_name__bindgen_ty_1 > ())) . unstructured_name as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_subject_alternative_name__bindgen_ty_1) , "::" , stringify ! (unstructured_name))) ; } impl Default for x509_subject_alternative_name__bindgen_ty_1 { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [test] fn bindgen_test_layout_x509_subject_alternative_name () { assert_eq ! (:: core :: mem :: size_of :: < x509_subject_alternative_name > () , 80usize , concat ! ("Size of: " , stringify ! (x509_subject_alternative_name))) ; assert_eq ! (:: core :: mem :: align_of :: < x509_subject_alternative_name > () , 8usize , concat ! ("Alignment of " , stringify ! (x509_subject_alternative_name))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_subject_alternative_name > ())) . type_ as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_subject_alternative_name) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_subject_alternative_name > ())) . san as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (x509_subject_alternative_name) , "::" , stringify ! (san))) ; } impl Default for x509_subject_alternative_name { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct x509_crt_profile { pub allowed_mds : u32 , pub allowed_pks : u32 , pub allowed_curves : u32 , pub rsa_min_bitlen : u32 , } # [test] fn bindgen_test_layout_x509_crt_profile () { assert_eq ! (:: core :: mem :: size_of :: < x509_crt_profile > () , 16usize , concat ! ("Size of: " , stringify ! (x509_crt_profile))) ; assert_eq ! (:: core :: mem :: align_of :: < x509_crt_profile > () , 4usize , concat ! ("Alignment of " , stringify ! (x509_crt_profile))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt_profile > ())) . allowed_mds as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_crt_profile) , "::" , stringify ! (allowed_mds))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt_profile > ())) . allowed_pks as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (x509_crt_profile) , "::" , stringify ! (allowed_pks))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt_profile > ())) . allowed_curves as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (x509_crt_profile) , "::" , stringify ! (allowed_curves))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt_profile > ())) . rsa_min_bitlen as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (x509_crt_profile) , "::" , stringify ! (rsa_min_bitlen))) ; } impl Default for x509_crt_profile { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct x509write_cert { pub version : :: types :: raw_types :: c_int , pub serial : mpi , pub subject_key : * mut pk_context , pub issuer_key : * mut pk_context , pub subject : * mut asn1_named_data , pub issuer : * mut asn1_named_data , pub md_alg : md_type_t , pub not_before : [:: types :: raw_types :: c_char ; 16usize] , pub not_after : [:: types :: raw_types :: c_char ; 16usize] , pub extensions : * mut asn1_named_data , } # [test] fn bindgen_test_layout_x509write_cert () { assert_eq ! (:: core :: mem :: size_of :: < x509write_cert > () , 112usize , concat ! ("Size of: " , stringify ! (x509write_cert))) ; assert_eq ! (:: core :: mem :: align_of :: < x509write_cert > () , 8usize , concat ! ("Alignment of " , stringify ! (x509write_cert))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_cert > ())) . version as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509write_cert) , "::" , stringify ! (version))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_cert > ())) . serial as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (x509write_cert) , "::" , stringify ! (serial))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_cert > ())) . subject_key as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (x509write_cert) , "::" , stringify ! (subject_key))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_cert > ())) . issuer_key as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (x509write_cert) , "::" , stringify ! (issuer_key))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_cert > ())) . subject as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (x509write_cert) , "::" , stringify ! (subject))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_cert > ())) . issuer as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (x509write_cert) , "::" , stringify ! (issuer))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_cert > ())) . md_alg as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (x509write_cert) , "::" , stringify ! (md_alg))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_cert > ())) . not_before as * const _ as usize } , 68usize , concat ! ("Offset of field: " , stringify ! (x509write_cert) , "::" , stringify ! (not_before))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_cert > ())) . not_after as * const _ as usize } , 84usize , concat ! ("Offset of field: " , stringify ! (x509write_cert) , "::" , stringify ! (not_after))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_cert > ())) . extensions as * const _ as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (x509write_cert) , "::" , stringify ! (extensions))) ; } impl Default for x509write_cert { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct x509_crt_verify_chain_item { pub crt : * mut x509_crt , pub flags : u32 , } # [test] fn bindgen_test_layout_x509_crt_verify_chain_item () { assert_eq ! (:: core :: mem :: size_of :: < x509_crt_verify_chain_item > () , 16usize , concat ! ("Size of: " , stringify ! (x509_crt_verify_chain_item))) ; assert_eq ! (:: core :: mem :: align_of :: < x509_crt_verify_chain_item > () , 8usize , concat ! ("Alignment of " , stringify ! (x509_crt_verify_chain_item))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt_verify_chain_item > ())) . crt as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_crt_verify_chain_item) , "::" , stringify ! (crt))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt_verify_chain_item > ())) . flags as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (x509_crt_verify_chain_item) , "::" , stringify ! (flags))) ; } impl Default for x509_crt_verify_chain_item { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct x509_crt_verify_chain { pub items : [x509_crt_verify_chain_item ; 10usize] , pub len : :: types :: raw_types :: c_uint , pub trust_ca_cb_result : * mut x509_crt , } # [test] fn bindgen_test_layout_x509_crt_verify_chain () { assert_eq ! (:: core :: mem :: size_of :: < x509_crt_verify_chain > () , 176usize , concat ! ("Size of: " , stringify ! (x509_crt_verify_chain))) ; assert_eq ! (:: core :: mem :: align_of :: < x509_crt_verify_chain > () , 8usize , concat ! ("Alignment of " , stringify ! (x509_crt_verify_chain))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt_verify_chain > ())) . items as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_crt_verify_chain) , "::" , stringify ! (items))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt_verify_chain > ())) . len as * const _ as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (x509_crt_verify_chain) , "::" , stringify ! (len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_crt_verify_chain > ())) . trust_ca_cb_result as * const _ as usize } , 168usize , concat ! ("Offset of field: " , stringify ! (x509_crt_verify_chain) , "::" , stringify ! (trust_ca_cb_result))) ; } impl Default for x509_crt_verify_chain { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } pub type x509_crt_restart_ctx = :: types :: raw_types :: c_void ; extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_profile_default"] pub static x509_crt_profile_default : x509_crt_profile ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_profile_next"] pub static x509_crt_profile_next : x509_crt_profile ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_profile_suiteb"] pub static x509_crt_profile_suiteb : x509_crt_profile ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_parse_der"] pub fn x509_crt_parse_der (chain : * mut x509_crt , buf : * const :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } pub type x509_crt_ext_cb_t = :: core :: option :: Option < unsafe extern "C" fn (p_ctx : * mut :: types :: raw_types :: c_void , crt : * const x509_crt , oid : * const x509_buf , critical : :: types :: raw_types :: c_int , p : * const :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int > ; extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_parse_der_with_ext_cb"] pub fn x509_crt_parse_der_with_ext_cb (chain : * mut x509_crt , buf : * const :: types :: raw_types :: c_uchar , buflen : size_t , make_copy : :: types :: raw_types :: c_int , cb : x509_crt_ext_cb_t , p_ctx : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_parse_der_nocopy"] pub fn x509_crt_parse_der_nocopy (chain : * mut x509_crt , buf : * const :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_parse"] pub fn x509_crt_parse (chain : * mut x509_crt , buf : * const :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_parse_file"] pub fn x509_crt_parse_file (chain : * mut x509_crt , path : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_parse_path"] pub fn x509_crt_parse_path (chain : * mut x509_crt , path : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_parse_subject_alt_name"] pub fn x509_parse_subject_alt_name (san_buf : * const x509_buf , san : * mut x509_subject_alternative_name) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_info"] pub fn x509_crt_info (buf : * mut :: types :: raw_types :: c_char , size : size_t , prefix : * const :: types :: raw_types :: c_char , crt : * const x509_crt) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_verify_info"] pub fn x509_crt_verify_info (buf : * mut :: types :: raw_types :: c_char , size : size_t , prefix : * const :: types :: raw_types :: c_char , flags : u32) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_verify"] pub fn x509_crt_verify (crt : * mut x509_crt , trust_ca : * mut x509_crt , ca_crl : * mut x509_crl , cn : * const :: types :: raw_types :: c_char , flags : * mut u32 , f_vrfy : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut x509_crt , arg3 : :: types :: raw_types :: c_int , arg4 : * mut u32) -> :: types :: raw_types :: c_int > , p_vrfy : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_verify_with_profile"] pub fn x509_crt_verify_with_profile (crt : * mut x509_crt , trust_ca : * mut x509_crt , ca_crl : * mut x509_crl , profile : * const x509_crt_profile , cn : * const :: types :: raw_types :: c_char , flags : * mut u32 , f_vrfy : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut x509_crt , arg3 : :: types :: raw_types :: c_int , arg4 : * mut u32) -> :: types :: raw_types :: c_int > , p_vrfy : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_verify_restartable"] pub fn x509_crt_verify_restartable (crt : * mut x509_crt , trust_ca : * mut x509_crt , ca_crl : * mut x509_crl , profile : * const x509_crt_profile , cn : * const :: types :: raw_types :: c_char , flags : * mut u32 , f_vrfy : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut x509_crt , arg3 : :: types :: raw_types :: c_int , arg4 : * mut u32) -> :: types :: raw_types :: c_int > , p_vrfy : * mut :: types :: raw_types :: c_void , rs_ctx : * mut x509_crt_restart_ctx) -> :: types :: raw_types :: c_int ; } pub type x509_crt_ca_cb_t = :: core :: option :: Option < unsafe extern "C" fn (p_ctx : * mut :: types :: raw_types :: c_void , child : * const x509_crt , candidate_cas : * mut * mut x509_crt) -> :: types :: raw_types :: c_int > ; extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_verify_with_ca_cb"] pub fn x509_crt_verify_with_ca_cb (crt : * mut x509_crt , f_ca_cb : x509_crt_ca_cb_t , p_ca_cb : * mut :: types :: raw_types :: c_void , profile : * const x509_crt_profile , cn : * const :: types :: raw_types :: c_char , flags : * mut u32 , f_vrfy : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut x509_crt , arg3 : :: types :: raw_types :: c_int , arg4 : * mut u32) -> :: types :: raw_types :: c_int > , p_vrfy : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_check_key_usage"] pub fn x509_crt_check_key_usage (crt : * const x509_crt , usage : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_check_extended_key_usage"] pub fn x509_crt_check_extended_key_usage (crt : * const x509_crt , usage_oid : * const :: types :: raw_types :: c_char , usage_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_is_revoked"] pub fn x509_crt_is_revoked (crt : * const x509_crt , crl : * const x509_crl) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_init"] pub fn x509_crt_init (crt : * mut x509_crt) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_crt_free"] pub fn x509_crt_free (crt : * mut x509_crt) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_init"] pub fn x509write_crt_init (ctx : * mut x509write_cert) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_version"] pub fn x509write_crt_set_version (ctx : * mut x509write_cert , version : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_serial"] pub fn x509write_crt_set_serial (ctx : * mut x509write_cert , serial : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_validity"] pub fn x509write_crt_set_validity (ctx : * mut x509write_cert , not_before : * const :: types :: raw_types :: c_char , not_after : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_issuer_name"] pub fn x509write_crt_set_issuer_name (ctx : * mut x509write_cert , issuer_name : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_subject_name"] pub fn x509write_crt_set_subject_name (ctx : * mut x509write_cert , subject_name : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_subject_key"] pub fn x509write_crt_set_subject_key (ctx : * mut x509write_cert , key : * mut pk_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_issuer_key"] pub fn x509write_crt_set_issuer_key (ctx : * mut x509write_cert , key : * mut pk_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_md_alg"] pub fn x509write_crt_set_md_alg (ctx : * mut x509write_cert , md_alg : md_type_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_extension"] pub fn x509write_crt_set_extension (ctx : * mut x509write_cert , oid : * const :: types :: raw_types :: c_char , oid_len : size_t , critical : :: types :: raw_types :: c_int , val : * const :: types :: raw_types :: c_uchar , val_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_basic_constraints"] pub fn x509write_crt_set_basic_constraints (ctx : * mut x509write_cert , is_ca : :: types :: raw_types :: c_int , max_pathlen : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_subject_key_identifier"] pub fn x509write_crt_set_subject_key_identifier (ctx : * mut x509write_cert) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_authority_key_identifier"] pub fn x509write_crt_set_authority_key_identifier (ctx : * mut x509write_cert) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_key_usage"] pub fn x509write_crt_set_key_usage (ctx : * mut x509write_cert , key_usage : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_set_ns_cert_type"] pub fn x509write_crt_set_ns_cert_type (ctx : * mut x509write_cert , ns_cert_type : :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_free"] pub fn x509write_crt_free (ctx : * mut x509write_cert) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_der"] pub fn x509write_crt_der (ctx : * mut x509write_cert , buf : * mut :: types :: raw_types :: c_uchar , size : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_crt_pem"] pub fn x509write_crt_pem (ctx : * mut x509write_cert , buf : * mut :: types :: raw_types :: c_uchar , size : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct dhm_context { pub len : size_t , pub P : mpi , pub G : mpi , pub X : mpi , pub GX : mpi , pub GY : mpi , pub K : mpi , pub RP : mpi , pub Vi : mpi , pub Vf : mpi , pub pX : mpi , } # [test] fn bindgen_test_layout_dhm_context () { assert_eq ! (:: core :: mem :: size_of :: < dhm_context > () , 248usize , concat ! ("Size of: " , stringify ! (dhm_context))) ; assert_eq ! (:: core :: mem :: align_of :: < dhm_context > () , 8usize , concat ! ("Alignment of " , stringify ! (dhm_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < dhm_context > ())) . len as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (dhm_context) , "::" , stringify ! (len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < dhm_context > ())) . P as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (dhm_context) , "::" , stringify ! (P))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < dhm_context > ())) . G as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (dhm_context) , "::" , stringify ! (G))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < dhm_context > ())) . X as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (dhm_context) , "::" , stringify ! (X))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < dhm_context > ())) . GX as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (dhm_context) , "::" , stringify ! (GX))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < dhm_context > ())) . GY as * const _ as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (dhm_context) , "::" , stringify ! (GY))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < dhm_context > ())) . K as * const _ as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (dhm_context) , "::" , stringify ! (K))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < dhm_context > ())) . RP as * const _ as usize } , 152usize , concat ! ("Offset of field: " , stringify ! (dhm_context) , "::" , stringify ! (RP))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < dhm_context > ())) . Vi as * const _ as usize } , 176usize , concat ! ("Offset of field: " , stringify ! (dhm_context) , "::" , stringify ! (Vi))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < dhm_context > ())) . Vf as * const _ as usize } , 200usize , concat ! ("Offset of field: " , stringify ! (dhm_context) , "::" , stringify ! (Vf))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < dhm_context > ())) . pX as * const _ as usize } , 224usize , concat ! ("Offset of field: " , stringify ! (dhm_context) , "::" , stringify ! (pX))) ; } impl Default for dhm_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_dhm_init"] pub fn dhm_init (ctx : * mut dhm_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_dhm_read_params"] pub fn dhm_read_params (ctx : * mut dhm_context , p : * mut * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_dhm_make_params"] pub fn dhm_make_params (ctx : * mut dhm_context , x_size : :: types :: raw_types :: c_int , output : * mut :: types :: raw_types :: c_uchar , olen : * mut size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_dhm_set_group"] pub fn dhm_set_group (ctx : * mut dhm_context , P : * const mpi , G : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_dhm_read_public"] pub fn dhm_read_public (ctx : * mut dhm_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_dhm_make_public"] pub fn dhm_make_public (ctx : * mut dhm_context , x_size : :: types :: raw_types :: c_int , output : * mut :: types :: raw_types :: c_uchar , olen : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_dhm_calc_secret"] pub fn dhm_calc_secret (ctx : * mut dhm_context , output : * mut :: types :: raw_types :: c_uchar , output_size : size_t , olen : * mut size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_dhm_free"] pub fn dhm_free (ctx : * mut dhm_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_dhm_parse_dhm"] pub fn dhm_parse_dhm (dhm : * mut dhm_context , dhmin : * const :: types :: raw_types :: c_uchar , dhminlen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_dhm_parse_dhmfile"] pub fn dhm_parse_dhmfile (dhm : * mut dhm_context , path : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_dhm_self_test"] pub fn dhm_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } pub const ECDH_OURS : ecdh_side = 0 ; pub const ECDH_THEIRS : ecdh_side = 1 ; pub type ecdh_side = u32 ; # [repr (C)] # [derive (Copy , Clone)] pub struct ecdh_context { pub grp : ecp_group , pub d : mpi , pub Q : ecp_point , pub Qp : ecp_point , pub z : mpi , pub point_format : :: types :: raw_types :: c_int , pub Vi : ecp_point , pub Vf : ecp_point , pub _d : mpi , } # [test] fn bindgen_test_layout_ecdh_context () { assert_eq ! (:: core :: mem :: size_of :: < ecdh_context > () , 616usize , concat ! ("Size of: " , stringify ! (ecdh_context))) ; assert_eq ! (:: core :: mem :: align_of :: < ecdh_context > () , 8usize , concat ! ("Alignment of " , stringify ! (ecdh_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecdh_context > ())) . grp as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ecdh_context) , "::" , stringify ! (grp))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecdh_context > ())) . d as * const _ as usize } , 248usize , concat ! ("Offset of field: " , stringify ! (ecdh_context) , "::" , stringify ! (d))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecdh_context > ())) . Q as * const _ as usize } , 272usize , concat ! ("Offset of field: " , stringify ! (ecdh_context) , "::" , stringify ! (Q))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecdh_context > ())) . Qp as * const _ as usize } , 344usize , concat ! ("Offset of field: " , stringify ! (ecdh_context) , "::" , stringify ! (Qp))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecdh_context > ())) . z as * const _ as usize } , 416usize , concat ! ("Offset of field: " , stringify ! (ecdh_context) , "::" , stringify ! (z))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecdh_context > ())) . point_format as * const _ as usize } , 440usize , concat ! ("Offset of field: " , stringify ! (ecdh_context) , "::" , stringify ! (point_format))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecdh_context > ())) . Vi as * const _ as usize } , 448usize , concat ! ("Offset of field: " , stringify ! (ecdh_context) , "::" , stringify ! (Vi))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecdh_context > ())) . Vf as * const _ as usize } , 520usize , concat ! ("Offset of field: " , stringify ! (ecdh_context) , "::" , stringify ! (Vf))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecdh_context > ())) . _d as * const _ as usize } , 592usize , concat ! ("Offset of field: " , stringify ! (ecdh_context) , "::" , stringify ! (_d))) ; } impl Default for ecdh_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_ecdh_can_do"] pub fn ecdh_can_do (gid : ecp_group_id) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdh_gen_public"] pub fn ecdh_gen_public (grp : * mut ecp_group , d : * mut mpi , Q : * mut ecp_point , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdh_compute_shared"] pub fn ecdh_compute_shared (grp : * mut ecp_group , z : * mut mpi , Q : * const ecp_point , d : * const mpi , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdh_init"] pub fn ecdh_init (ctx : * mut ecdh_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdh_setup"] pub fn ecdh_setup (ctx : * mut ecdh_context , grp_id : ecp_group_id) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdh_free"] pub fn ecdh_free (ctx : * mut ecdh_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdh_make_params"] pub fn ecdh_make_params (ctx : * mut ecdh_context , olen : * mut size_t , buf : * mut :: types :: raw_types :: c_uchar , blen : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdh_read_params"] pub fn ecdh_read_params (ctx : * mut ecdh_context , buf : * mut * const :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdh_get_params"] pub fn ecdh_get_params (ctx : * mut ecdh_context , key : * const ecp_keypair , side : ecdh_side) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdh_make_public"] pub fn ecdh_make_public (ctx : * mut ecdh_context , olen : * mut size_t , buf : * mut :: types :: raw_types :: c_uchar , blen : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdh_read_public"] pub fn ecdh_read_public (ctx : * mut ecdh_context , buf : * const :: types :: raw_types :: c_uchar , blen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdh_calc_secret"] pub fn ecdh_calc_secret (ctx : * mut ecdh_context , olen : * mut size_t , buf : * mut :: types :: raw_types :: c_uchar , blen : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct oid_descriptor_t { pub asn1 : * const :: types :: raw_types :: c_char , pub asn1_len : size_t , pub name : * const :: types :: raw_types :: c_char , pub description : * const :: types :: raw_types :: c_char , } # [test] fn bindgen_test_layout_oid_descriptor_t () { assert_eq ! (:: core :: mem :: size_of :: < oid_descriptor_t > () , 32usize , concat ! ("Size of: " , stringify ! (oid_descriptor_t))) ; assert_eq ! (:: core :: mem :: align_of :: < oid_descriptor_t > () , 8usize , concat ! ("Alignment of " , stringify ! (oid_descriptor_t))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < oid_descriptor_t > ())) . asn1 as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (oid_descriptor_t) , "::" , stringify ! (asn1))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < oid_descriptor_t > ())) . asn1_len as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (oid_descriptor_t) , "::" , stringify ! (asn1_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < oid_descriptor_t > ())) . name as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (oid_descriptor_t) , "::" , stringify ! (name))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < oid_descriptor_t > ())) . description as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (oid_descriptor_t) , "::" , stringify ! (description))) ; } impl Default for oid_descriptor_t { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_numeric_string"] pub fn oid_get_numeric_string (buf : * mut :: types :: raw_types :: c_char , size : size_t , oid : * const asn1_buf) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_x509_ext_type"] pub fn oid_get_x509_ext_type (oid : * const asn1_buf , ext_type : * mut :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_attr_short_name"] pub fn oid_get_attr_short_name (oid : * const asn1_buf , short_name : * mut * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_pk_alg"] pub fn oid_get_pk_alg (oid : * const asn1_buf , pk_alg : * mut pk_type_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_oid_by_pk_alg"] pub fn oid_get_oid_by_pk_alg (pk_alg : pk_type_t , oid : * mut * const :: types :: raw_types :: c_char , olen : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_ec_grp"] pub fn oid_get_ec_grp (oid : * const asn1_buf , grp_id : * mut ecp_group_id) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_oid_by_ec_grp"] pub fn oid_get_oid_by_ec_grp (grp_id : ecp_group_id , oid : * mut * const :: types :: raw_types :: c_char , olen : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_sig_alg"] pub fn oid_get_sig_alg (oid : * const asn1_buf , md_alg : * mut md_type_t , pk_alg : * mut pk_type_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_sig_alg_desc"] pub fn oid_get_sig_alg_desc (oid : * const asn1_buf , desc : * mut * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_oid_by_sig_alg"] pub fn oid_get_oid_by_sig_alg (pk_alg : pk_type_t , md_alg : md_type_t , oid : * mut * const :: types :: raw_types :: c_char , olen : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_md_alg"] pub fn oid_get_md_alg (oid : * const asn1_buf , md_alg : * mut md_type_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_md_hmac"] pub fn oid_get_md_hmac (oid : * const asn1_buf , md_hmac : * mut md_type_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_extended_key_usage"] pub fn oid_get_extended_key_usage (oid : * const asn1_buf , desc : * mut * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_certificate_policies"] pub fn oid_get_certificate_policies (oid : * const asn1_buf , desc : * mut * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_oid_by_md"] pub fn oid_get_oid_by_md (md_alg : md_type_t , oid : * mut * const :: types :: raw_types :: c_char , olen : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_cipher_alg"] pub fn oid_get_cipher_alg (oid : * const asn1_buf , cipher_alg : * mut cipher_type_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_oid_get_pkcs12_pbe_alg"] pub fn oid_get_pkcs12_pbe_alg (oid : * const asn1_buf , md_alg : * mut md_type_t , cipher_alg : * mut cipher_type_t) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ctr_drbg_context { pub counter : [:: types :: raw_types :: c_uchar ; 16usize] , pub reseed_counter : :: types :: raw_types :: c_int , pub prediction_resistance : :: types :: raw_types :: c_int , pub entropy_len : size_t , pub reseed_interval : :: types :: raw_types :: c_int , pub aes_ctx : aes_context , pub f_entropy : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , pub p_entropy : * mut :: types :: raw_types :: c_void , pub mutex : threading_mutex_t , } # [test] fn bindgen_test_layout_ctr_drbg_context () { assert_eq ! (:: core :: mem :: size_of :: < ctr_drbg_context > () , 392usize , concat ! ("Size of: " , stringify ! (ctr_drbg_context))) ; assert_eq ! (:: core :: mem :: align_of :: < ctr_drbg_context > () , 8usize , concat ! ("Alignment of " , stringify ! (ctr_drbg_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ctr_drbg_context > ())) . counter as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ctr_drbg_context) , "::" , stringify ! (counter))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ctr_drbg_context > ())) . reseed_counter as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (ctr_drbg_context) , "::" , stringify ! (reseed_counter))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ctr_drbg_context > ())) . prediction_resistance as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (ctr_drbg_context) , "::" , stringify ! (prediction_resistance))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ctr_drbg_context > ())) . entropy_len as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (ctr_drbg_context) , "::" , stringify ! (entropy_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ctr_drbg_context > ())) . reseed_interval as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (ctr_drbg_context) , "::" , stringify ! (reseed_interval))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ctr_drbg_context > ())) . aes_ctx as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (ctr_drbg_context) , "::" , stringify ! (aes_ctx))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ctr_drbg_context > ())) . f_entropy as * const _ as usize } , 328usize , concat ! ("Offset of field: " , stringify ! (ctr_drbg_context) , "::" , stringify ! (f_entropy))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ctr_drbg_context > ())) . p_entropy as * const _ as usize } , 336usize , concat ! ("Offset of field: " , stringify ! (ctr_drbg_context) , "::" , stringify ! (p_entropy))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ctr_drbg_context > ())) . mutex as * const _ as usize } , 344usize , concat ! ("Offset of field: " , stringify ! (ctr_drbg_context) , "::" , stringify ! (mutex))) ; } impl Default for ctr_drbg_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_init"] pub fn ctr_drbg_init (ctx : * mut ctr_drbg_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_seed"] pub fn ctr_drbg_seed (ctx : * mut ctr_drbg_context , f_entropy : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_entropy : * mut :: types :: raw_types :: c_void , custom : * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_free"] pub fn ctr_drbg_free (ctx : * mut ctr_drbg_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_set_prediction_resistance"] pub fn ctr_drbg_set_prediction_resistance (ctx : * mut ctr_drbg_context , resistance : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_set_entropy_len"] pub fn ctr_drbg_set_entropy_len (ctx : * mut ctr_drbg_context , len : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_set_nonce_len"] pub fn ctr_drbg_set_nonce_len (ctx : * mut ctr_drbg_context , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_set_reseed_interval"] pub fn ctr_drbg_set_reseed_interval (ctx : * mut ctr_drbg_context , interval : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_reseed"] pub fn ctr_drbg_reseed (ctx : * mut ctr_drbg_context , additional : * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_update_ret"] pub fn ctr_drbg_update_ret (ctx : * mut ctr_drbg_context , additional : * const :: types :: raw_types :: c_uchar , add_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_random_with_add"] pub fn ctr_drbg_random_with_add (p_rng : * mut :: types :: raw_types :: c_void , output : * mut :: types :: raw_types :: c_uchar , output_len : size_t , additional : * const :: types :: raw_types :: c_uchar , add_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_random"] pub fn ctr_drbg_random (p_rng : * mut :: types :: raw_types :: c_void , output : * mut :: types :: raw_types :: c_uchar , output_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_update"] pub fn ctr_drbg_update (ctx : * mut ctr_drbg_context , additional : * const :: types :: raw_types :: c_uchar , add_len : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_write_seed_file"] pub fn ctr_drbg_write_seed_file (ctx : * mut ctr_drbg_context , path : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_update_seed_file"] pub fn ctr_drbg_update_seed_file (ctx : * mut ctr_drbg_context , path : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ctr_drbg_self_test"] pub fn ctr_drbg_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct hmac_drbg_context { pub md_ctx : md_context_t , pub V : [:: types :: raw_types :: c_uchar ; 64usize] , pub reseed_counter : :: types :: raw_types :: c_int , pub entropy_len : size_t , pub prediction_resistance : :: types :: raw_types :: c_int , pub reseed_interval : :: types :: raw_types :: c_int , pub f_entropy : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , pub p_entropy : * mut :: types :: raw_types :: c_void , pub mutex : threading_mutex_t , } # [test] fn bindgen_test_layout_hmac_drbg_context () { assert_eq ! (:: core :: mem :: size_of :: < hmac_drbg_context > () , 176usize , concat ! ("Size of: " , stringify ! (hmac_drbg_context))) ; assert_eq ! (:: core :: mem :: align_of :: < hmac_drbg_context > () , 8usize , concat ! ("Alignment of " , stringify ! (hmac_drbg_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < hmac_drbg_context > ())) . md_ctx as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (hmac_drbg_context) , "::" , stringify ! (md_ctx))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < hmac_drbg_context > ())) . V as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (hmac_drbg_context) , "::" , stringify ! (V))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < hmac_drbg_context > ())) . reseed_counter as * const _ as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (hmac_drbg_context) , "::" , stringify ! (reseed_counter))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < hmac_drbg_context > ())) . entropy_len as * const _ as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (hmac_drbg_context) , "::" , stringify ! (entropy_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < hmac_drbg_context > ())) . prediction_resistance as * const _ as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (hmac_drbg_context) , "::" , stringify ! (prediction_resistance))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < hmac_drbg_context > ())) . reseed_interval as * const _ as usize } , 108usize , concat ! ("Offset of field: " , stringify ! (hmac_drbg_context) , "::" , stringify ! (reseed_interval))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < hmac_drbg_context > ())) . f_entropy as * const _ as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (hmac_drbg_context) , "::" , stringify ! (f_entropy))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < hmac_drbg_context > ())) . p_entropy as * const _ as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (hmac_drbg_context) , "::" , stringify ! (p_entropy))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < hmac_drbg_context > ())) . mutex as * const _ as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (hmac_drbg_context) , "::" , stringify ! (mutex))) ; } impl Default for hmac_drbg_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_init"] pub fn hmac_drbg_init (ctx : * mut hmac_drbg_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_seed"] pub fn hmac_drbg_seed (ctx : * mut hmac_drbg_context , md_info : * const md_info_t , f_entropy : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_entropy : * mut :: types :: raw_types :: c_void , custom : * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_seed_buf"] pub fn hmac_drbg_seed_buf (ctx : * mut hmac_drbg_context , md_info : * const md_info_t , data : * const :: types :: raw_types :: c_uchar , data_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_set_prediction_resistance"] pub fn hmac_drbg_set_prediction_resistance (ctx : * mut hmac_drbg_context , resistance : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_set_entropy_len"] pub fn hmac_drbg_set_entropy_len (ctx : * mut hmac_drbg_context , len : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_set_reseed_interval"] pub fn hmac_drbg_set_reseed_interval (ctx : * mut hmac_drbg_context , interval : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_update_ret"] pub fn hmac_drbg_update_ret (ctx : * mut hmac_drbg_context , additional : * const :: types :: raw_types :: c_uchar , add_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_reseed"] pub fn hmac_drbg_reseed (ctx : * mut hmac_drbg_context , additional : * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_random_with_add"] pub fn hmac_drbg_random_with_add (p_rng : * mut :: types :: raw_types :: c_void , output : * mut :: types :: raw_types :: c_uchar , output_len : size_t , additional : * const :: types :: raw_types :: c_uchar , add_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_random"] pub fn hmac_drbg_random (p_rng : * mut :: types :: raw_types :: c_void , output : * mut :: types :: raw_types :: c_uchar , out_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_free"] pub fn hmac_drbg_free (ctx : * mut hmac_drbg_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_update"] pub fn hmac_drbg_update (ctx : * mut hmac_drbg_context , additional : * const :: types :: raw_types :: c_uchar , add_len : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_write_seed_file"] pub fn hmac_drbg_write_seed_file (ctx : * mut hmac_drbg_context , path : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_update_seed_file"] pub fn hmac_drbg_update_seed_file (ctx : * mut hmac_drbg_context , path : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_hmac_drbg_self_test"] pub fn hmac_drbg_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub union ssl_premaster_secret { pub _pms_rsa : [:: types :: raw_types :: c_uchar ; 48usize] , pub _pms_dhm : [:: types :: raw_types :: c_uchar ; 1024usize] , pub _pms_ecdh : [:: types :: raw_types :: c_uchar ; 66usize] , pub _pms_psk : [:: types :: raw_types :: c_uchar ; 68usize] , pub _pms_dhe_psk : [:: types :: raw_types :: c_uchar ; 1060usize] , pub _pms_rsa_psk : [:: types :: raw_types :: c_uchar ; 84usize] , pub _pms_ecdhe_psk : [:: types :: raw_types :: c_uchar ; 102usize] , } # [test] fn bindgen_test_layout_ssl_premaster_secret () { assert_eq ! (:: core :: mem :: size_of :: < ssl_premaster_secret > () , 1060usize , concat ! ("Size of: " , stringify ! (ssl_premaster_secret))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_premaster_secret > () , 1usize , concat ! ("Alignment of " , stringify ! (ssl_premaster_secret))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_premaster_secret > ())) . _pms_rsa as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_premaster_secret) , "::" , stringify ! (_pms_rsa))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_premaster_secret > ())) . _pms_dhm as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_premaster_secret) , "::" , stringify ! (_pms_dhm))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_premaster_secret > ())) . _pms_ecdh as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_premaster_secret) , "::" , stringify ! (_pms_ecdh))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_premaster_secret > ())) . _pms_psk as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_premaster_secret) , "::" , stringify ! (_pms_psk))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_premaster_secret > ())) . _pms_dhe_psk as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_premaster_secret) , "::" , stringify ! (_pms_dhe_psk))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_premaster_secret > ())) . _pms_rsa_psk as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_premaster_secret) , "::" , stringify ! (_pms_rsa_psk))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_premaster_secret > ())) . _pms_ecdhe_psk as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_premaster_secret) , "::" , stringify ! (_pms_ecdhe_psk))) ; } impl Default for ssl_premaster_secret { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } pub const SSL_HELLO_REQUEST : ssl_states = 0 ; pub const SSL_CLIENT_HELLO : ssl_states = 1 ; pub const SSL_SERVER_HELLO : ssl_states = 2 ; pub const SSL_SERVER_CERTIFICATE : ssl_states = 3 ; pub const SSL_SERVER_KEY_EXCHANGE : ssl_states = 4 ; pub const SSL_CERTIFICATE_REQUEST : ssl_states = 5 ; pub const SSL_SERVER_HELLO_DONE : ssl_states = 6 ; pub const SSL_CLIENT_CERTIFICATE : ssl_states = 7 ; pub const SSL_CLIENT_KEY_EXCHANGE : ssl_states = 8 ; pub const SSL_CERTIFICATE_VERIFY : ssl_states = 9 ; pub const SSL_CLIENT_CHANGE_CIPHER_SPEC : ssl_states = 10 ; pub const SSL_CLIENT_FINISHED : ssl_states = 11 ; pub const SSL_SERVER_CHANGE_CIPHER_SPEC : ssl_states = 12 ; pub const SSL_SERVER_FINISHED : ssl_states = 13 ; pub const SSL_FLUSH_BUFFERS : ssl_states = 14 ; pub const SSL_HANDSHAKE_WRAPUP : ssl_states = 15 ; pub const SSL_HANDSHAKE_OVER : ssl_states = 16 ; pub const SSL_SERVER_NEW_SESSION_TICKET : ssl_states = 17 ; pub const SSL_SERVER_HELLO_VERIFY_REQUEST_SENT : ssl_states = 18 ; pub type ssl_states = u32 ; pub const SSL_TLS_PRF_NONE : tls_prf_types = 0 ; pub const SSL_TLS_PRF_SSL3 : tls_prf_types = 1 ; pub const SSL_TLS_PRF_TLS1 : tls_prf_types = 2 ; pub const SSL_TLS_PRF_SHA384 : tls_prf_types = 3 ; pub const SSL_TLS_PRF_SHA256 : tls_prf_types = 4 ; pub type tls_prf_types = u32 ; pub type ssl_send_t = :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , buf : * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int > ; pub type ssl_recv_t = :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , buf : * mut :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int > ; pub type ssl_recv_timeout_t = :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , buf : * mut :: types :: raw_types :: c_uchar , len : size_t , timeout : u32) -> :: types :: raw_types :: c_int > ; pub type ssl_set_timer_t = :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , int_ms : u32 , fin_ms : u32) > ; pub type ssl_get_timer_t = :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int > ; # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_session { pub mfl_code : :: types :: raw_types :: c_uchar , pub start : time_t , pub ciphersuite : :: types :: raw_types :: c_int , pub compression : :: types :: raw_types :: c_int , pub id_len : size_t , pub id : [:: types :: raw_types :: c_uchar ; 32usize] , pub master : [:: types :: raw_types :: c_uchar ; 48usize] , pub peer_cert : * mut x509_crt , pub verify_result : u32 , pub ticket : * mut :: types :: raw_types :: c_uchar , pub ticket_len : size_t , pub ticket_lifetime : u32 , pub trunc_hmac : :: types :: raw_types :: c_int , pub encrypt_then_mac : :: types :: raw_types :: c_int , } # [test] fn bindgen_test_layout_ssl_session () { assert_eq ! (:: core :: mem :: size_of :: < ssl_session > () , 160usize , concat ! ("Size of: " , stringify ! (ssl_session))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_session > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_session))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . mfl_code as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (mfl_code))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . start as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (start))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . ciphersuite as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (ciphersuite))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . compression as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (compression))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . id_len as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (id_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . id as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (id))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . master as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (master))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . peer_cert as * const _ as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (peer_cert))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . verify_result as * const _ as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (verify_result))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . ticket as * const _ as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (ticket))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . ticket_len as * const _ as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (ticket_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . ticket_lifetime as * const _ as usize } , 144usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (ticket_lifetime))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . trunc_hmac as * const _ as usize } , 148usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (trunc_hmac))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_session > ())) . encrypt_then_mac as * const _ as usize } , 152usize , concat ! ("Offset of field: " , stringify ! (ssl_session) , "::" , stringify ! (encrypt_then_mac))) ; } impl Default for ssl_session { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_config { pub max_major_ver : :: types :: raw_types :: c_uchar , pub max_minor_ver : :: types :: raw_types :: c_uchar , pub min_major_ver : :: types :: raw_types :: c_uchar , pub min_minor_ver : :: types :: raw_types :: c_uchar , pub endpoint : u8 , pub transport : u8 , pub authmode : u8 , pub allow_legacy_renegotiation : u8 , pub arc4_disabled : u8 , pub mfl_code : u8 , pub encrypt_then_mac : u8 , pub extended_ms : u8 , pub anti_replay : u8 , pub disable_renegotiation : u8 , pub trunc_hmac : u8 , pub session_tickets : u8 , pub fallback : u8 , pub cert_req_ca_list : u8 , pub read_timeout : u32 , pub hs_timeout_min : u32 , pub hs_timeout_max : u32 , pub renego_max_records : :: types :: raw_types :: c_int , pub renego_period : [:: types :: raw_types :: c_uchar ; 8usize] , pub badmac_limit : :: types :: raw_types :: c_uint , pub dhm_min_bitlen : :: types :: raw_types :: c_uint , pub ciphersuite_list : [* const :: types :: raw_types :: c_int ; 4usize] , pub f_dbg : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : :: types :: raw_types :: c_int , arg3 : * const :: types :: raw_types :: c_char , arg4 : :: types :: raw_types :: c_int , arg5 : * const :: types :: raw_types :: c_char) > , pub p_dbg : * mut :: types :: raw_types :: c_void , pub f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , pub p_rng : * mut :: types :: raw_types :: c_void , pub f_get_cache : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut ssl_session) -> :: types :: raw_types :: c_int > , pub f_set_cache : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * const ssl_session) -> :: types :: raw_types :: c_int > , pub p_cache : * mut :: types :: raw_types :: c_void , pub f_sni : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut ssl_context , arg3 : * const :: types :: raw_types :: c_uchar , arg4 : size_t) -> :: types :: raw_types :: c_int > , pub p_sni : * mut :: types :: raw_types :: c_void , pub f_vrfy : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut x509_crt , arg3 : :: types :: raw_types :: c_int , arg4 : * mut u32) -> :: types :: raw_types :: c_int > , pub p_vrfy : * mut :: types :: raw_types :: c_void , pub f_psk : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut ssl_context , arg3 : * const :: types :: raw_types :: c_uchar , arg4 : size_t) -> :: types :: raw_types :: c_int > , pub p_psk : * mut :: types :: raw_types :: c_void , pub f_cookie_write : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut * mut :: types :: raw_types :: c_uchar , arg3 : * mut :: types :: raw_types :: c_uchar , arg4 : * const :: types :: raw_types :: c_uchar , arg5 : size_t) -> :: types :: raw_types :: c_int > , pub f_cookie_check : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * const :: types :: raw_types :: c_uchar , arg3 : size_t , arg4 : * const :: types :: raw_types :: c_uchar , arg5 : size_t) -> :: types :: raw_types :: c_int > , pub p_cookie : * mut :: types :: raw_types :: c_void , pub f_ticket_write : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * const ssl_session , arg3 : * mut :: types :: raw_types :: c_uchar , arg4 : * const :: types :: raw_types :: c_uchar , arg5 : * mut size_t , arg6 : * mut u32) -> :: types :: raw_types :: c_int > , pub f_ticket_parse : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut ssl_session , arg3 : * mut :: types :: raw_types :: c_uchar , arg4 : size_t) -> :: types :: raw_types :: c_int > , pub p_ticket : * mut :: types :: raw_types :: c_void , pub f_export_keys : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * const :: types :: raw_types :: c_uchar , arg3 : * const :: types :: raw_types :: c_uchar , arg4 : size_t , arg5 : size_t , arg6 : size_t) -> :: types :: raw_types :: c_int > , pub f_export_keys_ext : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * const :: types :: raw_types :: c_uchar , arg3 : * const :: types :: raw_types :: c_uchar , arg4 : size_t , arg5 : size_t , arg6 : size_t , arg7 : * const :: types :: raw_types :: c_uchar , arg8 : * const :: types :: raw_types :: c_uchar , arg9 : tls_prf_types) -> :: types :: raw_types :: c_int > , pub p_export_keys : * mut :: types :: raw_types :: c_void , pub cert_profile : * const x509_crt_profile , pub key_cert : * mut ssl_key_cert , pub ca_chain : * mut x509_crt , pub ca_crl : * mut x509_crl , pub f_ca_cb : x509_crt_ca_cb_t , pub p_ca_cb : * mut :: types :: raw_types :: c_void , pub sig_hashes : * const :: types :: raw_types :: c_int , pub curve_list : * const ecp_group_id , pub dhm_P : mpi , pub dhm_G : mpi , pub psk : * mut :: types :: raw_types :: c_uchar , pub psk_len : size_t , pub psk_identity : * mut :: types :: raw_types :: c_uchar , pub psk_identity_len : size_t , pub alpn_list : * mut * const :: types :: raw_types :: c_char , } # [test] fn bindgen_test_layout_ssl_config () { assert_eq ! (:: core :: mem :: size_of :: < ssl_config > () , 416usize , concat ! ("Size of: " , stringify ! (ssl_config))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_config > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_config))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . max_major_ver as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (max_major_ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . max_minor_ver as * const _ as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (max_minor_ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . min_major_ver as * const _ as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (min_major_ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . min_minor_ver as * const _ as usize } , 3usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (min_minor_ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . endpoint as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (endpoint))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . transport as * const _ as usize } , 5usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (transport))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . authmode as * const _ as usize } , 6usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (authmode))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . allow_legacy_renegotiation as * const _ as usize } , 7usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (allow_legacy_renegotiation))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . arc4_disabled as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (arc4_disabled))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . mfl_code as * const _ as usize } , 9usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (mfl_code))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . encrypt_then_mac as * const _ as usize } , 10usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (encrypt_then_mac))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . extended_ms as * const _ as usize } , 11usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (extended_ms))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . anti_replay as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (anti_replay))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . disable_renegotiation as * const _ as usize } , 13usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (disable_renegotiation))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . trunc_hmac as * const _ as usize } , 14usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (trunc_hmac))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . session_tickets as * const _ as usize } , 15usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (session_tickets))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . fallback as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (fallback))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . cert_req_ca_list as * const _ as usize } , 17usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (cert_req_ca_list))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . read_timeout as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (read_timeout))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . hs_timeout_min as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (hs_timeout_min))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . hs_timeout_max as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (hs_timeout_max))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . renego_max_records as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (renego_max_records))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . renego_period as * const _ as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (renego_period))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . badmac_limit as * const _ as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (badmac_limit))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . dhm_min_bitlen as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (dhm_min_bitlen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . ciphersuite_list as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (ciphersuite_list))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_dbg as * const _ as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_dbg))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . p_dbg as * const _ as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (p_dbg))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_rng as * const _ as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_rng))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . p_rng as * const _ as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (p_rng))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_get_cache as * const _ as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_get_cache))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_set_cache as * const _ as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_set_cache))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . p_cache as * const _ as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (p_cache))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_sni as * const _ as usize } , 144usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_sni))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . p_sni as * const _ as usize } , 152usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (p_sni))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_vrfy as * const _ as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_vrfy))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . p_vrfy as * const _ as usize } , 168usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (p_vrfy))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_psk as * const _ as usize } , 176usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_psk))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . p_psk as * const _ as usize } , 184usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (p_psk))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_cookie_write as * const _ as usize } , 192usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_cookie_write))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_cookie_check as * const _ as usize } , 200usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_cookie_check))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . p_cookie as * const _ as usize } , 208usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (p_cookie))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_ticket_write as * const _ as usize } , 216usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_ticket_write))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_ticket_parse as * const _ as usize } , 224usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_ticket_parse))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . p_ticket as * const _ as usize } , 232usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (p_ticket))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_export_keys as * const _ as usize } , 240usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_export_keys))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_export_keys_ext as * const _ as usize } , 248usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_export_keys_ext))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . p_export_keys as * const _ as usize } , 256usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (p_export_keys))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . cert_profile as * const _ as usize } , 264usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (cert_profile))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . key_cert as * const _ as usize } , 272usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (key_cert))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . ca_chain as * const _ as usize } , 280usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (ca_chain))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . ca_crl as * const _ as usize } , 288usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (ca_crl))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . f_ca_cb as * const _ as usize } , 296usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (f_ca_cb))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . p_ca_cb as * const _ as usize } , 304usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (p_ca_cb))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . sig_hashes as * const _ as usize } , 312usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (sig_hashes))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . curve_list as * const _ as usize } , 320usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (curve_list))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . dhm_P as * const _ as usize } , 328usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (dhm_P))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . dhm_G as * const _ as usize } , 352usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (dhm_G))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . psk as * const _ as usize } , 376usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (psk))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . psk_len as * const _ as usize } , 384usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (psk_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . psk_identity as * const _ as usize } , 392usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (psk_identity))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . psk_identity_len as * const _ as usize } , 400usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (psk_identity_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_config > ())) . alpn_list as * const _ as usize } , 408usize , concat ! ("Offset of field: " , stringify ! (ssl_config) , "::" , stringify ! (alpn_list))) ; } impl Default for ssl_config { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_context { pub conf : * const ssl_config , pub state : :: types :: raw_types :: c_int , pub renego_status : :: types :: raw_types :: c_int , pub renego_records_seen : :: types :: raw_types :: c_int , pub major_ver : :: types :: raw_types :: c_int , pub minor_ver : :: types :: raw_types :: c_int , pub badmac_seen : :: types :: raw_types :: c_uint , pub f_vrfy : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut x509_crt , arg3 : :: types :: raw_types :: c_int , arg4 : * mut u32) -> :: types :: raw_types :: c_int > , pub p_vrfy : * mut :: types :: raw_types :: c_void , pub f_send : ssl_send_t , pub f_recv : ssl_recv_t , pub f_recv_timeout : ssl_recv_timeout_t , pub p_bio : * mut :: types :: raw_types :: c_void , pub session_in : * mut ssl_session , pub session_out : * mut ssl_session , pub session : * mut ssl_session , pub session_negotiate : * mut ssl_session , pub handshake : * mut ssl_handshake_params , pub transform_in : * mut ssl_transform , pub transform_out : * mut ssl_transform , pub transform : * mut ssl_transform , pub transform_negotiate : * mut ssl_transform , pub p_timer : * mut :: types :: raw_types :: c_void , pub f_set_timer : ssl_set_timer_t , pub f_get_timer : ssl_get_timer_t , pub in_buf : * mut :: types :: raw_types :: c_uchar , pub in_ctr : * mut :: types :: raw_types :: c_uchar , pub in_hdr : * mut :: types :: raw_types :: c_uchar , pub in_len : * mut :: types :: raw_types :: c_uchar , pub in_iv : * mut :: types :: raw_types :: c_uchar , pub in_msg : * mut :: types :: raw_types :: c_uchar , pub in_offt : * mut :: types :: raw_types :: c_uchar , pub in_msgtype : :: types :: raw_types :: c_int , pub in_msglen : size_t , pub in_left : size_t , pub in_epoch : u16 , pub next_record_offset : size_t , pub in_window_top : u64 , pub in_window : u64 , pub in_hslen : size_t , pub nb_zero : :: types :: raw_types :: c_int , pub keep_current_message : :: types :: raw_types :: c_int , pub disable_datagram_packing : u8 , pub out_buf : * mut :: types :: raw_types :: c_uchar , pub out_ctr : * mut :: types :: raw_types :: c_uchar , pub out_hdr : * mut :: types :: raw_types :: c_uchar , pub out_len : * mut :: types :: raw_types :: c_uchar , pub out_iv : * mut :: types :: raw_types :: c_uchar , pub out_msg : * mut :: types :: raw_types :: c_uchar , pub out_msgtype : :: types :: raw_types :: c_int , pub out_msglen : size_t , pub out_left : size_t , pub cur_out_ctr : [:: types :: raw_types :: c_uchar ; 8usize] , pub mtu : u16 , pub client_auth : :: types :: raw_types :: c_int , pub hostname : * mut :: types :: raw_types :: c_char , pub alpn_chosen : * const :: types :: raw_types :: c_char , pub cli_id : * mut :: types :: raw_types :: c_uchar , pub cli_id_len : size_t , pub secure_renegotiation : :: types :: raw_types :: c_int , pub verify_data_len : size_t , pub own_verify_data : [:: types :: raw_types :: c_char ; 12usize] , pub peer_verify_data : [:: types :: raw_types :: c_char ; 12usize] , } # [test] fn bindgen_test_layout_ssl_context () { assert_eq ! (:: core :: mem :: size_of :: < ssl_context > () , 472usize , concat ! ("Size of: " , stringify ! (ssl_context))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_context > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . conf as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (conf))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . state as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . renego_status as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (renego_status))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . renego_records_seen as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (renego_records_seen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . major_ver as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (major_ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . minor_ver as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (minor_ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . badmac_seen as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (badmac_seen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . f_vrfy as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (f_vrfy))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . p_vrfy as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (p_vrfy))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . f_send as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (f_send))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . f_recv as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (f_recv))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . f_recv_timeout as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (f_recv_timeout))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . p_bio as * const _ as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (p_bio))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . session_in as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (session_in))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . session_out as * const _ as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (session_out))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . session as * const _ as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (session))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . session_negotiate as * const _ as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (session_negotiate))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . handshake as * const _ as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (handshake))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . transform_in as * const _ as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (transform_in))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . transform_out as * const _ as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (transform_out))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . transform as * const _ as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (transform))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . transform_negotiate as * const _ as usize } , 144usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (transform_negotiate))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . p_timer as * const _ as usize } , 152usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (p_timer))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . f_set_timer as * const _ as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (f_set_timer))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . f_get_timer as * const _ as usize } , 168usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (f_get_timer))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_buf as * const _ as usize } , 176usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_buf))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_ctr as * const _ as usize } , 184usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_ctr))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_hdr as * const _ as usize } , 192usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_hdr))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_len as * const _ as usize } , 200usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_iv as * const _ as usize } , 208usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_iv))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_msg as * const _ as usize } , 216usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_msg))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_offt as * const _ as usize } , 224usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_offt))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_msgtype as * const _ as usize } , 232usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_msgtype))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_msglen as * const _ as usize } , 240usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_msglen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_left as * const _ as usize } , 248usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_left))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_epoch as * const _ as usize } , 256usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_epoch))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . next_record_offset as * const _ as usize } , 264usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (next_record_offset))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_window_top as * const _ as usize } , 272usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_window_top))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_window as * const _ as usize } , 280usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_window))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . in_hslen as * const _ as usize } , 288usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (in_hslen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . nb_zero as * const _ as usize } , 296usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (nb_zero))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . keep_current_message as * const _ as usize } , 300usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (keep_current_message))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . disable_datagram_packing as * const _ as usize } , 304usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (disable_datagram_packing))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . out_buf as * const _ as usize } , 312usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (out_buf))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . out_ctr as * const _ as usize } , 320usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (out_ctr))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . out_hdr as * const _ as usize } , 328usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (out_hdr))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . out_len as * const _ as usize } , 336usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (out_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . out_iv as * const _ as usize } , 344usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (out_iv))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . out_msg as * const _ as usize } , 352usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (out_msg))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . out_msgtype as * const _ as usize } , 360usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (out_msgtype))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . out_msglen as * const _ as usize } , 368usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (out_msglen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . out_left as * const _ as usize } , 376usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (out_left))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . cur_out_ctr as * const _ as usize } , 384usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (cur_out_ctr))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . mtu as * const _ as usize } , 392usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (mtu))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . client_auth as * const _ as usize } , 396usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (client_auth))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . hostname as * const _ as usize } , 400usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (hostname))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . alpn_chosen as * const _ as usize } , 408usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (alpn_chosen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . cli_id as * const _ as usize } , 416usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (cli_id))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . cli_id_len as * const _ as usize } , 424usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (cli_id_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . secure_renegotiation as * const _ as usize } , 432usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (secure_renegotiation))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . verify_data_len as * const _ as usize } , 440usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (verify_data_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . own_verify_data as * const _ as usize } , 448usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (own_verify_data))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_context > ())) . peer_verify_data as * const _ as usize } , 460usize , concat ! ("Offset of field: " , stringify ! (ssl_context) , "::" , stringify ! (peer_verify_data))) ; } impl Default for ssl_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_ciphersuite_name"] pub fn ssl_get_ciphersuite_name (ciphersuite_id : :: types :: raw_types :: c_int) -> * const :: types :: raw_types :: c_char ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_ciphersuite_id"] pub fn ssl_get_ciphersuite_id (ciphersuite_name : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_init"] pub fn ssl_init (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_setup"] pub fn ssl_setup (ssl : * mut ssl_context , conf : * const ssl_config) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_session_reset"] pub fn ssl_session_reset (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_endpoint"] pub fn ssl_conf_endpoint (conf : * mut ssl_config , endpoint : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_transport"] pub fn ssl_conf_transport (conf : * mut ssl_config , transport : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_authmode"] pub fn ssl_conf_authmode (conf : * mut ssl_config , authmode : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_verify"] pub fn ssl_conf_verify (conf : * mut ssl_config , f_vrfy : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut x509_crt , arg3 : :: types :: raw_types :: c_int , arg4 : * mut u32) -> :: types :: raw_types :: c_int > , p_vrfy : * mut :: types :: raw_types :: c_void) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_rng"] pub fn ssl_conf_rng (conf : * mut ssl_config , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_dbg"] pub fn ssl_conf_dbg (conf : * mut ssl_config , f_dbg : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : :: types :: raw_types :: c_int , arg3 : * const :: types :: raw_types :: c_char , arg4 : :: types :: raw_types :: c_int , arg5 : * const :: types :: raw_types :: c_char) > , p_dbg : * mut :: types :: raw_types :: c_void) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_bio"] pub fn ssl_set_bio (ssl : * mut ssl_context , p_bio : * mut :: types :: raw_types :: c_void , f_send : ssl_send_t , f_recv : ssl_recv_t , f_recv_timeout : ssl_recv_timeout_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_mtu"] pub fn ssl_set_mtu (ssl : * mut ssl_context , mtu : u16) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_verify"] pub fn ssl_set_verify (ssl : * mut ssl_context , f_vrfy : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut x509_crt , arg3 : :: types :: raw_types :: c_int , arg4 : * mut u32) -> :: types :: raw_types :: c_int > , p_vrfy : * mut :: types :: raw_types :: c_void) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_read_timeout"] pub fn ssl_conf_read_timeout (conf : * mut ssl_config , timeout : u32) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_check_record"] pub fn ssl_check_record (ssl : * const ssl_context , buf : * mut :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_timer_cb"] pub fn ssl_set_timer_cb (ssl : * mut ssl_context , p_timer : * mut :: types :: raw_types :: c_void , f_set_timer : ssl_set_timer_t , f_get_timer : ssl_get_timer_t) ; } pub type ssl_ticket_write_t = :: core :: option :: Option < unsafe extern "C" fn (p_ticket : * mut :: types :: raw_types :: c_void , session : * const ssl_session , start : * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , tlen : * mut size_t , lifetime : * mut u32) -> :: types :: raw_types :: c_int > ; pub type ssl_export_keys_t = :: core :: option :: Option < unsafe extern "C" fn (p_expkey : * mut :: types :: raw_types :: c_void , ms : * const :: types :: raw_types :: c_uchar , kb : * const :: types :: raw_types :: c_uchar , maclen : size_t , keylen : size_t , ivlen : size_t) -> :: types :: raw_types :: c_int > ; pub type ssl_export_keys_ext_t = :: core :: option :: Option < unsafe extern "C" fn (p_expkey : * mut :: types :: raw_types :: c_void , ms : * const :: types :: raw_types :: c_uchar , kb : * const :: types :: raw_types :: c_uchar , maclen : size_t , keylen : size_t , ivlen : size_t , client_random : * const :: types :: raw_types :: c_uchar , server_random : * const :: types :: raw_types :: c_uchar , tls_prf_type : tls_prf_types) -> :: types :: raw_types :: c_int > ; pub type ssl_ticket_parse_t = :: core :: option :: Option < unsafe extern "C" fn (p_ticket : * mut :: types :: raw_types :: c_void , session : * mut ssl_session , buf : * mut :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int > ; extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_session_tickets_cb"] pub fn ssl_conf_session_tickets_cb (conf : * mut ssl_config , f_ticket_write : ssl_ticket_write_t , f_ticket_parse : ssl_ticket_parse_t , p_ticket : * mut :: types :: raw_types :: c_void) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_export_keys_cb"] pub fn ssl_conf_export_keys_cb (conf : * mut ssl_config , f_export_keys : ssl_export_keys_t , p_export_keys : * mut :: types :: raw_types :: c_void) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_export_keys_ext_cb"] pub fn ssl_conf_export_keys_ext_cb (conf : * mut ssl_config , f_export_keys_ext : ssl_export_keys_ext_t , p_export_keys : * mut :: types :: raw_types :: c_void) ; } pub type ssl_cookie_write_t = :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , p : * mut * mut :: types :: raw_types :: c_uchar , end : * mut :: types :: raw_types :: c_uchar , info : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int > ; pub type ssl_cookie_check_t = :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , cookie : * const :: types :: raw_types :: c_uchar , clen : size_t , info : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int > ; extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_dtls_cookies"] pub fn ssl_conf_dtls_cookies (conf : * mut ssl_config , f_cookie_write : ssl_cookie_write_t , f_cookie_check : ssl_cookie_check_t , p_cookie : * mut :: types :: raw_types :: c_void) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_client_transport_id"] pub fn ssl_set_client_transport_id (ssl : * mut ssl_context , info : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_dtls_anti_replay"] pub fn ssl_conf_dtls_anti_replay (conf : * mut ssl_config , mode : :: types :: raw_types :: c_char) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_dtls_badmac_limit"] pub fn ssl_conf_dtls_badmac_limit (conf : * mut ssl_config , limit : :: types :: raw_types :: c_uint) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_datagram_packing"] pub fn ssl_set_datagram_packing (ssl : * mut ssl_context , allow_packing : :: types :: raw_types :: c_uint) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_handshake_timeout"] pub fn ssl_conf_handshake_timeout (conf : * mut ssl_config , min : u32 , max : u32) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_session_cache"] pub fn ssl_conf_session_cache (conf : * mut ssl_config , p_cache : * mut :: types :: raw_types :: c_void , f_get_cache : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut ssl_session) -> :: types :: raw_types :: c_int > , f_set_cache : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * const ssl_session) -> :: types :: raw_types :: c_int >) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_session"] pub fn ssl_set_session (ssl : * mut ssl_context , session : * const ssl_session) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_session_load"] pub fn ssl_session_load (session : * mut ssl_session , buf : * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_session_save"] pub fn ssl_session_save (session : * const ssl_session , buf : * mut :: types :: raw_types :: c_uchar , buf_len : size_t , olen : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_session_pointer"] pub fn ssl_get_session_pointer (ssl : * const ssl_context) -> * const ssl_session ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_ciphersuites"] pub fn ssl_conf_ciphersuites (conf : * mut ssl_config , ciphersuites : * const :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_ciphersuites_for_version"] pub fn ssl_conf_ciphersuites_for_version (conf : * mut ssl_config , ciphersuites : * const :: types :: raw_types :: c_int , major : :: types :: raw_types :: c_int , minor : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_cert_profile"] pub fn ssl_conf_cert_profile (conf : * mut ssl_config , profile : * const x509_crt_profile) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_ca_chain"] pub fn ssl_conf_ca_chain (conf : * mut ssl_config , ca_chain : * mut x509_crt , ca_crl : * mut x509_crl) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_ca_cb"] pub fn ssl_conf_ca_cb (conf : * mut ssl_config , f_ca_cb : x509_crt_ca_cb_t , p_ca_cb : * mut :: types :: raw_types :: c_void) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_own_cert"] pub fn ssl_conf_own_cert (conf : * mut ssl_config , own_cert : * mut x509_crt , pk_key : * mut pk_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_psk"] pub fn ssl_conf_psk (conf : * mut ssl_config , psk : * const :: types :: raw_types :: c_uchar , psk_len : size_t , psk_identity : * const :: types :: raw_types :: c_uchar , psk_identity_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_hs_psk"] pub fn ssl_set_hs_psk (ssl : * mut ssl_context , psk : * const :: types :: raw_types :: c_uchar , psk_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_psk_cb"] pub fn ssl_conf_psk_cb (conf : * mut ssl_config , f_psk : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut ssl_context , arg3 : * const :: types :: raw_types :: c_uchar , arg4 : size_t) -> :: types :: raw_types :: c_int > , p_psk : * mut :: types :: raw_types :: c_void) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_dh_param"] pub fn ssl_conf_dh_param (conf : * mut ssl_config , dhm_P : * const :: types :: raw_types :: c_char , dhm_G : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_dh_param_bin"] pub fn ssl_conf_dh_param_bin (conf : * mut ssl_config , dhm_P : * const :: types :: raw_types :: c_uchar , P_len : size_t , dhm_G : * const :: types :: raw_types :: c_uchar , G_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_dh_param_ctx"] pub fn ssl_conf_dh_param_ctx (conf : * mut ssl_config , dhm_ctx : * mut dhm_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_dhm_min_bitlen"] pub fn ssl_conf_dhm_min_bitlen (conf : * mut ssl_config , bitlen : :: types :: raw_types :: c_uint) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_curves"] pub fn ssl_conf_curves (conf : * mut ssl_config , curves : * const ecp_group_id) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_sig_hashes"] pub fn ssl_conf_sig_hashes (conf : * mut ssl_config , hashes : * const :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_hostname"] pub fn ssl_set_hostname (ssl : * mut ssl_context , hostname : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_hs_own_cert"] pub fn ssl_set_hs_own_cert (ssl : * mut ssl_context , own_cert : * mut x509_crt , pk_key : * mut pk_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_hs_ca_chain"] pub fn ssl_set_hs_ca_chain (ssl : * mut ssl_context , ca_chain : * mut x509_crt , ca_crl : * mut x509_crl) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_hs_authmode"] pub fn ssl_set_hs_authmode (ssl : * mut ssl_context , authmode : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_sni"] pub fn ssl_conf_sni (conf : * mut ssl_config , f_sni : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut ssl_context , arg3 : * const :: types :: raw_types :: c_uchar , arg4 : size_t) -> :: types :: raw_types :: c_int > , p_sni : * mut :: types :: raw_types :: c_void) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_alpn_protocols"] pub fn ssl_conf_alpn_protocols (conf : * mut ssl_config , protos : * mut * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_alpn_protocol"] pub fn ssl_get_alpn_protocol (ssl : * const ssl_context) -> * const :: types :: raw_types :: c_char ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_max_version"] pub fn ssl_conf_max_version (conf : * mut ssl_config , major : :: types :: raw_types :: c_int , minor : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_min_version"] pub fn ssl_conf_min_version (conf : * mut ssl_config , major : :: types :: raw_types :: c_int , minor : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_fallback"] pub fn ssl_conf_fallback (conf : * mut ssl_config , fallback : :: types :: raw_types :: c_char) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_encrypt_then_mac"] pub fn ssl_conf_encrypt_then_mac (conf : * mut ssl_config , etm : :: types :: raw_types :: c_char) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_extended_master_secret"] pub fn ssl_conf_extended_master_secret (conf : * mut ssl_config , ems : :: types :: raw_types :: c_char) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_arc4_support"] pub fn ssl_conf_arc4_support (conf : * mut ssl_config , arc4 : :: types :: raw_types :: c_char) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_cert_req_ca_list"] pub fn ssl_conf_cert_req_ca_list (conf : * mut ssl_config , cert_req_ca_list : :: types :: raw_types :: c_char) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_max_frag_len"] pub fn ssl_conf_max_frag_len (conf : * mut ssl_config , mfl_code : :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_truncated_hmac"] pub fn ssl_conf_truncated_hmac (conf : * mut ssl_config , truncate : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_session_tickets"] pub fn ssl_conf_session_tickets (conf : * mut ssl_config , use_tickets : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_renegotiation"] pub fn ssl_conf_renegotiation (conf : * mut ssl_config , renegotiation : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_legacy_renegotiation"] pub fn ssl_conf_legacy_renegotiation (conf : * mut ssl_config , allow_legacy : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_renegotiation_enforced"] pub fn ssl_conf_renegotiation_enforced (conf : * mut ssl_config , max_records : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_conf_renegotiation_period"] pub fn ssl_conf_renegotiation_period (conf : * mut ssl_config , period : * const :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_check_pending"] pub fn ssl_check_pending (ssl : * const ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_bytes_avail"] pub fn ssl_get_bytes_avail (ssl : * const ssl_context) -> size_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_verify_result"] pub fn ssl_get_verify_result (ssl : * const ssl_context) -> u32 ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_ciphersuite"] pub fn ssl_get_ciphersuite (ssl : * const ssl_context) -> * const :: types :: raw_types :: c_char ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_version"] pub fn ssl_get_version (ssl : * const ssl_context) -> * const :: types :: raw_types :: c_char ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_record_expansion"] pub fn ssl_get_record_expansion (ssl : * const ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_output_max_frag_len"] pub fn ssl_get_output_max_frag_len (ssl : * const ssl_context) -> size_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_input_max_frag_len"] pub fn ssl_get_input_max_frag_len (ssl : * const ssl_context) -> size_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_max_frag_len"] pub fn ssl_get_max_frag_len (ssl : * const ssl_context) -> size_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_max_out_record_payload"] pub fn ssl_get_max_out_record_payload (ssl : * const ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_peer_cert"] pub fn ssl_get_peer_cert (ssl : * const ssl_context) -> * const x509_crt ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_session"] pub fn ssl_get_session (ssl : * const ssl_context , session : * mut ssl_session) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_handshake"] pub fn ssl_handshake (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_handshake_step"] pub fn ssl_handshake_step (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_renegotiate"] pub fn ssl_renegotiate (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_read"] pub fn ssl_read (ssl : * mut ssl_context , buf : * mut :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_write"] pub fn ssl_write (ssl : * mut ssl_context , buf : * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_send_alert_message"] pub fn ssl_send_alert_message (ssl : * mut ssl_context , level : :: types :: raw_types :: c_uchar , message : :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_close_notify"] pub fn ssl_close_notify (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_free"] pub fn ssl_free (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_context_save"] pub fn ssl_context_save (ssl : * mut ssl_context , buf : * mut :: types :: raw_types :: c_uchar , buf_len : size_t , olen : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_context_load"] pub fn ssl_context_load (ssl : * mut ssl_context , buf : * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_config_init"] pub fn ssl_config_init (conf : * mut ssl_config) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_config_defaults"] pub fn ssl_config_defaults (conf : * mut ssl_config , endpoint : :: types :: raw_types :: c_int , transport : :: types :: raw_types :: c_int , preset : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_config_free"] pub fn ssl_config_free (conf : * mut ssl_config) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_session_init"] pub fn ssl_session_init (session : * mut ssl_session) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_session_free"] pub fn ssl_session_free (session : * mut ssl_session) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_tls_prf"] pub fn ssl_tls_prf (prf : tls_prf_types , secret : * const :: types :: raw_types :: c_uchar , slen : size_t , label : * const :: types :: raw_types :: c_char , random : * const :: types :: raw_types :: c_uchar , rlen : size_t , dstbuf : * mut :: types :: raw_types :: c_uchar , dlen : size_t) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct md5_context { pub total : [u32 ; 2usize] , pub state : [u32 ; 4usize] , pub buffer : [:: types :: raw_types :: c_uchar ; 64usize] , } # [test] fn bindgen_test_layout_md5_context () { assert_eq ! (:: core :: mem :: size_of :: < md5_context > () , 88usize , concat ! ("Size of: " , stringify ! (md5_context))) ; assert_eq ! (:: core :: mem :: align_of :: < md5_context > () , 4usize , concat ! ("Alignment of " , stringify ! (md5_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md5_context > ())) . total as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (md5_context) , "::" , stringify ! (total))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md5_context > ())) . state as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (md5_context) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md5_context > ())) . buffer as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (md5_context) , "::" , stringify ! (buffer))) ; } impl Default for md5_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_md5_init"] pub fn md5_init (ctx : * mut md5_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_md5_free"] pub fn md5_free (ctx : * mut md5_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_md5_clone"] pub fn md5_clone (dst : * mut md5_context , src : * const md5_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_md5_starts_ret"] pub fn md5_starts_ret (ctx : * mut md5_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md5_update_ret"] pub fn md5_update_ret (ctx : * mut md5_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md5_finish_ret"] pub fn md5_finish_ret (ctx : * mut md5_context , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_internal_md5_process"] pub fn internal_md5_process (ctx : * mut md5_context , data : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md5_starts"] pub fn md5_starts (ctx : * mut md5_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_md5_update"] pub fn md5_update (ctx : * mut md5_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_md5_finish"] pub fn md5_finish (ctx : * mut md5_context , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_md5_process"] pub fn md5_process (ctx : * mut md5_context , data : * const :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_md5_ret"] pub fn md5_ret (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md5"] pub fn md5 (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_md5_self_test"] pub fn md5_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct sha1_context { pub total : [u32 ; 2usize] , pub state : [u32 ; 5usize] , pub buffer : [:: types :: raw_types :: c_uchar ; 64usize] , } # [test] fn bindgen_test_layout_sha1_context () { assert_eq ! (:: core :: mem :: size_of :: < sha1_context > () , 92usize , concat ! ("Size of: " , stringify ! (sha1_context))) ; assert_eq ! (:: core :: mem :: align_of :: < sha1_context > () , 4usize , concat ! ("Alignment of " , stringify ! (sha1_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < sha1_context > ())) . total as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (sha1_context) , "::" , stringify ! (total))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < sha1_context > ())) . state as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (sha1_context) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < sha1_context > ())) . buffer as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (sha1_context) , "::" , stringify ! (buffer))) ; } impl Default for sha1_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_sha1_init"] pub fn sha1_init (ctx : * mut sha1_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha1_free"] pub fn sha1_free (ctx : * mut sha1_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha1_clone"] pub fn sha1_clone (dst : * mut sha1_context , src : * const sha1_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha1_starts_ret"] pub fn sha1_starts_ret (ctx : * mut sha1_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_sha1_update_ret"] pub fn sha1_update_ret (ctx : * mut sha1_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_sha1_finish_ret"] pub fn sha1_finish_ret (ctx : * mut sha1_context , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_internal_sha1_process"] pub fn internal_sha1_process (ctx : * mut sha1_context , data : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_sha1_starts"] pub fn sha1_starts (ctx : * mut sha1_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha1_update"] pub fn sha1_update (ctx : * mut sha1_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha1_finish"] pub fn sha1_finish (ctx : * mut sha1_context , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha1_process"] pub fn sha1_process (ctx : * mut sha1_context , data : * const :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha1_ret"] pub fn sha1_ret (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_sha1"] pub fn sha1 (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha1_self_test"] pub fn sha1_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct sha256_context { pub total : [u32 ; 2usize] , pub state : [u32 ; 8usize] , pub buffer : [:: types :: raw_types :: c_uchar ; 64usize] , pub is224 : :: types :: raw_types :: c_int , } # [test] fn bindgen_test_layout_sha256_context () { assert_eq ! (:: core :: mem :: size_of :: < sha256_context > () , 108usize , concat ! ("Size of: " , stringify ! (sha256_context))) ; assert_eq ! (:: core :: mem :: align_of :: < sha256_context > () , 4usize , concat ! ("Alignment of " , stringify ! (sha256_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < sha256_context > ())) . total as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (sha256_context) , "::" , stringify ! (total))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < sha256_context > ())) . state as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (sha256_context) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < sha256_context > ())) . buffer as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (sha256_context) , "::" , stringify ! (buffer))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < sha256_context > ())) . is224 as * const _ as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (sha256_context) , "::" , stringify ! (is224))) ; } impl Default for sha256_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_sha256_init"] pub fn sha256_init (ctx : * mut sha256_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha256_free"] pub fn sha256_free (ctx : * mut sha256_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha256_clone"] pub fn sha256_clone (dst : * mut sha256_context , src : * const sha256_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha256_starts_ret"] pub fn sha256_starts_ret (ctx : * mut sha256_context , is224 : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_sha256_update_ret"] pub fn sha256_update_ret (ctx : * mut sha256_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_sha256_finish_ret"] pub fn sha256_finish_ret (ctx : * mut sha256_context , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_internal_sha256_process"] pub fn internal_sha256_process (ctx : * mut sha256_context , data : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_sha256_starts"] pub fn sha256_starts (ctx : * mut sha256_context , is224 : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha256_update"] pub fn sha256_update (ctx : * mut sha256_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha256_finish"] pub fn sha256_finish (ctx : * mut sha256_context , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha256_process"] pub fn sha256_process (ctx : * mut sha256_context , data : * const :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha256_ret"] pub fn sha256_ret (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , is224 : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_sha256"] pub fn sha256 (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , is224 : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha256_self_test"] pub fn sha256_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct sha512_context { pub total : [u64 ; 2usize] , pub state : [u64 ; 8usize] , pub buffer : [:: types :: raw_types :: c_uchar ; 128usize] , pub is384 : :: types :: raw_types :: c_int , } # [test] fn bindgen_test_layout_sha512_context () { assert_eq ! (:: core :: mem :: size_of :: < sha512_context > () , 216usize , concat ! ("Size of: " , stringify ! (sha512_context))) ; assert_eq ! (:: core :: mem :: align_of :: < sha512_context > () , 8usize , concat ! ("Alignment of " , stringify ! (sha512_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < sha512_context > ())) . total as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (sha512_context) , "::" , stringify ! (total))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < sha512_context > ())) . state as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (sha512_context) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < sha512_context > ())) . buffer as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (sha512_context) , "::" , stringify ! (buffer))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < sha512_context > ())) . is384 as * const _ as usize } , 208usize , concat ! ("Offset of field: " , stringify ! (sha512_context) , "::" , stringify ! (is384))) ; } impl Default for sha512_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_sha512_init"] pub fn sha512_init (ctx : * mut sha512_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha512_free"] pub fn sha512_free (ctx : * mut sha512_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha512_clone"] pub fn sha512_clone (dst : * mut sha512_context , src : * const sha512_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha512_starts_ret"] pub fn sha512_starts_ret (ctx : * mut sha512_context , is384 : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_sha512_update_ret"] pub fn sha512_update_ret (ctx : * mut sha512_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_sha512_finish_ret"] pub fn sha512_finish_ret (ctx : * mut sha512_context , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_internal_sha512_process"] pub fn internal_sha512_process (ctx : * mut sha512_context , data : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_sha512_starts"] pub fn sha512_starts (ctx : * mut sha512_context , is384 : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha512_update"] pub fn sha512_update (ctx : * mut sha512_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha512_finish"] pub fn sha512_finish (ctx : * mut sha512_context , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha512_process"] pub fn sha512_process (ctx : * mut sha512_context , data : * const :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha512_ret"] pub fn sha512_ret (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , is384 : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_sha512"] pub fn sha512 (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , is384 : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_sha512_self_test"] pub fn sha512_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } pub const ECJPAKE_CLIENT : ecjpake_role = 0 ; pub const ECJPAKE_SERVER : ecjpake_role = 1 ; pub type ecjpake_role = u32 ; # [repr (C)] # [derive (Copy , Clone)] pub struct ecjpake_context { pub md_info : * const md_info_t , pub grp : ecp_group , pub role : ecjpake_role , pub point_format : :: types :: raw_types :: c_int , pub Xm1 : ecp_point , pub Xm2 : ecp_point , pub Xp1 : ecp_point , pub Xp2 : ecp_point , pub Xp : ecp_point , pub xm1 : mpi , pub xm2 : mpi , pub s : mpi , } # [test] fn bindgen_test_layout_ecjpake_context () { assert_eq ! (:: core :: mem :: size_of :: < ecjpake_context > () , 696usize , concat ! ("Size of: " , stringify ! (ecjpake_context))) ; assert_eq ! (:: core :: mem :: align_of :: < ecjpake_context > () , 8usize , concat ! ("Alignment of " , stringify ! (ecjpake_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecjpake_context > ())) . md_info as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ecjpake_context) , "::" , stringify ! (md_info))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecjpake_context > ())) . grp as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ecjpake_context) , "::" , stringify ! (grp))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecjpake_context > ())) . role as * const _ as usize } , 256usize , concat ! ("Offset of field: " , stringify ! (ecjpake_context) , "::" , stringify ! (role))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecjpake_context > ())) . point_format as * const _ as usize } , 260usize , concat ! ("Offset of field: " , stringify ! (ecjpake_context) , "::" , stringify ! (point_format))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecjpake_context > ())) . Xm1 as * const _ as usize } , 264usize , concat ! ("Offset of field: " , stringify ! (ecjpake_context) , "::" , stringify ! (Xm1))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecjpake_context > ())) . Xm2 as * const _ as usize } , 336usize , concat ! ("Offset of field: " , stringify ! (ecjpake_context) , "::" , stringify ! (Xm2))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecjpake_context > ())) . Xp1 as * const _ as usize } , 408usize , concat ! ("Offset of field: " , stringify ! (ecjpake_context) , "::" , stringify ! (Xp1))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecjpake_context > ())) . Xp2 as * const _ as usize } , 480usize , concat ! ("Offset of field: " , stringify ! (ecjpake_context) , "::" , stringify ! (Xp2))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecjpake_context > ())) . Xp as * const _ as usize } , 552usize , concat ! ("Offset of field: " , stringify ! (ecjpake_context) , "::" , stringify ! (Xp))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecjpake_context > ())) . xm1 as * const _ as usize } , 624usize , concat ! ("Offset of field: " , stringify ! (ecjpake_context) , "::" , stringify ! (xm1))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecjpake_context > ())) . xm2 as * const _ as usize } , 648usize , concat ! ("Offset of field: " , stringify ! (ecjpake_context) , "::" , stringify ! (xm2))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ecjpake_context > ())) . s as * const _ as usize } , 672usize , concat ! ("Offset of field: " , stringify ! (ecjpake_context) , "::" , stringify ! (s))) ; } impl Default for ecjpake_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_ecjpake_init"] pub fn ecjpake_init (ctx : * mut ecjpake_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ecjpake_setup"] pub fn ecjpake_setup (ctx : * mut ecjpake_context , role : ecjpake_role , hash : md_type_t , curve : ecp_group_id , secret : * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecjpake_check"] pub fn ecjpake_check (ctx : * const ecjpake_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecjpake_write_round_one"] pub fn ecjpake_write_round_one (ctx : * mut ecjpake_context , buf : * mut :: types :: raw_types :: c_uchar , len : size_t , olen : * mut size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecjpake_read_round_one"] pub fn ecjpake_read_round_one (ctx : * mut ecjpake_context , buf : * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecjpake_write_round_two"] pub fn ecjpake_write_round_two (ctx : * mut ecjpake_context , buf : * mut :: types :: raw_types :: c_uchar , len : size_t , olen : * mut size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecjpake_read_round_two"] pub fn ecjpake_read_round_two (ctx : * mut ecjpake_context , buf : * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecjpake_derive_secret"] pub fn ecjpake_derive_secret (ctx : * mut ecjpake_context , buf : * mut :: types :: raw_types :: c_uchar , len : size_t , olen : * mut size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ecjpake_free"] pub fn ecjpake_free (ctx : * mut ecjpake_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ecjpake_self_test"] pub fn ecjpake_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Default , Copy , Clone)] pub struct net_context { pub fd : :: types :: raw_types :: c_int , } # [test] fn bindgen_test_layout_net_context () { assert_eq ! (:: core :: mem :: size_of :: < net_context > () , 4usize , concat ! ("Size of: " , stringify ! (net_context))) ; assert_eq ! (:: core :: mem :: align_of :: < net_context > () , 4usize , concat ! ("Alignment of " , stringify ! (net_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < net_context > ())) . fd as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (net_context) , "::" , stringify ! (fd))) ; } extern "C" { # [link_name = "\u{1}mbedtls_net_init"] pub fn net_init (ctx : * mut net_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_net_connect"] pub fn net_connect (ctx : * mut net_context , host : * const :: types :: raw_types :: c_char , port : * const :: types :: raw_types :: c_char , proto : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_net_bind"] pub fn net_bind (ctx : * mut net_context , bind_ip : * const :: types :: raw_types :: c_char , port : * const :: types :: raw_types :: c_char , proto : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_net_accept"] pub fn net_accept (bind_ctx : * mut net_context , client_ctx : * mut net_context , client_ip : * mut :: types :: raw_types :: c_void , buf_size : size_t , ip_len : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_net_poll"] pub fn net_poll (ctx : * mut net_context , rw : u32 , timeout : u32) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_net_set_block"] pub fn net_set_block (ctx : * mut net_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_net_set_nonblock"] pub fn net_set_nonblock (ctx : * mut net_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_net_usleep"] pub fn net_usleep (usec : :: types :: raw_types :: c_ulong) ; } extern "C" { # [link_name = "\u{1}mbedtls_net_recv"] pub fn net_recv (ctx : * mut :: types :: raw_types :: c_void , buf : * mut :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_net_send"] pub fn net_send (ctx : * mut :: types :: raw_types :: c_void , buf : * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_net_recv_timeout"] pub fn net_recv_timeout (ctx : * mut :: types :: raw_types :: c_void , buf : * mut :: types :: raw_types :: c_uchar , len : size_t , timeout : u32) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_net_close"] pub fn net_close (ctx : * mut net_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_net_free"] pub fn net_free (ctx : * mut net_context) ; } # [repr (C)] # [derive (Copy , Clone)] pub struct havege_state { pub PT1 : u32 , pub PT2 : u32 , pub offset : [u32 ; 2usize] , pub pool : [u32 ; 1024usize] , pub WALK : [u32 ; 8192usize] , } # [test] fn bindgen_test_layout_havege_state () { assert_eq ! (:: core :: mem :: size_of :: < havege_state > () , 36880usize , concat ! ("Size of: " , stringify ! (havege_state))) ; assert_eq ! (:: core :: mem :: align_of :: < havege_state > () , 4usize , concat ! ("Alignment of " , stringify ! (havege_state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < havege_state > ())) . PT1 as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (havege_state) , "::" , stringify ! (PT1))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < havege_state > ())) . PT2 as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (havege_state) , "::" , stringify ! (PT2))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < havege_state > ())) . offset as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (havege_state) , "::" , stringify ! (offset))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < havege_state > ())) . pool as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (havege_state) , "::" , stringify ! (pool))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < havege_state > ())) . WALK as * const _ as usize } , 4112usize , concat ! ("Offset of field: " , stringify ! (havege_state) , "::" , stringify ! (WALK))) ; } impl Default for havege_state { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_havege_init"] pub fn havege_init (hs : * mut havege_state) ; } extern "C" { # [link_name = "\u{1}mbedtls_havege_free"] pub fn havege_free (hs : * mut havege_state) ; } extern "C" { # [link_name = "\u{1}mbedtls_havege_random"] pub fn havege_random (p_rng : * mut :: types :: raw_types :: c_void , output : * mut :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct poly1305_context { pub r : [u32 ; 4usize] , pub s : [u32 ; 4usize] , pub acc : [u32 ; 5usize] , pub queue : [u8 ; 16usize] , pub queue_len : size_t , } # [test] fn bindgen_test_layout_poly1305_context () { assert_eq ! (:: core :: mem :: size_of :: < poly1305_context > () , 80usize , concat ! ("Size of: " , stringify ! (poly1305_context))) ; assert_eq ! (:: core :: mem :: align_of :: < poly1305_context > () , 8usize , concat ! ("Alignment of " , stringify ! (poly1305_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < poly1305_context > ())) . r as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (poly1305_context) , "::" , stringify ! (r))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < poly1305_context > ())) . s as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (poly1305_context) , "::" , stringify ! (s))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < poly1305_context > ())) . acc as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (poly1305_context) , "::" , stringify ! (acc))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < poly1305_context > ())) . queue as * const _ as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (poly1305_context) , "::" , stringify ! (queue))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < poly1305_context > ())) . queue_len as * const _ as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (poly1305_context) , "::" , stringify ! (queue_len))) ; } impl Default for poly1305_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_poly1305_init"] pub fn poly1305_init (ctx : * mut poly1305_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_poly1305_free"] pub fn poly1305_free (ctx : * mut poly1305_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_poly1305_starts"] pub fn poly1305_starts (ctx : * mut poly1305_context , key : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_poly1305_update"] pub fn poly1305_update (ctx : * mut poly1305_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_poly1305_finish"] pub fn poly1305_finish (ctx : * mut poly1305_context , mac : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_poly1305_mac"] pub fn poly1305_mac (key : * const :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , mac : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_poly1305_self_test"] pub fn poly1305_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct chacha20_context { pub state : [u32 ; 16usize] , pub keystream8 : [u8 ; 64usize] , pub keystream_bytes_used : size_t , } # [test] fn bindgen_test_layout_chacha20_context () { assert_eq ! (:: core :: mem :: size_of :: < chacha20_context > () , 136usize , concat ! ("Size of: " , stringify ! (chacha20_context))) ; assert_eq ! (:: core :: mem :: align_of :: < chacha20_context > () , 8usize , concat ! ("Alignment of " , stringify ! (chacha20_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < chacha20_context > ())) . state as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (chacha20_context) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < chacha20_context > ())) . keystream8 as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (chacha20_context) , "::" , stringify ! (keystream8))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < chacha20_context > ())) . keystream_bytes_used as * const _ as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (chacha20_context) , "::" , stringify ! (keystream_bytes_used))) ; } impl Default for chacha20_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_chacha20_init"] pub fn chacha20_init (ctx : * mut chacha20_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_chacha20_free"] pub fn chacha20_free (ctx : * mut chacha20_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_chacha20_setkey"] pub fn chacha20_setkey (ctx : * mut chacha20_context , key : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_chacha20_starts"] pub fn chacha20_starts (ctx : * mut chacha20_context , nonce : * const :: types :: raw_types :: c_uchar , counter : u32) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_chacha20_update"] pub fn chacha20_update (ctx : * mut chacha20_context , size : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_chacha20_crypt"] pub fn chacha20_crypt (key : * const :: types :: raw_types :: c_uchar , nonce : * const :: types :: raw_types :: c_uchar , counter : u32 , size : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_chacha20_self_test"] pub fn chacha20_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct xtea_context { pub k : [u32 ; 4usize] , } # [test] fn bindgen_test_layout_xtea_context () { assert_eq ! (:: core :: mem :: size_of :: < xtea_context > () , 16usize , concat ! ("Size of: " , stringify ! (xtea_context))) ; assert_eq ! (:: core :: mem :: align_of :: < xtea_context > () , 4usize , concat ! ("Alignment of " , stringify ! (xtea_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < xtea_context > ())) . k as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xtea_context) , "::" , stringify ! (k))) ; } impl Default for xtea_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_xtea_init"] pub fn xtea_init (ctx : * mut xtea_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_xtea_free"] pub fn xtea_free (ctx : * mut xtea_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_xtea_setup"] pub fn xtea_setup (ctx : * mut xtea_context , key : * const :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_xtea_crypt_ecb"] pub fn xtea_crypt_ecb (ctx : * mut xtea_context , mode : :: types :: raw_types :: c_int , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_xtea_crypt_cbc"] pub fn xtea_crypt_cbc (ctx : * mut xtea_context , mode : :: types :: raw_types :: c_int , length : size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_xtea_self_test"] pub fn xtea_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct x509_csr { pub raw : x509_buf , pub cri : x509_buf , pub version : :: types :: raw_types :: c_int , pub subject_raw : x509_buf , pub subject : x509_name , pub pk : pk_context , pub sig_oid : x509_buf , pub sig : x509_buf , pub sig_md : md_type_t , pub sig_pk : pk_type_t , pub sig_opts : * mut :: types :: raw_types :: c_void , } # [test] fn bindgen_test_layout_x509_csr () { assert_eq ! (:: core :: mem :: size_of :: < x509_csr > () , 224usize , concat ! ("Size of: " , stringify ! (x509_csr))) ; assert_eq ! (:: core :: mem :: align_of :: < x509_csr > () , 8usize , concat ! ("Alignment of " , stringify ! (x509_csr))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_csr > ())) . raw as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509_csr) , "::" , stringify ! (raw))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_csr > ())) . cri as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (x509_csr) , "::" , stringify ! (cri))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_csr > ())) . version as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (x509_csr) , "::" , stringify ! (version))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_csr > ())) . subject_raw as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (x509_csr) , "::" , stringify ! (subject_raw))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_csr > ())) . subject as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (x509_csr) , "::" , stringify ! (subject))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_csr > ())) . pk as * const _ as usize } , 144usize , concat ! ("Offset of field: " , stringify ! (x509_csr) , "::" , stringify ! (pk))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_csr > ())) . sig_oid as * const _ as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (x509_csr) , "::" , stringify ! (sig_oid))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_csr > ())) . sig as * const _ as usize } , 184usize , concat ! ("Offset of field: " , stringify ! (x509_csr) , "::" , stringify ! (sig))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_csr > ())) . sig_md as * const _ as usize } , 208usize , concat ! ("Offset of field: " , stringify ! (x509_csr) , "::" , stringify ! (sig_md))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_csr > ())) . sig_pk as * const _ as usize } , 212usize , concat ! ("Offset of field: " , stringify ! (x509_csr) , "::" , stringify ! (sig_pk))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509_csr > ())) . sig_opts as * const _ as usize } , 216usize , concat ! ("Offset of field: " , stringify ! (x509_csr) , "::" , stringify ! (sig_opts))) ; } impl Default for x509_csr { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct x509write_csr { pub key : * mut pk_context , pub subject : * mut asn1_named_data , pub md_alg : md_type_t , pub extensions : * mut asn1_named_data , } # [test] fn bindgen_test_layout_x509write_csr () { assert_eq ! (:: core :: mem :: size_of :: < x509write_csr > () , 32usize , concat ! ("Size of: " , stringify ! (x509write_csr))) ; assert_eq ! (:: core :: mem :: align_of :: < x509write_csr > () , 8usize , concat ! ("Alignment of " , stringify ! (x509write_csr))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_csr > ())) . key as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (x509write_csr) , "::" , stringify ! (key))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_csr > ())) . subject as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (x509write_csr) , "::" , stringify ! (subject))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_csr > ())) . md_alg as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (x509write_csr) , "::" , stringify ! (md_alg))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < x509write_csr > ())) . extensions as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (x509write_csr) , "::" , stringify ! (extensions))) ; } impl Default for x509write_csr { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_x509_csr_parse_der"] pub fn x509_csr_parse_der (csr : * mut x509_csr , buf : * const :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_csr_parse"] pub fn x509_csr_parse (csr : * mut x509_csr , buf : * const :: types :: raw_types :: c_uchar , buflen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_csr_parse_file"] pub fn x509_csr_parse_file (csr : * mut x509_csr , path : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_csr_info"] pub fn x509_csr_info (buf : * mut :: types :: raw_types :: c_char , size : size_t , prefix : * const :: types :: raw_types :: c_char , csr : * const x509_csr) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_csr_init"] pub fn x509_csr_init (csr : * mut x509_csr) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509_csr_free"] pub fn x509_csr_free (csr : * mut x509_csr) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_csr_init"] pub fn x509write_csr_init (ctx : * mut x509write_csr) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_csr_set_subject_name"] pub fn x509write_csr_set_subject_name (ctx : * mut x509write_csr , subject_name : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_csr_set_key"] pub fn x509write_csr_set_key (ctx : * mut x509write_csr , key : * mut pk_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_csr_set_md_alg"] pub fn x509write_csr_set_md_alg (ctx : * mut x509write_csr , md_alg : md_type_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_csr_set_key_usage"] pub fn x509write_csr_set_key_usage (ctx : * mut x509write_csr , key_usage : :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_csr_set_ns_cert_type"] pub fn x509write_csr_set_ns_cert_type (ctx : * mut x509write_csr , ns_cert_type : :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_csr_set_extension"] pub fn x509write_csr_set_extension (ctx : * mut x509write_csr , oid : * const :: types :: raw_types :: c_char , oid_len : size_t , val : * const :: types :: raw_types :: c_uchar , val_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_csr_free"] pub fn x509write_csr_free (ctx : * mut x509write_csr) ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_csr_der"] pub fn x509write_csr_der (ctx : * mut x509write_csr , buf : * mut :: types :: raw_types :: c_uchar , size : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_x509write_csr_pem"] pub fn x509write_csr_pem (ctx : * mut x509write_csr , buf : * mut :: types :: raw_types :: c_uchar , size : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_version_get_number"] pub fn version_get_number () -> :: types :: raw_types :: c_uint ; } extern "C" { # [link_name = "\u{1}mbedtls_version_get_string"] pub fn version_get_string (string : * mut :: types :: raw_types :: c_char) ; } extern "C" { # [link_name = "\u{1}mbedtls_version_get_string_full"] pub fn version_get_string_full (string : * mut :: types :: raw_types :: c_char) ; } extern "C" { # [link_name = "\u{1}mbedtls_version_check_feature"] pub fn version_check_feature (feature : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Default , Copy , Clone)] pub struct timing_hr_time { pub opaque : [:: types :: raw_types :: c_uchar ; 32usize] , } # [test] fn bindgen_test_layout_timing_hr_time () { assert_eq ! (:: core :: mem :: size_of :: < timing_hr_time > () , 32usize , concat ! ("Size of: " , stringify ! (timing_hr_time))) ; assert_eq ! (:: core :: mem :: align_of :: < timing_hr_time > () , 1usize , concat ! ("Alignment of " , stringify ! (timing_hr_time))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < timing_hr_time > ())) . opaque as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (timing_hr_time) , "::" , stringify ! (opaque))) ; } # [repr (C)] # [derive (Copy , Clone)] pub struct timing_delay_context { pub timer : timing_hr_time , pub int_ms : u32 , pub fin_ms : u32 , } # [test] fn bindgen_test_layout_timing_delay_context () { assert_eq ! (:: core :: mem :: size_of :: < timing_delay_context > () , 40usize , concat ! ("Size of: " , stringify ! (timing_delay_context))) ; assert_eq ! (:: core :: mem :: align_of :: < timing_delay_context > () , 4usize , concat ! ("Alignment of " , stringify ! (timing_delay_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < timing_delay_context > ())) . timer as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (timing_delay_context) , "::" , stringify ! (timer))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < timing_delay_context > ())) . int_ms as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (timing_delay_context) , "::" , stringify ! (int_ms))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < timing_delay_context > ())) . fin_ms as * const _ as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (timing_delay_context) , "::" , stringify ! (fin_ms))) ; } impl Default for timing_delay_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_timing_alarmed"] pub static mut timing_alarmed : :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_timing_hardclock"] pub fn timing_hardclock () -> :: types :: raw_types :: c_ulong ; } extern "C" { # [link_name = "\u{1}mbedtls_timing_get_timer"] pub fn timing_get_timer (val : * mut timing_hr_time , reset : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_ulong ; } extern "C" { # [link_name = "\u{1}mbedtls_set_alarm"] pub fn set_alarm (seconds : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_timing_set_delay"] pub fn timing_set_delay (data : * mut :: types :: raw_types :: c_void , int_ms : u32 , fin_ms : u32) ; } extern "C" { # [link_name = "\u{1}mbedtls_timing_get_delay"] pub fn timing_get_delay (data : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_timing_self_test"] pub fn timing_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_ticket_key { pub name : [:: types :: raw_types :: c_uchar ; 4usize] , pub generation_time : u32 , pub ctx : cipher_context_t , } # [test] fn bindgen_test_layout_ssl_ticket_key () { assert_eq ! (:: core :: mem :: size_of :: < ssl_ticket_key > () , 104usize , concat ! ("Size of: " , stringify ! (ssl_ticket_key))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_ticket_key > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_ticket_key))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ticket_key > ())) . name as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_ticket_key) , "::" , stringify ! (name))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ticket_key > ())) . generation_time as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (ssl_ticket_key) , "::" , stringify ! (generation_time))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ticket_key > ())) . ctx as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_ticket_key) , "::" , stringify ! (ctx))) ; } impl Default for ssl_ticket_key { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_ticket_context { pub keys : [ssl_ticket_key ; 2usize] , pub active : :: types :: raw_types :: c_uchar , pub ticket_lifetime : u32 , pub f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , pub p_rng : * mut :: types :: raw_types :: c_void , pub mutex : threading_mutex_t , } # [test] fn bindgen_test_layout_ssl_ticket_context () { assert_eq ! (:: core :: mem :: size_of :: < ssl_ticket_context > () , 280usize , concat ! ("Size of: " , stringify ! (ssl_ticket_context))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_ticket_context > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_ticket_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ticket_context > ())) . keys as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_ticket_context) , "::" , stringify ! (keys))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ticket_context > ())) . active as * const _ as usize } , 208usize , concat ! ("Offset of field: " , stringify ! (ssl_ticket_context) , "::" , stringify ! (active))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ticket_context > ())) . ticket_lifetime as * const _ as usize } , 212usize , concat ! ("Offset of field: " , stringify ! (ssl_ticket_context) , "::" , stringify ! (ticket_lifetime))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ticket_context > ())) . f_rng as * const _ as usize } , 216usize , concat ! ("Offset of field: " , stringify ! (ssl_ticket_context) , "::" , stringify ! (f_rng))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ticket_context > ())) . p_rng as * const _ as usize } , 224usize , concat ! ("Offset of field: " , stringify ! (ssl_ticket_context) , "::" , stringify ! (p_rng))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_ticket_context > ())) . mutex as * const _ as usize } , 232usize , concat ! ("Offset of field: " , stringify ! (ssl_ticket_context) , "::" , stringify ! (mutex))) ; } impl Default for ssl_ticket_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_ssl_ticket_init"] pub fn ssl_ticket_init (ctx : * mut ssl_ticket_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_ticket_setup"] pub fn ssl_ticket_setup (ctx : * mut ssl_ticket_context , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void , cipher : cipher_type_t , lifetime : u32) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_ticket_write"] pub fn ssl_ticket_write (p_ticket : * mut :: types :: raw_types :: c_void , session : * const ssl_session , start : * mut :: types :: raw_types :: c_uchar , end : * const :: types :: raw_types :: c_uchar , tlen : * mut size_t , lifetime : * mut u32) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_ticket_parse"] pub fn ssl_ticket_parse (p_ticket : * mut :: types :: raw_types :: c_void , session : * mut ssl_session , buf : * mut :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_ticket_free"] pub fn ssl_ticket_free (ctx : * mut ssl_ticket_context) ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_sig_hash_set_t { pub rsa : md_type_t , pub ecdsa : md_type_t , } # [test] fn bindgen_test_layout_ssl_sig_hash_set_t () { assert_eq ! (:: core :: mem :: size_of :: < ssl_sig_hash_set_t > () , 8usize , concat ! ("Size of: " , stringify ! (ssl_sig_hash_set_t))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_sig_hash_set_t > () , 4usize , concat ! ("Alignment of " , stringify ! (ssl_sig_hash_set_t))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_sig_hash_set_t > ())) . rsa as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_sig_hash_set_t) , "::" , stringify ! (rsa))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_sig_hash_set_t > ())) . ecdsa as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (ssl_sig_hash_set_t) , "::" , stringify ! (ecdsa))) ; } impl Default for ssl_sig_hash_set_t { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } pub type ssl_tls_prf_cb = :: core :: option :: Option < unsafe extern "C" fn (secret : * const :: types :: raw_types :: c_uchar , slen : size_t , label : * const :: types :: raw_types :: c_char , random : * const :: types :: raw_types :: c_uchar , rlen : size_t , dstbuf : * mut :: types :: raw_types :: c_uchar , dlen : size_t) -> :: types :: raw_types :: c_int > ; # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_key_set { pub client_write_key : [:: types :: raw_types :: c_uchar ; 32usize] , pub server_write_key : [:: types :: raw_types :: c_uchar ; 32usize] , pub client_write_iv : [:: types :: raw_types :: c_uchar ; 16usize] , pub server_write_iv : [:: types :: raw_types :: c_uchar ; 16usize] , pub key_len : size_t , pub iv_len : size_t , } # [test] fn bindgen_test_layout_ssl_key_set () { assert_eq ! (:: core :: mem :: size_of :: < ssl_key_set > () , 112usize , concat ! ("Size of: " , stringify ! (ssl_key_set))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_key_set > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_key_set))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_key_set > ())) . client_write_key as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_key_set) , "::" , stringify ! (client_write_key))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_key_set > ())) . server_write_key as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (ssl_key_set) , "::" , stringify ! (server_write_key))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_key_set > ())) . client_write_iv as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (ssl_key_set) , "::" , stringify ! (client_write_iv))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_key_set > ())) . server_write_iv as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (ssl_key_set) , "::" , stringify ! (server_write_iv))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_key_set > ())) . key_len as * const _ as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (ssl_key_set) , "::" , stringify ! (key_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_key_set > ())) . iv_len as * const _ as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (ssl_key_set) , "::" , stringify ! (iv_len))) ; } impl Default for ssl_key_set { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_handshake_params { pub max_major_ver : u8 , pub max_minor_ver : u8 , pub resume : u8 , pub cli_exts : u8 , pub sni_authmode : u8 , pub new_session_ticket : u8 , pub extended_ms : u8 , pub retransmit_state : :: types :: raw_types :: c_uchar , pub hash_algs : ssl_sig_hash_set_t , pub pmslen : size_t , pub ciphersuite_info : * const ssl_ciphersuite_t , pub update_checksum : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut ssl_context , arg2 : * const :: types :: raw_types :: c_uchar , arg3 : size_t) > , pub calc_verify : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * const ssl_context , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : * mut size_t) > , pub calc_finished : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut ssl_context , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : :: types :: raw_types :: c_int) > , pub tls_prf : ssl_tls_prf_cb , pub dhm_ctx : dhm_context , pub ecdh_ctx : ecdh_context , pub curves : * mut * const ecp_curve_info , pub psk : * mut :: types :: raw_types :: c_uchar , pub psk_len : size_t , pub key_cert : * mut ssl_key_cert , pub sni_key_cert : * mut ssl_key_cert , pub sni_ca_chain : * mut x509_crt , pub sni_ca_crl : * mut x509_crl , pub buffering : ssl_handshake_params__bindgen_ty_1 , pub out_msg_seq : :: types :: raw_types :: c_uint , pub in_msg_seq : :: types :: raw_types :: c_uint , pub verify_cookie : * mut :: types :: raw_types :: c_uchar , pub verify_cookie_len : :: types :: raw_types :: c_uchar , pub retransmit_timeout : u32 , pub flight : * mut ssl_flight_item , pub cur_msg : * mut ssl_flight_item , pub cur_msg_p : * mut :: types :: raw_types :: c_uchar , pub in_flight_start_seq : :: types :: raw_types :: c_uint , pub alt_transform_out : * mut ssl_transform , pub alt_out_ctr : [:: types :: raw_types :: c_uchar ; 8usize] , pub mtu : u16 , pub fin_sha256 : sha256_context , pub fin_sha512 : sha512_context , pub randbytes : [:: types :: raw_types :: c_uchar ; 64usize] , pub premaster : [:: types :: raw_types :: c_uchar ; 1060usize] , } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_handshake_params__bindgen_ty_1 { pub total_bytes_buffered : size_t , pub seen_ccs : u8 , pub hs : [ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer ; 4usize] , pub future_record : ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer { pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub data : * mut :: types :: raw_types :: c_uchar , pub data_len : size_t , } # [test] fn bindgen_test_layout_ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer () { assert_eq ! (:: core :: mem :: size_of :: < ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer > () , 24usize , concat ! ("Size of: " , stringify ! (ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer > ())) . data as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer) , "::" , stringify ! (data))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer > ())) . data_len as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer) , "::" , stringify ! (data_len))) ; } impl Default for ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } impl ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer { # [inline] pub fn is_valid (& self) -> :: types :: raw_types :: c_uint { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_is_valid (& mut self , val : :: types :: raw_types :: c_uint) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn is_fragmented (& self) -> :: types :: raw_types :: c_uint { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_is_fragmented (& mut self , val : :: types :: raw_types :: c_uint) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn is_complete (& self) -> :: types :: raw_types :: c_uint { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u32) } } # [inline] pub fn set_is_complete (& mut self , val : :: types :: raw_types :: c_uint) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (is_valid : :: types :: raw_types :: c_uint , is_fragmented : :: types :: raw_types :: c_uint , is_complete : :: types :: raw_types :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let is_valid : u32 = unsafe { :: core :: mem :: transmute (is_valid) } ; is_valid as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let is_fragmented : u32 = unsafe { :: core :: mem :: transmute (is_fragmented) } ; is_fragmented as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let is_complete : u32 = unsafe { :: core :: mem :: transmute (is_complete) } ; is_complete as u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 { pub data : * mut :: types :: raw_types :: c_uchar , pub len : size_t , pub epoch : :: types :: raw_types :: c_uint , } # [test] fn bindgen_test_layout_ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 > () , 24usize , concat ! ("Size of: " , stringify ! (ssl_handshake_params__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_handshake_params__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 > ())) . data as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (data))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 > ())) . len as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 > ())) . epoch as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (epoch))) ; } impl Default for ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [test] fn bindgen_test_layout_ssl_handshake_params__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < ssl_handshake_params__bindgen_ty_1 > () , 136usize , concat ! ("Size of: " , stringify ! (ssl_handshake_params__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_handshake_params__bindgen_ty_1 > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_handshake_params__bindgen_ty_1))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params__bindgen_ty_1 > ())) . total_bytes_buffered as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params__bindgen_ty_1) , "::" , stringify ! (total_bytes_buffered))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params__bindgen_ty_1 > ())) . seen_ccs as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params__bindgen_ty_1) , "::" , stringify ! (seen_ccs))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params__bindgen_ty_1 > ())) . hs as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params__bindgen_ty_1) , "::" , stringify ! (hs))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params__bindgen_ty_1 > ())) . future_record as * const _ as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params__bindgen_ty_1) , "::" , stringify ! (future_record))) ; } impl Default for ssl_handshake_params__bindgen_ty_1 { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [test] fn bindgen_test_layout_ssl_handshake_params () { assert_eq ! (:: core :: mem :: size_of :: < ssl_handshake_params > () , 2648usize , concat ! ("Size of: " , stringify ! (ssl_handshake_params))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_handshake_params > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_handshake_params))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . max_major_ver as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (max_major_ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . max_minor_ver as * const _ as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (max_minor_ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . resume as * const _ as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (resume))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . cli_exts as * const _ as usize } , 3usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (cli_exts))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . sni_authmode as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (sni_authmode))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . new_session_ticket as * const _ as usize } , 5usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (new_session_ticket))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . extended_ms as * const _ as usize } , 6usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (extended_ms))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . retransmit_state as * const _ as usize } , 7usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (retransmit_state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . hash_algs as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (hash_algs))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . pmslen as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (pmslen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . ciphersuite_info as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (ciphersuite_info))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . update_checksum as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (update_checksum))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . calc_verify as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (calc_verify))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . calc_finished as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (calc_finished))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . tls_prf as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (tls_prf))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . dhm_ctx as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (dhm_ctx))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . ecdh_ctx as * const _ as usize } , 312usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (ecdh_ctx))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . curves as * const _ as usize } , 928usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (curves))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . psk as * const _ as usize } , 936usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (psk))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . psk_len as * const _ as usize } , 944usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (psk_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . key_cert as * const _ as usize } , 952usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (key_cert))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . sni_key_cert as * const _ as usize } , 960usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (sni_key_cert))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . sni_ca_chain as * const _ as usize } , 968usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (sni_ca_chain))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . sni_ca_crl as * const _ as usize } , 976usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (sni_ca_crl))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . buffering as * const _ as usize } , 984usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (buffering))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . out_msg_seq as * const _ as usize } , 1120usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (out_msg_seq))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . in_msg_seq as * const _ as usize } , 1124usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (in_msg_seq))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . verify_cookie as * const _ as usize } , 1128usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (verify_cookie))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . verify_cookie_len as * const _ as usize } , 1136usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (verify_cookie_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . retransmit_timeout as * const _ as usize } , 1140usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (retransmit_timeout))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . flight as * const _ as usize } , 1144usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (flight))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . cur_msg as * const _ as usize } , 1152usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (cur_msg))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . cur_msg_p as * const _ as usize } , 1160usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (cur_msg_p))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . in_flight_start_seq as * const _ as usize } , 1168usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (in_flight_start_seq))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . alt_transform_out as * const _ as usize } , 1176usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (alt_transform_out))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . alt_out_ctr as * const _ as usize } , 1184usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (alt_out_ctr))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . mtu as * const _ as usize } , 1192usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (mtu))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . fin_sha256 as * const _ as usize } , 1196usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (fin_sha256))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . fin_sha512 as * const _ as usize } , 1304usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (fin_sha512))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . randbytes as * const _ as usize } , 1520usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (randbytes))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_handshake_params > ())) . premaster as * const _ as usize } , 1584usize , concat ! ("Offset of field: " , stringify ! (ssl_handshake_params) , "::" , stringify ! (premaster))) ; } impl Default for ssl_handshake_params { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } pub type ssl_hs_buffer = ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer ; # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_transform { pub minlen : size_t , pub ivlen : size_t , pub fixed_ivlen : size_t , pub maclen : size_t , pub taglen : size_t , pub iv_enc : [:: types :: raw_types :: c_uchar ; 16usize] , pub iv_dec : [:: types :: raw_types :: c_uchar ; 16usize] , pub md_ctx_enc : md_context_t , pub md_ctx_dec : md_context_t , pub encrypt_then_mac : :: types :: raw_types :: c_int , pub cipher_ctx_enc : cipher_context_t , pub cipher_ctx_dec : cipher_context_t , pub minor_ver : :: types :: raw_types :: c_int , pub randbytes : [:: types :: raw_types :: c_uchar ; 64usize] , } # [test] fn bindgen_test_layout_ssl_transform () { assert_eq ! (:: core :: mem :: size_of :: < ssl_transform > () , 392usize , concat ! ("Size of: " , stringify ! (ssl_transform))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_transform > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_transform))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . minlen as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (minlen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . ivlen as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (ivlen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . fixed_ivlen as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (fixed_ivlen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . maclen as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (maclen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . taglen as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (taglen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . iv_enc as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (iv_enc))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . iv_dec as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (iv_dec))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . md_ctx_enc as * const _ as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (md_ctx_enc))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . md_ctx_dec as * const _ as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (md_ctx_dec))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . encrypt_then_mac as * const _ as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (encrypt_then_mac))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . cipher_ctx_enc as * const _ as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (cipher_ctx_enc))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . cipher_ctx_dec as * const _ as usize } , 224usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (cipher_ctx_dec))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . minor_ver as * const _ as usize } , 320usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (minor_ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_transform > ())) . randbytes as * const _ as usize } , 324usize , concat ! ("Offset of field: " , stringify ! (ssl_transform) , "::" , stringify ! (randbytes))) ; } impl Default for ssl_transform { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct record { pub ctr : [u8 ; 8usize] , pub type_ : u8 , pub ver : [u8 ; 2usize] , pub buf : * mut :: types :: raw_types :: c_uchar , pub buf_len : size_t , pub data_offset : size_t , pub data_len : size_t , } # [test] fn bindgen_test_layout_record () { assert_eq ! (:: core :: mem :: size_of :: < record > () , 48usize , concat ! ("Size of: " , stringify ! (record))) ; assert_eq ! (:: core :: mem :: align_of :: < record > () , 8usize , concat ! ("Alignment of " , stringify ! (record))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < record > ())) . ctr as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (record) , "::" , stringify ! (ctr))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < record > ())) . type_ as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (record) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < record > ())) . ver as * const _ as usize } , 9usize , concat ! ("Offset of field: " , stringify ! (record) , "::" , stringify ! (ver))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < record > ())) . buf as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (record) , "::" , stringify ! (buf))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < record > ())) . buf_len as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (record) , "::" , stringify ! (buf_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < record > ())) . data_offset as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (record) , "::" , stringify ! (data_offset))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < record > ())) . data_len as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (record) , "::" , stringify ! (data_len))) ; } impl Default for record { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_key_cert { pub cert : * mut x509_crt , pub key : * mut pk_context , pub next : * mut ssl_key_cert , } # [test] fn bindgen_test_layout_ssl_key_cert () { assert_eq ! (:: core :: mem :: size_of :: < ssl_key_cert > () , 24usize , concat ! ("Size of: " , stringify ! (ssl_key_cert))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_key_cert > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_key_cert))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_key_cert > ())) . cert as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_key_cert) , "::" , stringify ! (cert))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_key_cert > ())) . key as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_key_cert) , "::" , stringify ! (key))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_key_cert > ())) . next as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (ssl_key_cert) , "::" , stringify ! (next))) ; } impl Default for ssl_key_cert { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_flight_item { pub p : * mut :: types :: raw_types :: c_uchar , pub len : size_t , pub type_ : :: types :: raw_types :: c_uchar , pub next : * mut ssl_flight_item , } # [test] fn bindgen_test_layout_ssl_flight_item () { assert_eq ! (:: core :: mem :: size_of :: < ssl_flight_item > () , 32usize , concat ! ("Size of: " , stringify ! (ssl_flight_item))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_flight_item > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_flight_item))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_flight_item > ())) . p as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_flight_item) , "::" , stringify ! (p))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_flight_item > ())) . len as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_flight_item) , "::" , stringify ! (len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_flight_item > ())) . type_ as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (ssl_flight_item) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_flight_item > ())) . next as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (ssl_flight_item) , "::" , stringify ! (next))) ; } impl Default for ssl_flight_item { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_ssl_sig_hash_set_find"] pub fn ssl_sig_hash_set_find (set : * mut ssl_sig_hash_set_t , sig_alg : pk_type_t) -> md_type_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_sig_hash_set_add"] pub fn ssl_sig_hash_set_add (set : * mut ssl_sig_hash_set_t , sig_alg : pk_type_t , md_alg : md_type_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_sig_hash_set_const_hash"] pub fn ssl_sig_hash_set_const_hash (set : * mut ssl_sig_hash_set_t , md_alg : md_type_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_transform_free"] pub fn ssl_transform_free (transform : * mut ssl_transform) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_handshake_free"] pub fn ssl_handshake_free (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_handshake_client_step"] pub fn ssl_handshake_client_step (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_handshake_server_step"] pub fn ssl_handshake_server_step (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_handshake_wrapup"] pub fn ssl_handshake_wrapup (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_send_fatal_handshake_failure"] pub fn ssl_send_fatal_handshake_failure (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_reset_checksum"] pub fn ssl_reset_checksum (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_derive_keys"] pub fn ssl_derive_keys (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_handle_message_type"] pub fn ssl_handle_message_type (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_prepare_handshake_record"] pub fn ssl_prepare_handshake_record (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_update_handshake_status"] pub fn ssl_update_handshake_status (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_read_record"] pub fn ssl_read_record (ssl : * mut ssl_context , update_hs_digest : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_fetch_input"] pub fn ssl_fetch_input (ssl : * mut ssl_context , nb_want : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_write_handshake_msg"] pub fn ssl_write_handshake_msg (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_write_record"] pub fn ssl_write_record (ssl : * mut ssl_context , force_flush : u8) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_flush_output"] pub fn ssl_flush_output (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_parse_certificate"] pub fn ssl_parse_certificate (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_write_certificate"] pub fn ssl_write_certificate (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_parse_change_cipher_spec"] pub fn ssl_parse_change_cipher_spec (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_write_change_cipher_spec"] pub fn ssl_write_change_cipher_spec (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_parse_finished"] pub fn ssl_parse_finished (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_write_finished"] pub fn ssl_write_finished (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_optimize_checksum"] pub fn ssl_optimize_checksum (ssl : * mut ssl_context , ciphersuite_info : * const ssl_ciphersuite_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_psk_derive_premaster"] pub fn ssl_psk_derive_premaster (ssl : * mut ssl_context , key_ex : key_exchange_type_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_sig_from_pk"] pub fn ssl_sig_from_pk (pk : * mut pk_context) -> :: types :: raw_types :: c_uchar ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_sig_from_pk_alg"] pub fn ssl_sig_from_pk_alg (type_ : pk_type_t) -> :: types :: raw_types :: c_uchar ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_pk_alg_from_sig"] pub fn ssl_pk_alg_from_sig (sig : :: types :: raw_types :: c_uchar) -> pk_type_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_md_alg_from_hash"] pub fn ssl_md_alg_from_hash (hash : :: types :: raw_types :: c_uchar) -> md_type_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_hash_from_md_alg"] pub fn ssl_hash_from_md_alg (md : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_uchar ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_calc_verify_md"] pub fn ssl_set_calc_verify_md (ssl : * mut ssl_context , md : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_check_curve"] pub fn ssl_check_curve (ssl : * const ssl_context , grp_id : ecp_group_id) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_check_sig_hash"] pub fn ssl_check_sig_hash (ssl : * const ssl_context , md : md_type_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_check_cert_usage"] pub fn ssl_check_cert_usage (cert : * const x509_crt , ciphersuite : * const ssl_ciphersuite_t , cert_endpoint : :: types :: raw_types :: c_int , flags : * mut u32) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_write_version"] pub fn ssl_write_version (major : :: types :: raw_types :: c_int , minor : :: types :: raw_types :: c_int , transport : :: types :: raw_types :: c_int , ver : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_read_version"] pub fn ssl_read_version (major : * mut :: types :: raw_types :: c_int , minor : * mut :: types :: raw_types :: c_int , transport : :: types :: raw_types :: c_int , ver : * const :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_send_flight_completed"] pub fn ssl_send_flight_completed (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_recv_flight_completed"] pub fn ssl_recv_flight_completed (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_resend"] pub fn ssl_resend (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_flight_transmit"] pub fn ssl_flight_transmit (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_dtls_replay_check"] pub fn ssl_dtls_replay_check (ssl : * const ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_dtls_replay_update"] pub fn ssl_dtls_replay_update (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_session_copy"] pub fn ssl_session_copy (dst : * mut ssl_session , src : * const ssl_session) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_key_exchange_md_tls1_2"] pub fn ssl_get_key_exchange_md_tls1_2 (ssl : * mut ssl_context , hash : * mut :: types :: raw_types :: c_uchar , hashlen : * mut size_t , data : * mut :: types :: raw_types :: c_uchar , data_len : size_t , md_alg : md_type_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_transform_init"] pub fn ssl_transform_init (transform : * mut ssl_transform) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_encrypt_buf"] pub fn ssl_encrypt_buf (ssl : * mut ssl_context , transform : * mut ssl_transform , rec : * mut record , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_decrypt_buf"] pub fn ssl_decrypt_buf (ssl : * const ssl_context , transform : * mut ssl_transform , rec : * mut record) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_resend_hello_request"] pub fn ssl_resend_hello_request (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_set_timer"] pub fn ssl_set_timer (ssl : * mut ssl_context , millisecs : u32) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_check_timer"] pub fn ssl_check_timer (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_reset_in_out_pointers"] pub fn ssl_reset_in_out_pointers (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_update_out_pointers"] pub fn ssl_update_out_pointers (ssl : * mut ssl_context , transform : * mut ssl_transform) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_update_in_pointers"] pub fn ssl_update_in_pointers (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_session_reset_int"] pub fn ssl_session_reset_int (ssl : * mut ssl_context , partial : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_dtls_replay_reset"] pub fn ssl_dtls_replay_reset (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_handshake_wrapup_free_hs_transform"] pub fn ssl_handshake_wrapup_free_hs_transform (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_start_renegotiation"] pub fn ssl_start_renegotiation (ssl : * mut ssl_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_get_current_mtu"] pub fn ssl_get_current_mtu (ssl : * const ssl_context) -> size_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_buffering_free"] pub fn ssl_buffering_free (ssl : * mut ssl_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_flight_free"] pub fn ssl_flight_free (flight : * mut ssl_flight_item) ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_cookie_ctx { pub hmac_ctx : md_context_t , pub timeout : :: types :: raw_types :: c_ulong , pub mutex : threading_mutex_t , } # [test] fn bindgen_test_layout_ssl_cookie_ctx () { assert_eq ! (:: core :: mem :: size_of :: < ssl_cookie_ctx > () , 80usize , concat ! ("Size of: " , stringify ! (ssl_cookie_ctx))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_cookie_ctx > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_cookie_ctx))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_cookie_ctx > ())) . hmac_ctx as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_cookie_ctx) , "::" , stringify ! (hmac_ctx))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_cookie_ctx > ())) . timeout as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (ssl_cookie_ctx) , "::" , stringify ! (timeout))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_cookie_ctx > ())) . mutex as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (ssl_cookie_ctx) , "::" , stringify ! (mutex))) ; } impl Default for ssl_cookie_ctx { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_ssl_cookie_init"] pub fn ssl_cookie_init (ctx : * mut ssl_cookie_ctx) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_cookie_setup"] pub fn ssl_cookie_setup (ctx : * mut ssl_cookie_ctx , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_cookie_set_timeout"] pub fn ssl_cookie_set_timeout (ctx : * mut ssl_cookie_ctx , delay : :: types :: raw_types :: c_ulong) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_cookie_free"] pub fn ssl_cookie_free (ctx : * mut ssl_cookie_ctx) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_cookie_write"] pub fn ssl_cookie_write (ctx : * mut :: types :: raw_types :: c_void , p : * mut * mut :: types :: raw_types :: c_uchar , end : * mut :: types :: raw_types :: c_uchar , info : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_cookie_check"] pub fn ssl_cookie_check (ctx : * mut :: types :: raw_types :: c_void , cookie : * const :: types :: raw_types :: c_uchar , clen : size_t , info : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_cache_entry { pub timestamp : time_t , pub session : ssl_session , pub peer_cert : x509_buf , pub next : * mut ssl_cache_entry , } # [test] fn bindgen_test_layout_ssl_cache_entry () { assert_eq ! (:: core :: mem :: size_of :: < ssl_cache_entry > () , 200usize , concat ! ("Size of: " , stringify ! (ssl_cache_entry))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_cache_entry > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_cache_entry))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_cache_entry > ())) . timestamp as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_cache_entry) , "::" , stringify ! (timestamp))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_cache_entry > ())) . session as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_cache_entry) , "::" , stringify ! (session))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_cache_entry > ())) . peer_cert as * const _ as usize } , 168usize , concat ! ("Offset of field: " , stringify ! (ssl_cache_entry) , "::" , stringify ! (peer_cert))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_cache_entry > ())) . next as * const _ as usize } , 192usize , concat ! ("Offset of field: " , stringify ! (ssl_cache_entry) , "::" , stringify ! (next))) ; } impl Default for ssl_cache_entry { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct ssl_cache_context { pub chain : * mut ssl_cache_entry , pub timeout : :: types :: raw_types :: c_int , pub max_entries : :: types :: raw_types :: c_int , pub mutex : threading_mutex_t , } # [test] fn bindgen_test_layout_ssl_cache_context () { assert_eq ! (:: core :: mem :: size_of :: < ssl_cache_context > () , 64usize , concat ! ("Size of: " , stringify ! (ssl_cache_context))) ; assert_eq ! (:: core :: mem :: align_of :: < ssl_cache_context > () , 8usize , concat ! ("Alignment of " , stringify ! (ssl_cache_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_cache_context > ())) . chain as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ssl_cache_context) , "::" , stringify ! (chain))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_cache_context > ())) . timeout as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ssl_cache_context) , "::" , stringify ! (timeout))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_cache_context > ())) . max_entries as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (ssl_cache_context) , "::" , stringify ! (max_entries))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ssl_cache_context > ())) . mutex as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (ssl_cache_context) , "::" , stringify ! (mutex))) ; } impl Default for ssl_cache_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_ssl_cache_init"] pub fn ssl_cache_init (cache : * mut ssl_cache_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_cache_get"] pub fn ssl_cache_get (data : * mut :: types :: raw_types :: c_void , session : * mut ssl_session) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_cache_set"] pub fn ssl_cache_set (data : * mut :: types :: raw_types :: c_void , session : * const ssl_session) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_cache_set_timeout"] pub fn ssl_cache_set_timeout (cache : * mut ssl_cache_context , timeout : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_cache_set_max_entries"] pub fn ssl_cache_set_max_entries (cache : * mut ssl_cache_context , max : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_ssl_cache_free"] pub fn ssl_cache_free (cache : * mut ssl_cache_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_deduce_primes"] pub fn rsa_deduce_primes (N : * const mpi , E : * const mpi , D : * const mpi , P : * mut mpi , Q : * mut mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_deduce_private_exponent"] pub fn rsa_deduce_private_exponent (P : * const mpi , Q : * const mpi , E : * const mpi , D : * mut mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_deduce_crt"] pub fn rsa_deduce_crt (P : * const mpi , Q : * const mpi , D : * const mpi , DP : * mut mpi , DQ : * mut mpi , QP : * mut mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_validate_params"] pub fn rsa_validate_params (N : * const mpi , P : * const mpi , Q : * const mpi , D : * const mpi , E : * const mpi , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_validate_crt"] pub fn rsa_validate_crt (P : * const mpi , Q : * const mpi , D : * const mpi , DP : * const mpi , DQ : * const mpi , QP : * const mpi) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ripemd160_context { pub total : [u32 ; 2usize] , pub state : [u32 ; 5usize] , pub buffer : [:: types :: raw_types :: c_uchar ; 64usize] , } # [test] fn bindgen_test_layout_ripemd160_context () { assert_eq ! (:: core :: mem :: size_of :: < ripemd160_context > () , 92usize , concat ! ("Size of: " , stringify ! (ripemd160_context))) ; assert_eq ! (:: core :: mem :: align_of :: < ripemd160_context > () , 4usize , concat ! ("Alignment of " , stringify ! (ripemd160_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ripemd160_context > ())) . total as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ripemd160_context) , "::" , stringify ! (total))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ripemd160_context > ())) . state as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (ripemd160_context) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ripemd160_context > ())) . buffer as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (ripemd160_context) , "::" , stringify ! (buffer))) ; } impl Default for ripemd160_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160_init"] pub fn ripemd160_init (ctx : * mut ripemd160_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160_free"] pub fn ripemd160_free (ctx : * mut ripemd160_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160_clone"] pub fn ripemd160_clone (dst : * mut ripemd160_context , src : * const ripemd160_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160_starts_ret"] pub fn ripemd160_starts_ret (ctx : * mut ripemd160_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160_update_ret"] pub fn ripemd160_update_ret (ctx : * mut ripemd160_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160_finish_ret"] pub fn ripemd160_finish_ret (ctx : * mut ripemd160_context , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_internal_ripemd160_process"] pub fn internal_ripemd160_process (ctx : * mut ripemd160_context , data : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160_starts"] pub fn ripemd160_starts (ctx : * mut ripemd160_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160_update"] pub fn ripemd160_update (ctx : * mut ripemd160_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160_finish"] pub fn ripemd160_finish (ctx : * mut ripemd160_context , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160_process"] pub fn ripemd160_process (ctx : * mut ripemd160_context , data : * const :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160_ret"] pub fn ripemd160_ret (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160"] pub fn ripemd160 (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160_self_test"] pub fn ripemd160_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Default , Copy , Clone)] pub struct platform_context { pub dummy : :: types :: raw_types :: c_char , } # [test] fn bindgen_test_layout_platform_context () { assert_eq ! (:: core :: mem :: size_of :: < platform_context > () , 1usize , concat ! ("Size of: " , stringify ! (platform_context))) ; assert_eq ! (:: core :: mem :: align_of :: < platform_context > () , 1usize , concat ! ("Alignment of " , stringify ! (platform_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < platform_context > ())) . dummy as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (platform_context) , "::" , stringify ! (dummy))) ; } extern "C" { # [link_name = "\u{1}mbedtls_platform_setup"] pub fn platform_setup (ctx : * mut platform_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_platform_teardown"] pub fn platform_teardown (ctx : * mut platform_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_pkcs5_pbes2"] pub fn pkcs5_pbes2 (pbe_params : * const asn1_buf , mode : :: types :: raw_types :: c_int , pwd : * const :: types :: raw_types :: c_uchar , pwdlen : size_t , data : * const :: types :: raw_types :: c_uchar , datalen : size_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pkcs5_pbkdf2_hmac"] pub fn pkcs5_pbkdf2_hmac (ctx : * mut md_context_t , password : * const :: types :: raw_types :: c_uchar , plen : size_t , salt : * const :: types :: raw_types :: c_uchar , slen : size_t , iteration_count : :: types :: raw_types :: c_uint , key_length : u32 , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pkcs5_self_test"] pub fn pkcs5_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pkcs12_pbe_sha1_rc4_128"] pub fn pkcs12_pbe_sha1_rc4_128 (pbe_params : * mut asn1_buf , mode : :: types :: raw_types :: c_int , pwd : * const :: types :: raw_types :: c_uchar , pwdlen : size_t , input : * const :: types :: raw_types :: c_uchar , len : size_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pkcs12_pbe"] pub fn pkcs12_pbe (pbe_params : * mut asn1_buf , mode : :: types :: raw_types :: c_int , cipher_type : cipher_type_t , md_type : md_type_t , pwd : * const :: types :: raw_types :: c_uchar , pwdlen : size_t , input : * const :: types :: raw_types :: c_uchar , len : size_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pkcs12_derivation"] pub fn pkcs12_derivation (data : * mut :: types :: raw_types :: c_uchar , datalen : size_t , pwd : * const :: types :: raw_types :: c_uchar , pwdlen : size_t , salt : * const :: types :: raw_types :: c_uchar , saltlen : size_t , mbedtls_md : md_type_t , id : :: types :: raw_types :: c_int , iterations : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct pk_info_t { pub type_ : pk_type_t , pub name : * const :: types :: raw_types :: c_char , pub get_bitlen : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * const :: types :: raw_types :: c_void) -> size_t > , pub can_do : :: core :: option :: Option < unsafe extern "C" fn (type_ : pk_type_t) -> :: types :: raw_types :: c_int > , pub verify_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , md_alg : md_type_t , hash : * const :: types :: raw_types :: c_uchar , hash_len : size_t , sig : * const :: types :: raw_types :: c_uchar , sig_len : size_t) -> :: types :: raw_types :: c_int > , pub sign_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , md_alg : md_type_t , hash : * const :: types :: raw_types :: c_uchar , hash_len : size_t , sig : * mut :: types :: raw_types :: c_uchar , sig_len : * mut size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int > , pub decrypt_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , olen : * mut size_t , osize : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int > , pub encrypt_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar , olen : * mut size_t , osize : size_t , f_rng : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: types :: raw_types :: c_void , arg2 : * mut :: types :: raw_types :: c_uchar , arg3 : size_t) -> :: types :: raw_types :: c_int > , p_rng : * mut :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int > , pub check_pair_func : :: core :: option :: Option < unsafe extern "C" fn (pub_ : * const :: types :: raw_types :: c_void , prv : * const :: types :: raw_types :: c_void) -> :: types :: raw_types :: c_int > , pub ctx_alloc_func : :: core :: option :: Option < unsafe extern "C" fn () -> * mut :: types :: raw_types :: c_void > , pub ctx_free_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void) > , pub debug_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * const :: types :: raw_types :: c_void , items : * mut pk_debug_item) > , } # [test] fn bindgen_test_layout_pk_info_t () { assert_eq ! (:: core :: mem :: size_of :: < pk_info_t > () , 96usize , concat ! ("Size of: " , stringify ! (pk_info_t))) ; assert_eq ! (:: core :: mem :: align_of :: < pk_info_t > () , 8usize , concat ! ("Alignment of " , stringify ! (pk_info_t))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_info_t > ())) . type_ as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pk_info_t) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_info_t > ())) . name as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (pk_info_t) , "::" , stringify ! (name))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_info_t > ())) . get_bitlen as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (pk_info_t) , "::" , stringify ! (get_bitlen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_info_t > ())) . can_do as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (pk_info_t) , "::" , stringify ! (can_do))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_info_t > ())) . verify_func as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (pk_info_t) , "::" , stringify ! (verify_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_info_t > ())) . sign_func as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (pk_info_t) , "::" , stringify ! (sign_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_info_t > ())) . decrypt_func as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (pk_info_t) , "::" , stringify ! (decrypt_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_info_t > ())) . encrypt_func as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (pk_info_t) , "::" , stringify ! (encrypt_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_info_t > ())) . check_pair_func as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (pk_info_t) , "::" , stringify ! (check_pair_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_info_t > ())) . ctx_alloc_func as * const _ as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (pk_info_t) , "::" , stringify ! (ctx_alloc_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_info_t > ())) . ctx_free_func as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (pk_info_t) , "::" , stringify ! (ctx_free_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pk_info_t > ())) . debug_func as * const _ as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (pk_info_t) , "::" , stringify ! (debug_func))) ; } impl Default for pk_info_t { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct rsa_alt_context { pub key : * mut :: types :: raw_types :: c_void , pub decrypt_func : pk_rsa_alt_decrypt_func , pub sign_func : pk_rsa_alt_sign_func , pub key_len_func : pk_rsa_alt_key_len_func , } # [test] fn bindgen_test_layout_rsa_alt_context () { assert_eq ! (:: core :: mem :: size_of :: < rsa_alt_context > () , 32usize , concat ! ("Size of: " , stringify ! (rsa_alt_context))) ; assert_eq ! (:: core :: mem :: align_of :: < rsa_alt_context > () , 8usize , concat ! ("Alignment of " , stringify ! (rsa_alt_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_alt_context > ())) . key as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (rsa_alt_context) , "::" , stringify ! (key))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_alt_context > ())) . decrypt_func as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (rsa_alt_context) , "::" , stringify ! (decrypt_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_alt_context > ())) . sign_func as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (rsa_alt_context) , "::" , stringify ! (sign_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < rsa_alt_context > ())) . key_len_func as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (rsa_alt_context) , "::" , stringify ! (key_len_func))) ; } impl Default for rsa_alt_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_rsa_info"] pub static rsa_info : pk_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_eckey_info"] pub static eckey_info : pk_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_eckeydh_info"] pub static eckeydh_info : pk_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ecdsa_info"] pub static ecdsa_info : pk_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_rsa_alt_info"] pub static rsa_alt_info : pk_info_t ; } # [repr (C)] # [derive (Copy , Clone)] pub struct pem_context { pub buf : * mut :: types :: raw_types :: c_uchar , pub buflen : size_t , pub info : * mut :: types :: raw_types :: c_uchar , } # [test] fn bindgen_test_layout_pem_context () { assert_eq ! (:: core :: mem :: size_of :: < pem_context > () , 24usize , concat ! ("Size of: " , stringify ! (pem_context))) ; assert_eq ! (:: core :: mem :: align_of :: < pem_context > () , 8usize , concat ! ("Alignment of " , stringify ! (pem_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pem_context > ())) . buf as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (pem_context) , "::" , stringify ! (buf))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pem_context > ())) . buflen as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (pem_context) , "::" , stringify ! (buflen))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < pem_context > ())) . info as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (pem_context) , "::" , stringify ! (info))) ; } impl Default for pem_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_pem_init"] pub fn pem_init (ctx : * mut pem_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_pem_read_buffer"] pub fn pem_read_buffer (ctx : * mut pem_context , header : * const :: types :: raw_types :: c_char , footer : * const :: types :: raw_types :: c_char , data : * const :: types :: raw_types :: c_uchar , pwd : * const :: types :: raw_types :: c_uchar , pwdlen : size_t , use_len : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_pem_free"] pub fn pem_free (ctx : * mut pem_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_pem_write_buffer"] pub fn pem_write_buffer (header : * const :: types :: raw_types :: c_char , footer : * const :: types :: raw_types :: c_char , der_data : * const :: types :: raw_types :: c_uchar , der_len : size_t , buf : * mut :: types :: raw_types :: c_uchar , buf_len : size_t , olen : * mut size_t) -> :: types :: raw_types :: c_int ; } pub const KW_MODE_KW : nist_kw_mode_t = 0 ; pub const KW_MODE_KWP : nist_kw_mode_t = 1 ; pub type nist_kw_mode_t = u32 ; # [repr (C)] # [derive (Copy , Clone)] pub struct nist_kw_context { pub cipher_ctx : cipher_context_t , } # [test] fn bindgen_test_layout_nist_kw_context () { assert_eq ! (:: core :: mem :: size_of :: < nist_kw_context > () , 96usize , concat ! ("Size of: " , stringify ! (nist_kw_context))) ; assert_eq ! (:: core :: mem :: align_of :: < nist_kw_context > () , 8usize , concat ! ("Alignment of " , stringify ! (nist_kw_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < nist_kw_context > ())) . cipher_ctx as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (nist_kw_context) , "::" , stringify ! (cipher_ctx))) ; } impl Default for nist_kw_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_nist_kw_init"] pub fn nist_kw_init (ctx : * mut nist_kw_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_nist_kw_setkey"] pub fn nist_kw_setkey (ctx : * mut nist_kw_context , cipher : cipher_id_t , key : * const :: types :: raw_types :: c_uchar , keybits : :: types :: raw_types :: c_uint , is_wrap : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_nist_kw_free"] pub fn nist_kw_free (ctx : * mut nist_kw_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_nist_kw_wrap"] pub fn nist_kw_wrap (ctx : * mut nist_kw_context , mode : nist_kw_mode_t , input : * const :: types :: raw_types :: c_uchar , in_len : size_t , output : * mut :: types :: raw_types :: c_uchar , out_len : * mut size_t , out_size : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_nist_kw_unwrap"] pub fn nist_kw_unwrap (ctx : * mut nist_kw_context , mode : nist_kw_mode_t , input : * const :: types :: raw_types :: c_uchar , in_len : size_t , output : * mut :: types :: raw_types :: c_uchar , out_len : * mut size_t , out_size : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_nist_kw_self_test"] pub fn nist_kw_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_memory_buffer_alloc_init"] pub fn memory_buffer_alloc_init (buf : * mut :: types :: raw_types :: c_uchar , len : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_memory_buffer_alloc_free"] pub fn memory_buffer_alloc_free () ; } extern "C" { # [link_name = "\u{1}mbedtls_memory_buffer_set_verify"] pub fn memory_buffer_set_verify (verify : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_memory_buffer_alloc_verify"] pub fn memory_buffer_alloc_verify () -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_memory_buffer_alloc_self_test"] pub fn memory_buffer_alloc_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct md_info_t { pub name : * const :: types :: raw_types :: c_char , pub type_ : md_type_t , pub size : :: types :: raw_types :: c_uchar , pub block_size : :: types :: raw_types :: c_uchar , } # [test] fn bindgen_test_layout_md_info_t () { assert_eq ! (:: core :: mem :: size_of :: < md_info_t > () , 16usize , concat ! ("Size of: " , stringify ! (md_info_t))) ; assert_eq ! (:: core :: mem :: align_of :: < md_info_t > () , 8usize , concat ! ("Alignment of " , stringify ! (md_info_t))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md_info_t > ())) . name as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (md_info_t) , "::" , stringify ! (name))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md_info_t > ())) . type_ as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (md_info_t) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md_info_t > ())) . size as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (md_info_t) , "::" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md_info_t > ())) . block_size as * const _ as usize } , 13usize , concat ! ("Offset of field: " , stringify ! (md_info_t) , "::" , stringify ! (block_size))) ; } impl Default for md_info_t { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_md2_info"] pub static md2_info : md_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_md4_info"] pub static md4_info : md_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_md5_info"] pub static md5_info : md_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_ripemd160_info"] pub static ripemd160_info : md_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_sha1_info"] pub static sha1_info : md_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_sha224_info"] pub static sha224_info : md_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_sha256_info"] pub static sha256_info : md_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_sha384_info"] pub static sha384_info : md_info_t ; } extern "C" { # [link_name = "\u{1}mbedtls_sha512_info"] pub static sha512_info : md_info_t ; } # [repr (C)] # [derive (Copy , Clone)] pub struct md4_context { pub total : [u32 ; 2usize] , pub state : [u32 ; 4usize] , pub buffer : [:: types :: raw_types :: c_uchar ; 64usize] , } # [test] fn bindgen_test_layout_md4_context () { assert_eq ! (:: core :: mem :: size_of :: < md4_context > () , 88usize , concat ! ("Size of: " , stringify ! (md4_context))) ; assert_eq ! (:: core :: mem :: align_of :: < md4_context > () , 4usize , concat ! ("Alignment of " , stringify ! (md4_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md4_context > ())) . total as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (md4_context) , "::" , stringify ! (total))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md4_context > ())) . state as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (md4_context) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md4_context > ())) . buffer as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (md4_context) , "::" , stringify ! (buffer))) ; } impl Default for md4_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_md4_init"] pub fn md4_init (ctx : * mut md4_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_md4_free"] pub fn md4_free (ctx : * mut md4_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_md4_clone"] pub fn md4_clone (dst : * mut md4_context , src : * const md4_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_md4_starts_ret"] pub fn md4_starts_ret (ctx : * mut md4_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md4_update_ret"] pub fn md4_update_ret (ctx : * mut md4_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md4_finish_ret"] pub fn md4_finish_ret (ctx : * mut md4_context , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_internal_md4_process"] pub fn internal_md4_process (ctx : * mut md4_context , data : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md4_starts"] pub fn md4_starts (ctx : * mut md4_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_md4_update"] pub fn md4_update (ctx : * mut md4_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_md4_finish"] pub fn md4_finish (ctx : * mut md4_context , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_md4_process"] pub fn md4_process (ctx : * mut md4_context , data : * const :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_md4_ret"] pub fn md4_ret (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md4"] pub fn md4 (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_md4_self_test"] pub fn md4_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct md2_context { pub cksum : [:: types :: raw_types :: c_uchar ; 16usize] , pub state : [:: types :: raw_types :: c_uchar ; 48usize] , pub buffer : [:: types :: raw_types :: c_uchar ; 16usize] , pub left : size_t , } # [test] fn bindgen_test_layout_md2_context () { assert_eq ! (:: core :: mem :: size_of :: < md2_context > () , 88usize , concat ! ("Size of: " , stringify ! (md2_context))) ; assert_eq ! (:: core :: mem :: align_of :: < md2_context > () , 8usize , concat ! ("Alignment of " , stringify ! (md2_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md2_context > ())) . cksum as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (md2_context) , "::" , stringify ! (cksum))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md2_context > ())) . state as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (md2_context) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md2_context > ())) . buffer as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (md2_context) , "::" , stringify ! (buffer))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < md2_context > ())) . left as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (md2_context) , "::" , stringify ! (left))) ; } impl Default for md2_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_md2_init"] pub fn md2_init (ctx : * mut md2_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_md2_free"] pub fn md2_free (ctx : * mut md2_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_md2_clone"] pub fn md2_clone (dst : * mut md2_context , src : * const md2_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_md2_starts_ret"] pub fn md2_starts_ret (ctx : * mut md2_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md2_update_ret"] pub fn md2_update_ret (ctx : * mut md2_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md2_finish_ret"] pub fn md2_finish_ret (ctx : * mut md2_context , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_internal_md2_process"] pub fn internal_md2_process (ctx : * mut md2_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md2_starts"] pub fn md2_starts (ctx : * mut md2_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_md2_update"] pub fn md2_update (ctx : * mut md2_context , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_md2_finish"] pub fn md2_finish (ctx : * mut md2_context , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_md2_process"] pub fn md2_process (ctx : * mut md2_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_md2_ret"] pub fn md2_ret (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_md2"] pub fn md2 (input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_md2_self_test"] pub fn md2_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_hkdf"] pub fn hkdf (md : * const md_info_t , salt : * const :: types :: raw_types :: c_uchar , salt_len : size_t , ikm : * const :: types :: raw_types :: c_uchar , ikm_len : size_t , info : * const :: types :: raw_types :: c_uchar , info_len : size_t , okm : * mut :: types :: raw_types :: c_uchar , okm_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_hkdf_extract"] pub fn hkdf_extract (md : * const md_info_t , salt : * const :: types :: raw_types :: c_uchar , salt_len : size_t , ikm : * const :: types :: raw_types :: c_uchar , ikm_len : size_t , prk : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_hkdf_expand"] pub fn hkdf_expand (md : * const md_info_t , prk : * const :: types :: raw_types :: c_uchar , prk_len : size_t , info : * const :: types :: raw_types :: c_uchar , info_len : size_t , okm : * mut :: types :: raw_types :: c_uchar , okm_len : size_t) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct gcm_context { pub cipher_ctx : cipher_context_t , pub HL : [u64 ; 16usize] , pub HH : [u64 ; 16usize] , pub len : u64 , pub add_len : u64 , pub base_ectr : [:: types :: raw_types :: c_uchar ; 16usize] , pub y : [:: types :: raw_types :: c_uchar ; 16usize] , pub buf : [:: types :: raw_types :: c_uchar ; 16usize] , pub mode : :: types :: raw_types :: c_int , } # [test] fn bindgen_test_layout_gcm_context () { assert_eq ! (:: core :: mem :: size_of :: < gcm_context > () , 424usize , concat ! ("Size of: " , stringify ! (gcm_context))) ; assert_eq ! (:: core :: mem :: align_of :: < gcm_context > () , 8usize , concat ! ("Alignment of " , stringify ! (gcm_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < gcm_context > ())) . cipher_ctx as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (gcm_context) , "::" , stringify ! (cipher_ctx))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < gcm_context > ())) . HL as * const _ as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (gcm_context) , "::" , stringify ! (HL))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < gcm_context > ())) . HH as * const _ as usize } , 224usize , concat ! ("Offset of field: " , stringify ! (gcm_context) , "::" , stringify ! (HH))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < gcm_context > ())) . len as * const _ as usize } , 352usize , concat ! ("Offset of field: " , stringify ! (gcm_context) , "::" , stringify ! (len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < gcm_context > ())) . add_len as * const _ as usize } , 360usize , concat ! ("Offset of field: " , stringify ! (gcm_context) , "::" , stringify ! (add_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < gcm_context > ())) . base_ectr as * const _ as usize } , 368usize , concat ! ("Offset of field: " , stringify ! (gcm_context) , "::" , stringify ! (base_ectr))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < gcm_context > ())) . y as * const _ as usize } , 384usize , concat ! ("Offset of field: " , stringify ! (gcm_context) , "::" , stringify ! (y))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < gcm_context > ())) . buf as * const _ as usize } , 400usize , concat ! ("Offset of field: " , stringify ! (gcm_context) , "::" , stringify ! (buf))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < gcm_context > ())) . mode as * const _ as usize } , 416usize , concat ! ("Offset of field: " , stringify ! (gcm_context) , "::" , stringify ! (mode))) ; } impl Default for gcm_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_gcm_init"] pub fn gcm_init (ctx : * mut gcm_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_gcm_setkey"] pub fn gcm_setkey (ctx : * mut gcm_context , cipher : cipher_id_t , key : * const :: types :: raw_types :: c_uchar , keybits : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_gcm_crypt_and_tag"] pub fn gcm_crypt_and_tag (ctx : * mut gcm_context , mode : :: types :: raw_types :: c_int , length : size_t , iv : * const :: types :: raw_types :: c_uchar , iv_len : size_t , add : * const :: types :: raw_types :: c_uchar , add_len : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar , tag_len : size_t , tag : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_gcm_auth_decrypt"] pub fn gcm_auth_decrypt (ctx : * mut gcm_context , length : size_t , iv : * const :: types :: raw_types :: c_uchar , iv_len : size_t , add : * const :: types :: raw_types :: c_uchar , add_len : size_t , tag : * const :: types :: raw_types :: c_uchar , tag_len : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_gcm_starts"] pub fn gcm_starts (ctx : * mut gcm_context , mode : :: types :: raw_types :: c_int , iv : * const :: types :: raw_types :: c_uchar , iv_len : size_t , add : * const :: types :: raw_types :: c_uchar , add_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_gcm_update"] pub fn gcm_update (ctx : * mut gcm_context , length : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_gcm_finish"] pub fn gcm_finish (ctx : * mut gcm_context , tag : * mut :: types :: raw_types :: c_uchar , tag_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_gcm_free"] pub fn gcm_free (ctx : * mut gcm_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_gcm_self_test"] pub fn gcm_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_strerror"] pub fn strerror (errnum : :: types :: raw_types :: c_int , buffer : * mut :: types :: raw_types :: c_char , buflen : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_high_level_strerr"] pub fn high_level_strerr (error_code : :: types :: raw_types :: c_int) -> * const :: types :: raw_types :: c_char ; } extern "C" { # [link_name = "\u{1}mbedtls_low_level_strerr"] pub fn low_level_strerr (error_code : :: types :: raw_types :: c_int) -> * const :: types :: raw_types :: c_char ; } extern "C" { # [link_name = "\u{1}mbedtls_platform_entropy_poll"] pub fn platform_entropy_poll (data : * mut :: types :: raw_types :: c_void , output : * mut :: types :: raw_types :: c_uchar , len : size_t , olen : * mut size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_hardclock_poll"] pub fn hardclock_poll (data : * mut :: types :: raw_types :: c_void , output : * mut :: types :: raw_types :: c_uchar , len : size_t , olen : * mut size_t) -> :: types :: raw_types :: c_int ; } pub type entropy_f_source_ptr = :: core :: option :: Option < unsafe extern "C" fn (data : * mut :: types :: raw_types :: c_void , output : * mut :: types :: raw_types :: c_uchar , len : size_t , olen : * mut size_t) -> :: types :: raw_types :: c_int > ; # [repr (C)] # [derive (Copy , Clone)] pub struct entropy_source_state { pub f_source : entropy_f_source_ptr , pub p_source : * mut :: types :: raw_types :: c_void , pub size : size_t , pub threshold : size_t , pub strong : :: types :: raw_types :: c_int , } # [test] fn bindgen_test_layout_entropy_source_state () { assert_eq ! (:: core :: mem :: size_of :: < entropy_source_state > () , 40usize , concat ! ("Size of: " , stringify ! (entropy_source_state))) ; assert_eq ! (:: core :: mem :: align_of :: < entropy_source_state > () , 8usize , concat ! ("Alignment of " , stringify ! (entropy_source_state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < entropy_source_state > ())) . f_source as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (entropy_source_state) , "::" , stringify ! (f_source))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < entropy_source_state > ())) . p_source as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (entropy_source_state) , "::" , stringify ! (p_source))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < entropy_source_state > ())) . size as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (entropy_source_state) , "::" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < entropy_source_state > ())) . threshold as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (entropy_source_state) , "::" , stringify ! (threshold))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < entropy_source_state > ())) . strong as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (entropy_source_state) , "::" , stringify ! (strong))) ; } impl Default for entropy_source_state { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct entropy_context { pub accumulator_started : :: types :: raw_types :: c_int , pub accumulator : sha512_context , pub source_count : :: types :: raw_types :: c_int , pub source : [entropy_source_state ; 20usize] , pub mutex : threading_mutex_t , } # [test] fn bindgen_test_layout_entropy_context () { assert_eq ! (:: core :: mem :: size_of :: < entropy_context > () , 1080usize , concat ! ("Size of: " , stringify ! (entropy_context))) ; assert_eq ! (:: core :: mem :: align_of :: < entropy_context > () , 8usize , concat ! ("Alignment of " , stringify ! (entropy_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < entropy_context > ())) . accumulator_started as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (entropy_context) , "::" , stringify ! (accumulator_started))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < entropy_context > ())) . accumulator as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (entropy_context) , "::" , stringify ! (accumulator))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < entropy_context > ())) . source_count as * const _ as usize } , 224usize , concat ! ("Offset of field: " , stringify ! (entropy_context) , "::" , stringify ! (source_count))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < entropy_context > ())) . source as * const _ as usize } , 232usize , concat ! ("Offset of field: " , stringify ! (entropy_context) , "::" , stringify ! (source))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < entropy_context > ())) . mutex as * const _ as usize } , 1032usize , concat ! ("Offset of field: " , stringify ! (entropy_context) , "::" , stringify ! (mutex))) ; } impl Default for entropy_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_entropy_init"] pub fn entropy_init (ctx : * mut entropy_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_entropy_free"] pub fn entropy_free (ctx : * mut entropy_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_entropy_add_source"] pub fn entropy_add_source (ctx : * mut entropy_context , f_source : entropy_f_source_ptr , p_source : * mut :: types :: raw_types :: c_void , threshold : size_t , strong : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_entropy_gather"] pub fn entropy_gather (ctx : * mut entropy_context) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_entropy_func"] pub fn entropy_func (data : * mut :: types :: raw_types :: c_void , output : * mut :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_entropy_update_manual"] pub fn entropy_update_manual (ctx : * mut entropy_context , data : * const :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_entropy_write_seed_file"] pub fn entropy_write_seed_file (ctx : * mut entropy_context , path : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_entropy_update_seed_file"] pub fn entropy_update_seed_file (ctx : * mut entropy_context , path : * const :: types :: raw_types :: c_char) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_entropy_self_test"] pub fn entropy_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct des_context { pub sk : [u32 ; 32usize] , } # [test] fn bindgen_test_layout_des_context () { assert_eq ! (:: core :: mem :: size_of :: < des_context > () , 128usize , concat ! ("Size of: " , stringify ! (des_context))) ; assert_eq ! (:: core :: mem :: align_of :: < des_context > () , 4usize , concat ! ("Alignment of " , stringify ! (des_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < des_context > ())) . sk as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (des_context) , "::" , stringify ! (sk))) ; } impl Default for des_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct des3_context { pub sk : [u32 ; 96usize] , } # [test] fn bindgen_test_layout_des3_context () { assert_eq ! (:: core :: mem :: size_of :: < des3_context > () , 384usize , concat ! ("Size of: " , stringify ! (des3_context))) ; assert_eq ! (:: core :: mem :: align_of :: < des3_context > () , 4usize , concat ! ("Alignment of " , stringify ! (des3_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < des3_context > ())) . sk as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (des3_context) , "::" , stringify ! (sk))) ; } impl Default for des3_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_des_init"] pub fn des_init (ctx : * mut des_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_des_free"] pub fn des_free (ctx : * mut des_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_des3_init"] pub fn des3_init (ctx : * mut des3_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_des3_free"] pub fn des3_free (ctx : * mut des3_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_des_key_set_parity"] pub fn des_key_set_parity (key : * mut :: types :: raw_types :: c_uchar) ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_des_key_check_key_parity"] pub fn des_key_check_key_parity (key : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_des_key_check_weak"] pub fn des_key_check_weak (key : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_des_setkey_enc"] pub fn des_setkey_enc (ctx : * mut des_context , key : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_des_setkey_dec"] pub fn des_setkey_dec (ctx : * mut des_context , key : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_des3_set2key_enc"] pub fn des3_set2key_enc (ctx : * mut des3_context , key : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_des3_set2key_dec"] pub fn des3_set2key_dec (ctx : * mut des3_context , key : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_des3_set3key_enc"] pub fn des3_set3key_enc (ctx : * mut des3_context , key : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_des3_set3key_dec"] pub fn des3_set3key_dec (ctx : * mut des3_context , key : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_des_crypt_ecb"] pub fn des_crypt_ecb (ctx : * mut des_context , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_des_crypt_cbc"] pub fn des_crypt_cbc (ctx : * mut des_context , mode : :: types :: raw_types :: c_int , length : size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_des3_crypt_ecb"] pub fn des3_crypt_ecb (ctx : * mut des3_context , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_des3_crypt_cbc"] pub fn des3_crypt_cbc (ctx : * mut des3_context , mode : :: types :: raw_types :: c_int , length : size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_des_setkey"] pub fn des_setkey (SK : * mut u32 , key : * const :: types :: raw_types :: c_uchar) ; } extern "C" { # [must_use] # [link_name = "\u{1}mbedtls_des_self_test"] pub fn des_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_debug_set_threshold"] pub fn debug_set_threshold (threshold : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_debug_print_msg"] pub fn debug_print_msg (ssl : * const ssl_context , level : :: types :: raw_types :: c_int , file : * const :: types :: raw_types :: c_char , line : :: types :: raw_types :: c_int , format : * const :: types :: raw_types :: c_char , ...) ; } extern "C" { # [link_name = "\u{1}mbedtls_debug_print_ret"] pub fn debug_print_ret (ssl : * const ssl_context , level : :: types :: raw_types :: c_int , file : * const :: types :: raw_types :: c_char , line : :: types :: raw_types :: c_int , text : * const :: types :: raw_types :: c_char , ret : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_debug_print_buf"] pub fn debug_print_buf (ssl : * const ssl_context , level : :: types :: raw_types :: c_int , file : * const :: types :: raw_types :: c_char , line : :: types :: raw_types :: c_int , text : * const :: types :: raw_types :: c_char , buf : * const :: types :: raw_types :: c_uchar , len : size_t) ; } extern "C" { # [link_name = "\u{1}mbedtls_debug_print_mpi"] pub fn debug_print_mpi (ssl : * const ssl_context , level : :: types :: raw_types :: c_int , file : * const :: types :: raw_types :: c_char , line : :: types :: raw_types :: c_int , text : * const :: types :: raw_types :: c_char , X : * const mpi) ; } extern "C" { # [link_name = "\u{1}mbedtls_debug_print_ecp"] pub fn debug_print_ecp (ssl : * const ssl_context , level : :: types :: raw_types :: c_int , file : * const :: types :: raw_types :: c_char , line : :: types :: raw_types :: c_int , text : * const :: types :: raw_types :: c_char , X : * const ecp_point) ; } extern "C" { # [link_name = "\u{1}mbedtls_debug_print_crt"] pub fn debug_print_crt (ssl : * const ssl_context , level : :: types :: raw_types :: c_int , file : * const :: types :: raw_types :: c_char , line : :: types :: raw_types :: c_int , text : * const :: types :: raw_types :: c_char , crt : * const x509_crt) ; } pub const DEBUG_ECDH_Q : debug_ecdh_attr = 0 ; pub const DEBUG_ECDH_QP : debug_ecdh_attr = 1 ; pub const DEBUG_ECDH_Z : debug_ecdh_attr = 2 ; pub type debug_ecdh_attr = u32 ; extern "C" { # [link_name = "\u{1}mbedtls_debug_printf_ecdh"] pub fn debug_printf_ecdh (ssl : * const ssl_context , level : :: types :: raw_types :: c_int , file : * const :: types :: raw_types :: c_char , line : :: types :: raw_types :: c_int , ecdh : * const ecdh_context , attr : debug_ecdh_attr) ; } extern "C" { # [link_name = "\u{1}mbedtls_ct_memcmp"] pub fn ct_memcmp (a : * const :: types :: raw_types :: c_void , b : * const :: types :: raw_types :: c_void , n : size_t) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct cmac_context_t { pub state : [:: types :: raw_types :: c_uchar ; 16usize] , pub unprocessed_block : [:: types :: raw_types :: c_uchar ; 16usize] , pub unprocessed_len : size_t , } # [test] fn bindgen_test_layout_cmac_context_t () { assert_eq ! (:: core :: mem :: size_of :: < cmac_context_t > () , 40usize , concat ! ("Size of: " , stringify ! (cmac_context_t))) ; assert_eq ! (:: core :: mem :: align_of :: < cmac_context_t > () , 8usize , concat ! ("Alignment of " , stringify ! (cmac_context_t))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cmac_context_t > ())) . state as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (cmac_context_t) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cmac_context_t > ())) . unprocessed_block as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (cmac_context_t) , "::" , stringify ! (unprocessed_block))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cmac_context_t > ())) . unprocessed_len as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (cmac_context_t) , "::" , stringify ! (unprocessed_len))) ; } impl Default for cmac_context_t { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_cipher_cmac_starts"] pub fn cipher_cmac_starts (ctx : * mut cipher_context_t , key : * const :: types :: raw_types :: c_uchar , keybits : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_cmac_update"] pub fn cipher_cmac_update (ctx : * mut cipher_context_t , input : * const :: types :: raw_types :: c_uchar , ilen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_cmac_finish"] pub fn cipher_cmac_finish (ctx : * mut cipher_context_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_cmac_reset"] pub fn cipher_cmac_reset (ctx : * mut cipher_context_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_cmac"] pub fn cipher_cmac (cipher_info : * const cipher_info_t , key : * const :: types :: raw_types :: c_uchar , keylen : size_t , input : * const :: types :: raw_types :: c_uchar , ilen : size_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_aes_cmac_prf_128"] pub fn aes_cmac_prf_128 (key : * const :: types :: raw_types :: c_uchar , key_len : size_t , input : * const :: types :: raw_types :: c_uchar , in_len : size_t , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_cmac_self_test"] pub fn cmac_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct cipher_base_t { pub cipher : cipher_id_t , pub ecb_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , mode : operation_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int > , pub cbc_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , mode : operation_t , length : size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int > , pub cfb_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , mode : operation_t , length : size_t , iv_off : * mut size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int > , pub ofb_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , length : size_t , iv_off : * mut size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int > , pub ctr_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , length : size_t , nc_off : * mut size_t , nonce_counter : * mut :: types :: raw_types :: c_uchar , stream_block : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int > , pub xts_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , mode : operation_t , length : size_t , data_unit : * const :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int > , pub stream_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , length : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int > , pub setkey_enc_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , key : * const :: types :: raw_types :: c_uchar , key_bitlen : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int > , pub setkey_dec_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void , key : * const :: types :: raw_types :: c_uchar , key_bitlen : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int > , pub ctx_alloc_func : :: core :: option :: Option < unsafe extern "C" fn () -> * mut :: types :: raw_types :: c_void > , pub ctx_free_func : :: core :: option :: Option < unsafe extern "C" fn (ctx : * mut :: types :: raw_types :: c_void) > , } # [test] fn bindgen_test_layout_cipher_base_t () { assert_eq ! (:: core :: mem :: size_of :: < cipher_base_t > () , 96usize , concat ! ("Size of: " , stringify ! (cipher_base_t))) ; assert_eq ! (:: core :: mem :: align_of :: < cipher_base_t > () , 8usize , concat ! ("Alignment of " , stringify ! (cipher_base_t))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_base_t > ())) . cipher as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (cipher_base_t) , "::" , stringify ! (cipher))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_base_t > ())) . ecb_func as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (cipher_base_t) , "::" , stringify ! (ecb_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_base_t > ())) . cbc_func as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (cipher_base_t) , "::" , stringify ! (cbc_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_base_t > ())) . cfb_func as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (cipher_base_t) , "::" , stringify ! (cfb_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_base_t > ())) . ofb_func as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (cipher_base_t) , "::" , stringify ! (ofb_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_base_t > ())) . ctr_func as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (cipher_base_t) , "::" , stringify ! (ctr_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_base_t > ())) . xts_func as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (cipher_base_t) , "::" , stringify ! (xts_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_base_t > ())) . stream_func as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (cipher_base_t) , "::" , stringify ! (stream_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_base_t > ())) . setkey_enc_func as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (cipher_base_t) , "::" , stringify ! (setkey_enc_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_base_t > ())) . setkey_dec_func as * const _ as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (cipher_base_t) , "::" , stringify ! (setkey_dec_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_base_t > ())) . ctx_alloc_func as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (cipher_base_t) , "::" , stringify ! (ctx_alloc_func))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_base_t > ())) . ctx_free_func as * const _ as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (cipher_base_t) , "::" , stringify ! (ctx_free_func))) ; } impl Default for cipher_base_t { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } # [repr (C)] # [derive (Copy , Clone)] pub struct cipher_definition_t { pub type_ : cipher_type_t , pub info : * const cipher_info_t , } # [test] fn bindgen_test_layout_cipher_definition_t () { assert_eq ! (:: core :: mem :: size_of :: < cipher_definition_t > () , 16usize , concat ! ("Size of: " , stringify ! (cipher_definition_t))) ; assert_eq ! (:: core :: mem :: align_of :: < cipher_definition_t > () , 8usize , concat ! ("Alignment of " , stringify ! (cipher_definition_t))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_definition_t > ())) . type_ as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (cipher_definition_t) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < cipher_definition_t > ())) . info as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (cipher_definition_t) , "::" , stringify ! (info))) ; } impl Default for cipher_definition_t { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_cipher_definitions"] pub static mut cipher_definitions : [cipher_definition_t ; 0usize] ; } extern "C" { # [link_name = "\u{1}mbedtls_cipher_supported"] pub static mut cipher_supported : [:: types :: raw_types :: c_int ; 0usize] ; } pub const CHACHAPOLY_ENCRYPT : chachapoly_mode_t = 0 ; pub const CHACHAPOLY_DECRYPT : chachapoly_mode_t = 1 ; pub type chachapoly_mode_t = u32 ; # [repr (C)] # [derive (Copy , Clone)] pub struct chachapoly_context { pub chacha20_ctx : chacha20_context , pub poly1305_ctx : poly1305_context , pub aad_len : u64 , pub ciphertext_len : u64 , pub state : :: types :: raw_types :: c_int , pub mode : chachapoly_mode_t , } # [test] fn bindgen_test_layout_chachapoly_context () { assert_eq ! (:: core :: mem :: size_of :: < chachapoly_context > () , 240usize , concat ! ("Size of: " , stringify ! (chachapoly_context))) ; assert_eq ! (:: core :: mem :: align_of :: < chachapoly_context > () , 8usize , concat ! ("Alignment of " , stringify ! (chachapoly_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < chachapoly_context > ())) . chacha20_ctx as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (chachapoly_context) , "::" , stringify ! (chacha20_ctx))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < chachapoly_context > ())) . poly1305_ctx as * const _ as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (chachapoly_context) , "::" , stringify ! (poly1305_ctx))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < chachapoly_context > ())) . aad_len as * const _ as usize } , 216usize , concat ! ("Offset of field: " , stringify ! (chachapoly_context) , "::" , stringify ! (aad_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < chachapoly_context > ())) . ciphertext_len as * const _ as usize } , 224usize , concat ! ("Offset of field: " , stringify ! (chachapoly_context) , "::" , stringify ! (ciphertext_len))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < chachapoly_context > ())) . state as * const _ as usize } , 232usize , concat ! ("Offset of field: " , stringify ! (chachapoly_context) , "::" , stringify ! (state))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < chachapoly_context > ())) . mode as * const _ as usize } , 236usize , concat ! ("Offset of field: " , stringify ! (chachapoly_context) , "::" , stringify ! (mode))) ; } impl Default for chachapoly_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_chachapoly_init"] pub fn chachapoly_init (ctx : * mut chachapoly_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_chachapoly_free"] pub fn chachapoly_free (ctx : * mut chachapoly_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_chachapoly_setkey"] pub fn chachapoly_setkey (ctx : * mut chachapoly_context , key : * const :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_chachapoly_starts"] pub fn chachapoly_starts (ctx : * mut chachapoly_context , nonce : * const :: types :: raw_types :: c_uchar , mode : chachapoly_mode_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_chachapoly_update_aad"] pub fn chachapoly_update_aad (ctx : * mut chachapoly_context , aad : * const :: types :: raw_types :: c_uchar , aad_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_chachapoly_update"] pub fn chachapoly_update (ctx : * mut chachapoly_context , len : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_chachapoly_finish"] pub fn chachapoly_finish (ctx : * mut chachapoly_context , mac : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_chachapoly_encrypt_and_tag"] pub fn chachapoly_encrypt_and_tag (ctx : * mut chachapoly_context , length : size_t , nonce : * const :: types :: raw_types :: c_uchar , aad : * const :: types :: raw_types :: c_uchar , aad_len : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar , tag : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_chachapoly_auth_decrypt"] pub fn chachapoly_auth_decrypt (ctx : * mut chachapoly_context , length : size_t , nonce : * const :: types :: raw_types :: c_uchar , aad : * const :: types :: raw_types :: c_uchar , aad_len : size_t , tag : * const :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_chachapoly_self_test"] pub fn chachapoly_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct ccm_context { pub cipher_ctx : cipher_context_t , } # [test] fn bindgen_test_layout_ccm_context () { assert_eq ! (:: core :: mem :: size_of :: < ccm_context > () , 96usize , concat ! ("Size of: " , stringify ! (ccm_context))) ; assert_eq ! (:: core :: mem :: align_of :: < ccm_context > () , 8usize , concat ! ("Alignment of " , stringify ! (ccm_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < ccm_context > ())) . cipher_ctx as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (ccm_context) , "::" , stringify ! (cipher_ctx))) ; } impl Default for ccm_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_ccm_init"] pub fn ccm_init (ctx : * mut ccm_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ccm_setkey"] pub fn ccm_setkey (ctx : * mut ccm_context , cipher : cipher_id_t , key : * const :: types :: raw_types :: c_uchar , keybits : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ccm_free"] pub fn ccm_free (ctx : * mut ccm_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_ccm_encrypt_and_tag"] pub fn ccm_encrypt_and_tag (ctx : * mut ccm_context , length : size_t , iv : * const :: types :: raw_types :: c_uchar , iv_len : size_t , add : * const :: types :: raw_types :: c_uchar , add_len : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar , tag : * mut :: types :: raw_types :: c_uchar , tag_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ccm_star_encrypt_and_tag"] pub fn ccm_star_encrypt_and_tag (ctx : * mut ccm_context , length : size_t , iv : * const :: types :: raw_types :: c_uchar , iv_len : size_t , add : * const :: types :: raw_types :: c_uchar , add_len : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar , tag : * mut :: types :: raw_types :: c_uchar , tag_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ccm_auth_decrypt"] pub fn ccm_auth_decrypt (ctx : * mut ccm_context , length : size_t , iv : * const :: types :: raw_types :: c_uchar , iv_len : size_t , add : * const :: types :: raw_types :: c_uchar , add_len : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar , tag : * const :: types :: raw_types :: c_uchar , tag_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ccm_star_auth_decrypt"] pub fn ccm_star_auth_decrypt (ctx : * mut ccm_context , length : size_t , iv : * const :: types :: raw_types :: c_uchar , iv_len : size_t , add : * const :: types :: raw_types :: c_uchar , add_len : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar , tag : * const :: types :: raw_types :: c_uchar , tag_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_ccm_self_test"] pub fn ccm_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct camellia_context { pub nr : :: types :: raw_types :: c_int , pub rk : [u32 ; 68usize] , } # [test] fn bindgen_test_layout_camellia_context () { assert_eq ! (:: core :: mem :: size_of :: < camellia_context > () , 276usize , concat ! ("Size of: " , stringify ! (camellia_context))) ; assert_eq ! (:: core :: mem :: align_of :: < camellia_context > () , 4usize , concat ! ("Alignment of " , stringify ! (camellia_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < camellia_context > ())) . nr as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (camellia_context) , "::" , stringify ! (nr))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < camellia_context > ())) . rk as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (camellia_context) , "::" , stringify ! (rk))) ; } impl Default for camellia_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_camellia_init"] pub fn camellia_init (ctx : * mut camellia_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_camellia_free"] pub fn camellia_free (ctx : * mut camellia_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_camellia_setkey_enc"] pub fn camellia_setkey_enc (ctx : * mut camellia_context , key : * const :: types :: raw_types :: c_uchar , keybits : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_camellia_setkey_dec"] pub fn camellia_setkey_dec (ctx : * mut camellia_context , key : * const :: types :: raw_types :: c_uchar , keybits : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_camellia_crypt_ecb"] pub fn camellia_crypt_ecb (ctx : * mut camellia_context , mode : :: types :: raw_types :: c_int , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_camellia_crypt_cbc"] pub fn camellia_crypt_cbc (ctx : * mut camellia_context , mode : :: types :: raw_types :: c_int , length : size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_camellia_crypt_cfb128"] pub fn camellia_crypt_cfb128 (ctx : * mut camellia_context , mode : :: types :: raw_types :: c_int , length : size_t , iv_off : * mut size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_camellia_crypt_ctr"] pub fn camellia_crypt_ctr (ctx : * mut camellia_context , length : size_t , nc_off : * mut size_t , nonce_counter : * mut :: types :: raw_types :: c_uchar , stream_block : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_camellia_self_test"] pub fn camellia_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct blowfish_context { pub P : [u32 ; 18usize] , pub S : [[u32 ; 256usize] ; 4usize] , } # [test] fn bindgen_test_layout_blowfish_context () { assert_eq ! (:: core :: mem :: size_of :: < blowfish_context > () , 4168usize , concat ! ("Size of: " , stringify ! (blowfish_context))) ; assert_eq ! (:: core :: mem :: align_of :: < blowfish_context > () , 4usize , concat ! ("Alignment of " , stringify ! (blowfish_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < blowfish_context > ())) . P as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (blowfish_context) , "::" , stringify ! (P))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < blowfish_context > ())) . S as * const _ as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (blowfish_context) , "::" , stringify ! (S))) ; } impl Default for blowfish_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_blowfish_init"] pub fn blowfish_init (ctx : * mut blowfish_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_blowfish_free"] pub fn blowfish_free (ctx : * mut blowfish_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_blowfish_setkey"] pub fn blowfish_setkey (ctx : * mut blowfish_context , key : * const :: types :: raw_types :: c_uchar , keybits : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_blowfish_crypt_ecb"] pub fn blowfish_crypt_ecb (ctx : * mut blowfish_context , mode : :: types :: raw_types :: c_int , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_blowfish_crypt_cbc"] pub fn blowfish_crypt_cbc (ctx : * mut blowfish_context , mode : :: types :: raw_types :: c_int , length : size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_blowfish_crypt_cfb64"] pub fn blowfish_crypt_cfb64 (ctx : * mut blowfish_context , mode : :: types :: raw_types :: c_int , length : size_t , iv_off : * mut size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_blowfish_crypt_ctr"] pub fn blowfish_crypt_ctr (ctx : * mut blowfish_context , length : size_t , nc_off : * mut size_t , nonce_counter : * mut :: types :: raw_types :: c_uchar , stream_block : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_base64_encode"] pub fn base64_encode (dst : * mut :: types :: raw_types :: c_uchar , dlen : size_t , olen : * mut size_t , src : * const :: types :: raw_types :: c_uchar , slen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_base64_decode"] pub fn base64_decode (dst : * mut :: types :: raw_types :: c_uchar , dlen : size_t , olen : * mut size_t , src : * const :: types :: raw_types :: c_uchar , slen : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_base64_self_test"] pub fn base64_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_len"] pub fn asn1_write_len (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_tag"] pub fn asn1_write_tag (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , tag : :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_raw_buffer"] pub fn asn1_write_raw_buffer (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , buf : * const :: types :: raw_types :: c_uchar , size : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_mpi"] pub fn asn1_write_mpi (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , X : * const mpi) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_null"] pub fn asn1_write_null (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_oid"] pub fn asn1_write_oid (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , oid : * const :: types :: raw_types :: c_char , oid_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_algorithm_identifier"] pub fn asn1_write_algorithm_identifier (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , oid : * const :: types :: raw_types :: c_char , oid_len : size_t , par_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_bool"] pub fn asn1_write_bool (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , boolean : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_int"] pub fn asn1_write_int (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , val : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_enum"] pub fn asn1_write_enum (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , val : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_tagged_string"] pub fn asn1_write_tagged_string (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , tag : :: types :: raw_types :: c_int , text : * const :: types :: raw_types :: c_char , text_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_printable_string"] pub fn asn1_write_printable_string (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , text : * const :: types :: raw_types :: c_char , text_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_utf8_string"] pub fn asn1_write_utf8_string (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , text : * const :: types :: raw_types :: c_char , text_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_ia5_string"] pub fn asn1_write_ia5_string (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , text : * const :: types :: raw_types :: c_char , text_len : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_bitstring"] pub fn asn1_write_bitstring (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , buf : * const :: types :: raw_types :: c_uchar , bits : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_named_bitstring"] pub fn asn1_write_named_bitstring (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , buf : * const :: types :: raw_types :: c_uchar , bits : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_write_octet_string"] pub fn asn1_write_octet_string (p : * mut * mut :: types :: raw_types :: c_uchar , start : * mut :: types :: raw_types :: c_uchar , buf : * const :: types :: raw_types :: c_uchar , size : size_t) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_asn1_store_named_data"] pub fn asn1_store_named_data (list : * mut * mut asn1_named_data , oid : * const :: types :: raw_types :: c_char , oid_len : size_t , val : * const :: types :: raw_types :: c_uchar , val_len : size_t) -> * mut asn1_named_data ; } # [repr (C)] # [derive (Copy , Clone)] pub struct aria_context { pub nr : :: types :: raw_types :: c_uchar , pub rk : [[u32 ; 4usize] ; 17usize] , } # [test] fn bindgen_test_layout_aria_context () { assert_eq ! (:: core :: mem :: size_of :: < aria_context > () , 276usize , concat ! ("Size of: " , stringify ! (aria_context))) ; assert_eq ! (:: core :: mem :: align_of :: < aria_context > () , 4usize , concat ! ("Alignment of " , stringify ! (aria_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < aria_context > ())) . nr as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (aria_context) , "::" , stringify ! (nr))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < aria_context > ())) . rk as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (aria_context) , "::" , stringify ! (rk))) ; } impl Default for aria_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_aria_init"] pub fn aria_init (ctx : * mut aria_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_aria_free"] pub fn aria_free (ctx : * mut aria_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_aria_setkey_enc"] pub fn aria_setkey_enc (ctx : * mut aria_context , key : * const :: types :: raw_types :: c_uchar , keybits : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_aria_setkey_dec"] pub fn aria_setkey_dec (ctx : * mut aria_context , key : * const :: types :: raw_types :: c_uchar , keybits : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_aria_crypt_ecb"] pub fn aria_crypt_ecb (ctx : * mut aria_context , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_aria_crypt_cbc"] pub fn aria_crypt_cbc (ctx : * mut aria_context , mode : :: types :: raw_types :: c_int , length : size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_aria_crypt_cfb128"] pub fn aria_crypt_cfb128 (ctx : * mut aria_context , mode : :: types :: raw_types :: c_int , length : size_t , iv_off : * mut size_t , iv : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_aria_crypt_ctr"] pub fn aria_crypt_ctr (ctx : * mut aria_context , length : size_t , nc_off : * mut size_t , nonce_counter : * mut :: types :: raw_types :: c_uchar , stream_block : * mut :: types :: raw_types :: c_uchar , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_aria_self_test"] pub fn aria_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } # [repr (C)] # [derive (Copy , Clone)] pub struct arc4_context { pub x : :: types :: raw_types :: c_int , pub y : :: types :: raw_types :: c_int , pub m : [:: types :: raw_types :: c_uchar ; 256usize] , } # [test] fn bindgen_test_layout_arc4_context () { assert_eq ! (:: core :: mem :: size_of :: < arc4_context > () , 264usize , concat ! ("Size of: " , stringify ! (arc4_context))) ; assert_eq ! (:: core :: mem :: align_of :: < arc4_context > () , 4usize , concat ! ("Alignment of " , stringify ! (arc4_context))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < arc4_context > ())) . x as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (arc4_context) , "::" , stringify ! (x))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < arc4_context > ())) . y as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (arc4_context) , "::" , stringify ! (y))) ; assert_eq ! (unsafe { & (* (:: core :: ptr :: null :: < arc4_context > ())) . m as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (arc4_context) , "::" , stringify ! (m))) ; } impl Default for arc4_context { fn default () -> Self { unsafe { :: core :: mem :: zeroed () } } } extern "C" { # [link_name = "\u{1}mbedtls_arc4_init"] pub fn arc4_init (ctx : * mut arc4_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_arc4_free"] pub fn arc4_free (ctx : * mut arc4_context) ; } extern "C" { # [link_name = "\u{1}mbedtls_arc4_setup"] pub fn arc4_setup (ctx : * mut arc4_context , key : * const :: types :: raw_types :: c_uchar , keylen : :: types :: raw_types :: c_uint) ; } extern "C" { # [link_name = "\u{1}mbedtls_arc4_crypt"] pub fn arc4_crypt (ctx : * mut arc4_context , length : size_t , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_arc4_self_test"] pub fn arc4_self_test (verbose : :: types :: raw_types :: c_int) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_aesni_has_support"] pub fn aesni_has_support (what : :: types :: raw_types :: c_uint) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_aesni_crypt_ecb"] pub fn aesni_crypt_ecb (ctx : * mut aes_context , mode : :: types :: raw_types :: c_int , input : * const :: types :: raw_types :: c_uchar , output : * mut :: types :: raw_types :: c_uchar) -> :: types :: raw_types :: c_int ; } extern "C" { # [link_name = "\u{1}mbedtls_aesni_gcm_mult"] pub fn aesni_gcm_mult (c : * mut :: types :: raw_types :: c_uchar , a : * const :: types :: raw_types :: c_uchar , b : * const :: types :: raw_types :: c_uchar) ; } extern "C" { # [link_name = "\u{1}mbedtls_aesni_inverse_key"] pub fn aesni_inverse_key (invkey : * mut :: types :: raw_types :: c_uchar , fwdkey : * const :: types :: raw_types :: c_uchar , nr : :: types :: raw_types :: c_int) ; } extern "C" { # [link_name = "\u{1}mbedtls_aesni_setkey_enc"] pub fn aesni_setkey_enc (rk : * mut :: types :: raw_types :: c_uchar , key : * const :: types :: raw_types :: c_uchar , bits : size_t) -> :: types :: raw_types :: c_int ; }impl x509_san_other_name__bindgen_ty_1 { # [deprecated] pub unsafe fn hardware_module_name (& mut self) -> * mut x509_san_other_name__bindgen_ty_1__bindgen_ty_1 { & mut self . hardware_module_name } }impl x509_subject_alternative_name__bindgen_ty_1 { # [deprecated] pub unsafe fn other_name (& mut self) -> * mut x509_san_other_name { & mut self . other_name } # [deprecated] pub unsafe fn unstructured_name (& mut self) -> * mut x509_buf { & mut self . unstructured_name } }impl ssl_premaster_secret { # [deprecated] pub unsafe fn _pms_rsa (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 48usize] { & mut self . _pms_rsa } # [deprecated] pub unsafe fn _pms_dhm (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 1024usize] { & mut self . _pms_dhm } # [deprecated] pub unsafe fn _pms_ecdh (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 66usize] { & mut self . _pms_ecdh } # [deprecated] pub unsafe fn _pms_psk (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 68usize] { & mut self . _pms_psk } # [deprecated] pub unsafe fn _pms_dhe_psk (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 1060usize] { & mut self . _pms_dhe_psk } # [deprecated] pub unsafe fn _pms_rsa_psk (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 84usize] { & mut self . _pms_rsa_psk } # [deprecated] pub unsafe fn _pms_ecdhe_psk (& mut self) -> * mut [:: types :: raw_types :: c_uchar ; 102usize] { & mut self . _pms_ecdhe_psk } }use crate::types::*;
